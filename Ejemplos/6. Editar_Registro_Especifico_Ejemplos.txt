
/* ============================================================================================
   PROCEDIMIENTO: SP_EditarPais  (VERSIÓN PRO “REAL”: Lock determinístico + SIN CAMBIOS + 1062 controlado)
   ============================================================================================

   OBJETIVO
   --------
   Editar Código y Nombre de un País, con:
   - Validaciones previas entendibles (mensajes claros)
   - “SIN_CAMBIOS” (si el usuario no cambió nada, no hacemos UPDATE)
   - Blindaje contra duplicados (Codigo único / Nombre único)
   - Manejo “PRO” de concurrencia: 1062 => respuesta controlada “CONFLICTO”
   - Lock determinístico de filas para minimizar deadlocks en escenarios de “intercambio” (swap)

   ESCENARIO CLÁSICO DE DEADLOCK (POR QUÉ AQUÍ SÍ IMPORTA “LOCK DETERMINÍSTICO”)
   ----------------------------------------------------------------------------
   Caso:
   - Usuario A edita País #1 (MEX) y lo quiere cambiar a Codigo='USA'
   - Usuario B edita País #2 (USA) y lo quiere cambiar a Codigo='MEX'
   Sin lock determinístico, podría ocurrir:
   - A bloquea País #1 (FOR UPDATE)
   - B bloquea País #2 (FOR UPDATE)
   - A intenta bloquear País #2 (para validar duplicado por código)
   - B intenta bloquear País #1 (para validar duplicado por código)
   => DEADLOCK.

   SOLUCIÓN
   --------
   En vez de “bloquear primero el país a editar y luego el posible conflicto” en orden variable,
   hacemos un lock determinístico de TODAS las filas relevantes (máximo 3):
     - El País que se edita (_Id_Pais)
     - El País que ya tenga el nuevo Código (si existe)
     - El País que ya tenga el nuevo Nombre (si existe)
   Y las bloqueamos SIEMPRE en orden ascendente de Id_Pais.

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   1) El País a editar DEBE existir.
   2) _Nuevo_Codigo y _Nuevo_Nombre son obligatorios.
   3) No puede existir OTRO País con:
      - el mismo Codigo
      - el mismo Nombre
      (excluimos el mismo Id_Pais para permitir guardar sin cambios)
   4) Si no cambió nada => Accion = 'SIN_CAMBIOS'
   5) Si en UPDATE ocurre 1062 => Accion = 'CONFLICTO' (controlado)

   SOBRE LOS RESETEOS A NULL ANTES DE SELECT ... INTO
   -------------------------------------------------
   En MySQL, si un SELECT ... INTO no encuentra filas:
   - NO asigna nada y la variable conserva el valor anterior.
   Por eso antes de cada SELECT ... INTO hacemos SET var = NULL.

   RESULTADO
   ---------
   ÉXITO:
     - Mensaje
     - Accion = 'ACTUALIZADA'
     - Id_Pais

   SIN CAMBIOS:
     - Mensaje
     - Accion = 'SIN_CAMBIOS'
     - Id_Pais

   CONFLICTO (1062):
     - Mensaje
     - Accion = 'CONFLICTO'
     - Campo = 'CODIGO' | 'NOMBRE'
     - Id_Conflicto
     - Id_Pais_Que_Intentabas_Editar
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_EditarPais$$
CREATE PROCEDURE SP_EditarPais(
    IN _Id_Pais INT,
    IN _Nuevo_Codigo VARCHAR(50),
    IN _Nuevo_Nombre VARCHAR(255)
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0) VARIABLES
       ======================================================================================== */

    /* Valores actuales del país (para “SIN_CAMBIOS”) */
    DECLARE v_Codigo_Actual VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre_Actual VARCHAR(255) DEFAULT NULL;

    /* Posibles filas “en conflicto” (por código o por nombre) */
    DECLARE v_Id_Pais_DupCodigo INT DEFAULT NULL;
    DECLARE v_Id_Pais_DupNombre INT DEFAULT NULL;

    /* Auxiliar genérico para validar existencia en locks */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Auxiliar para pre-checks finales (duplicidad) */
    DECLARE v_DupId INT DEFAULT NULL;

    /* Bandera de choque 1062 en UPDATE */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* Para respuesta de conflicto controlado */
    DECLARE v_Id_Conflicto INT DEFAULT NULL;
    DECLARE v_Campo_Conflicto VARCHAR(20) DEFAULT NULL;

    /* Para lock determinístico (3 ids máximo) */
    DECLARE v_L1 INT DEFAULT NULL;
    DECLARE v_L2 INT DEFAULT NULL;
    DECLARE v_L3 INT DEFAULT NULL;
    DECLARE v_Min INT DEFAULT NULL;

    /* ========================================================================================
       PARTE 1) HANDLERS
       ======================================================================================== */

    /* 1062 (Duplicate entry):
       - No abortamos el SP de golpe.
       - Marcamos v_Dup=1 para devolver “CONFLICTO” controlado.
    */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* Cualquier otro error SQL:
       - rollback + relanzar el error real
    */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ========================================================================================
       PARTE 2) NORMALIZACIÓN
       ======================================================================================== */
    SET _Nuevo_Codigo = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');

    /* ========================================================================================
       PARTE 3) VALIDACIONES BÁSICAS
       ======================================================================================== */
    IF _Id_Pais IS NULL OR _Id_Pais <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_Pais inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL OR _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Código y Nombre son obligatorios.';
    END IF;

    /* ========================================================================================
       PARTE 4) TRANSACCIÓN PRINCIPAL
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1) Lectura inicial del País a editar (SIN bloquear todavía)
       ----------------------------------------------------------------------------------------
       - Aquí solo verificamos que exista y obtenemos valores actuales.
       - OJO: aún NO bloqueamos para poder hacer lock determinístico después.
       - Si alguien cambia algo en microsegundos, lo corregimos en PASO 4 (re-lectura con lock).
    ---------------------------------------------------------------------------------------- */
    SET v_Codigo_Actual = NULL;
    SET v_Nombre_Actual = NULL;

    SELECT Codigo, Nombre
      INTO v_Codigo_Actual, v_Nombre_Actual
    FROM Pais
    WHERE Id_Pais = _Id_Pais
    LIMIT 1;

    IF v_Codigo_Actual IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El País no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) Descubrir “posibles conflictos” (SIN bloquear todavía)
       ----------------------------------------------------------------------------------------
       - Buscamos qué fila (si existe) YA tiene el nuevo Código o el nuevo Nombre.
       - Esto nos permite saber QUÉ filas hay que bloquear en orden determinístico.
       - NO usamos FOR UPDATE aquí, justamente para NO inducir locks en orden variable.
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Pais_DupCodigo = NULL;

    SELECT Id_Pais
      INTO v_Id_Pais_DupCodigo
    FROM Pais
    WHERE Codigo = _Nuevo_Codigo
      AND Id_Pais <> _Id_Pais
    LIMIT 1;

    SET v_Id_Pais_DupNombre = NULL;

    SELECT Id_Pais
      INTO v_Id_Pais_DupNombre
    FROM Pais
    WHERE Nombre = _Nuevo_Nombre
      AND Id_Pais <> _Id_Pais
    LIMIT 1;

    /* ----------------------------------------------------------------------------------------
       PASO 3) LOCK DETERMINÍSTICO de filas relevantes (hasta 3)
       ----------------------------------------------------------------------------------------
       - Construimos la lista (Id a editar, Id por código, Id por nombre)
       - Quitamos NULLs y duplicados
       - Bloqueamos SIEMPRE en orden ascendente:
           lock #1: el menor Id
           lock #2: el siguiente
           lock #3: el siguiente
       - Cada lock se hace con SELECT ... FOR UPDATE que NO devuelve result sets “extra”.
    ---------------------------------------------------------------------------------------- */
    SET v_L1 = _Id_Pais;
    SET v_L2 = v_Id_Pais_DupCodigo;
    SET v_L3 = v_Id_Pais_DupNombre;

    /* Remover duplicados obvios */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 IS NOT NULL AND v_L2 IS NOT NULL AND v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* 3.1) Lock del menor */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SET v_Existe = NULL;

        SELECT 1
          INTO v_Existe
        FROM Pais
        WHERE Id_Pais = v_Min
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: fila a bloquear ya no existe (lock #1).';
        END IF;

        /* “Consumimos” el id bloqueado */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* 3.2) Lock del siguiente menor */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SET v_Existe = NULL;

        SELECT 1
          INTO v_Existe
        FROM Pais
        WHERE Id_Pais = v_Min
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: fila a bloquear ya no existe (lock #2).';
        END IF;

        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* 3.3) Lock del último (si existe) */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SET v_Existe = NULL;

        SELECT 1
          INTO v_Existe
        FROM Pais
        WHERE Id_Pais = v_Min
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: fila a bloquear ya no existe (lock #3).';
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) Re-lectura del País objetivo YA con lock (consistencia)
       ----------------------------------------------------------------------------------------
       - Ahora sí, ya tenemos un punto estable:
         la fila _Id_Pais está bloqueada dentro de esta transacción.
       - Actualizamos “actuales” por si cambiaron entre PASO 1 y PASO 3.
    ---------------------------------------------------------------------------------------- */
    SET v_Codigo_Actual = NULL;
    SET v_Nombre_Actual = NULL;

    SELECT Codigo, Nombre
      INTO v_Codigo_Actual, v_Nombre_Actual
    FROM Pais
    WHERE Id_Pais = _Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Codigo_Actual IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El País no existe (desapareció durante la edición).';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5) SIN CAMBIOS (salida temprana)
       ----------------------------------------------------------------------------------------
       - Si el usuario no cambió ni Código ni Nombre:
         devolvemos “SIN_CAMBIOS” y liberamos locks rápido (COMMIT).
    ---------------------------------------------------------------------------------------- */
    IF v_Codigo_Actual = _Nuevo_Codigo
       AND v_Nombre_Actual = _Nuevo_Nombre THEN

        COMMIT;

        SELECT 'Sin cambios: El País ya tiene ese Código y ese Nombre.' AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Id_Pais AS Id_Pais;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 6) Pre-check duplicidad por CÓDIGO (otro Id)
       ----------------------------------------------------------------------------------------
       - Aquí ya estamos bajo locks determinísticos, así reducimos deadlocks.
       - Excluimos el mismo Id_Pais (edición del propio registro).
    ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_Pais
      INTO v_DupId
    FROM Pais
    WHERE Codigo = _Nuevo_Codigo
      AND Id_Pais <> _Id_Pais
    ORDER BY Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRO País con ese CÓDIGO.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7) Pre-check duplicidad por NOMBRE (otro Id)
    ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_Pais
      INTO v_DupId
    FROM Pais
    WHERE Nombre = _Nuevo_Nombre
      AND Id_Pais <> _Id_Pais
    ORDER BY Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRO País con ese NOMBRE.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 8) UPDATE FINAL (aquí puede aparecer 1062 por carrera)
       ----------------------------------------------------------------------------------------
       - Reseteamos v_Dup = 0 justo antes del UPDATE.
       - Si alguien “se coló” entre nuestros checks y el update (concurrencia real),
         el UNIQUE dispara 1062 y nuestro handler marca v_Dup=1.
    ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    UPDATE Pais
    SET Codigo = _Nuevo_Codigo,
        Nombre = _Nuevo_Nombre,
        updated_at = NOW()
    WHERE Id_Pais = _Id_Pais;

    /* ----------------------------------------------------------------------------------------
       PASO 9) Si hubo 1062 => CONFLICTO CONTROLADO
       ----------------------------------------------------------------------------------------
       - ROLLBACK: no guardamos nada.
       - Re-consultamos quién causó el choque:
           * primero por Código
           * si no, por Nombre
       - Devolvemos datos para UI (mensaje + Id_Conflicto).
    ---------------------------------------------------------------------------------------- */
    IF v_Dup = 1 THEN
        ROLLBACK;

        SET v_Id_Conflicto = NULL;
        SET v_Campo_Conflicto = NULL;

        /* 9.1) Conflicto por Código */
        SELECT Id_Pais
          INTO v_Id_Conflicto
        FROM Pais
        WHERE Codigo = _Nuevo_Codigo
          AND Id_Pais <> _Id_Pais
        ORDER BY Id_Pais
        LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
            SET v_Campo_Conflicto = 'CODIGO';
        ELSE
            /* 9.2) Conflicto por Nombre */
            SELECT Id_Pais
              INTO v_Id_Conflicto
            FROM Pais
            WHERE Nombre = _Nuevo_Nombre
              AND Id_Pais <> _Id_Pais
            ORDER BY Id_Pais
            LIMIT 1;

            IF v_Id_Conflicto IS NOT NULL THEN
                SET v_Campo_Conflicto = 'NOMBRE';
            END IF;
        END IF;

        SELECT 'No se guardó: otro usuario se adelantó. Refresca y vuelve a intentar.' AS Mensaje,
               'CONFLICTO' AS Accion,
               v_Campo_Conflicto AS Campo,
               v_Id_Conflicto AS Id_Conflicto,
               _Id_Pais AS Id_Pais_Que_Intentabas_Editar;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       ÉXITO
    ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 'País actualizado correctamente' AS Mensaje,
           'ACTUALIZADA' AS Accion,
           _Id_Pais AS Id_Pais;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarEstado  (VERSIÓN PRO “REAL”: Lock determinístico + SIN CAMBIOS + 1062 controlado)
   ============================================================================================

   OBJETIVO
   --------
   Editar un Estado existente permitiendo:
   - Cambiar Código
   - Cambiar Nombre
   - (Opcionalmente) moverlo a otro País (Fk_Id_Pais)

   ¿CUÁNDO SE USA?
   --------------
   - Formulario “Editar Estado”
   - El usuario modifica:
       * _Nuevo_Codigo
       * _Nuevo_Nombre
     y elige en dropdown:
       * _Nuevo_Id_Pais (solo países activos listados por UI)

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   1) El Estado a editar DEBE existir.
      - Se bloquea su fila con FOR UPDATE para que nadie lo edite al mismo tiempo.
   2) El País destino DEBE existir y estar Activo=1.
      - La UI normalmente solo lista activos, pero aquí lo exigimos en backend.
   3) Anti-duplicados en el País destino:
      - NO puede existir OTRO Estado en el País destino con el mismo Codigo.
        (UNIQUE compuesto típico: (Fk_Id_Pais, Codigo))
      - NO puede existir OTRO Estado en el País destino con el mismo Nombre.
        (UNIQUE compuesto típico: (Fk_Id_Pais, Nombre))
      - Se excluye el mismo Id_Estado para permitir “guardar sin cambios”.
   4) Si el usuario no cambió nada (Codigo, Nombre y País iguales) => “SIN_CAMBIOS”.
   5) Se ejecuta el UPDATE.
   6) Si por concurrencia ocurre 1062 en UPDATE => respuesta “CONFLICTO” controlada.

   ¿POR QUÉ TODAVÍA PUEDE OCURRIR 1062 SI YA HAY PRE-CHECKS?
   ---------------------------------------------------------
   Por carrera (concurrencia real):
   - Usuario A y Usuario B editan estados diferentes
   - Ambos van a poner el mismo (Codigo, País) o (Nombre, País)
   - Ambos validan “no existe duplicado” (todavía)
   - A guarda primero
   - B choca con UNIQUE => MySQL lanza error 1062

   CONCURRENCIA “PRO” EN EDITAR: 1062 => CONFLICTO (NO REUSAR)
   -----------------------------------------------------------
   En EDITAR no queremos “aprovechar” el registro ajeno.
   Queremos informar al frontend:
     - Accion = 'CONFLICTO'
     - Campo  = 'CODIGO' o 'NOMBRE'
     - Id_Conflicto = Id_Estado que ya tomó ese valor

   PRO “DE VERDAD”: LOCK DETERMINÍSTICO DE PAÍSES (ANTI-DEADLOCKS)
   --------------------------------------------------------------
   PROBLEMA:
   - Si una transacción mueve Estado X de País A -> País B
     y otra transacción mueve Estado Y de País B -> País A
     pueden terminar bloqueando países en orden diferente => deadlock.
   SOLUCIÓN:
   - Bloquear países SIEMPRE en el mismo orden:
       Pais_Low  = min(PaisActual, PaisDestino)
       Pais_High = max(PaisActual, PaisDestino)
     y se bloquean en ese orden con FOR UPDATE.

   NOTA SOBRE RESETEOS A NULL ANTES DE SELECT ... INTO
   ---------------------------------------------------
   En MySQL, si SELECT ... INTO no encuentra filas:
   - NO asigna nada y la variable conserva su valor anterior.
   Por eso, antes de cada SELECT ... INTO hacemos:
     SET v_X = NULL;
   para distinguir correctamente “no encontrado”.

   RESULTADO
   ---------
   ÉXITO:
     - Mensaje
     - Accion = 'ACTUALIZADA'
     - Id_Estado
     - Id_Pais (alias compatible)
     - Id_Pais_Anterior (extra útil)
     - Id_Pais_Nuevo (extra útil)

   SIN CAMBIOS:
     - Mensaje
     - Accion = 'SIN_CAMBIOS'
     - Id_Estado
     - Id_Pais (alias compatible)
     - Id_Pais_Anterior
     - Id_Pais_Nuevo

   CONFLICTO (1062):
     - Mensaje
     - Accion = 'CONFLICTO'
     - Campo  = 'CODIGO' | 'NOMBRE'
     - Id_Conflicto
     - Id_Estado_Que_Intentabas_Editar
     - Id_Pais_Destino (como ya tenías)
     - Id_Pais_Anterior
     - Id_Pais_Nuevo
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_EditarEstado$$
CREATE PROCEDURE SP_EditarEstado(
    IN _Id_Estado INT,
    IN _Nuevo_Codigo VARCHAR(50),
    IN _Nuevo_Nombre VARCHAR(255),
    IN _Nuevo_Id_Pais INT
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0) VARIABLES
       ======================================================================================== */

    /* Datos actuales (para poder detectar “SIN CAMBIOS”) */
    DECLARE v_Codigo_Actual VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre_Actual VARCHAR(255) DEFAULT NULL;
    DECLARE v_Id_Pais_Actual INT         DEFAULT NULL;

    /* Auxiliares de validación / duplicidad */
    DECLARE v_Existe INT DEFAULT NULL;
    DECLARE v_DupId INT DEFAULT NULL;

    /* Bandera de choque 1062 en UPDATE */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* Datos para respuesta de conflicto controlado */
    DECLARE v_Id_Conflicto INT DEFAULT NULL;
    DECLARE v_Campo_Conflicto VARCHAR(20) DEFAULT NULL;

    /* Para lock determinístico de países */
    DECLARE v_Pais_Low INT DEFAULT NULL;
    DECLARE v_Pais_High INT DEFAULT NULL;

    /* ========================================================================================
       PARTE 1) HANDLERS
       ======================================================================================== */

    /* 1062 (Duplicate entry):
       - No abortamos el SP de golpe.
       - Marcamos v_Dup = 1 para regresar “CONFLICTO” controlado.
    */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* Cualquier otro error SQL:
       - rollback + relanzar error real
    */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ========================================================================================
       PARTE 2) NORMALIZACIÓN
       ======================================================================================== */
    SET _Nuevo_Codigo = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');

    /* ========================================================================================
       PARTE 3) VALIDACIONES BÁSICAS
       ======================================================================================== */
    IF _Id_Estado IS NULL OR _Id_Estado <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_Estado inválido.';
    END IF;

    IF _Nuevo_Id_Pais IS NULL OR _Nuevo_Id_Pais <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_Pais destino inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL OR _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Código y Nombre del Estado son obligatorios.';
    END IF;

    /* ========================================================================================
       PARTE 4) TRANSACCIÓN PRINCIPAL
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1) Bloquear el Estado a editar y leer sus valores actuales
       ----------------------------------------------------------------------------------------
       - FOR UPDATE bloquea la fila del Estado => nadie lo edita en paralelo.
       - De aquí sacamos:
           * v_Codigo_Actual
           * v_Nombre_Actual
           * v_Id_Pais_Actual  (para lock determinístico entre País actual y País destino)
    ---------------------------------------------------------------------------------------- */
    SET v_Codigo_Actual = NULL;
    SET v_Nombre_Actual = NULL;
    SET v_Id_Pais_Actual = NULL;

    SELECT
        E.Codigo,
        E.Nombre,
        E.Fk_Id_Pais
    INTO
        v_Codigo_Actual,
        v_Nombre_Actual,
        v_Id_Pais_Actual
    FROM Estado E
    WHERE E.Id_Estado = _Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Pais_Actual IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El Estado no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) LOCK DETERMINÍSTICO DE PAÍSES (anti-deadlocks)
       ----------------------------------------------------------------------------------------
       - Vamos a bloquear SIEMPRE los países en el mismo orden:
           Pais_Low  = min(PaisActual, PaisDestino)
           Pais_High = max(PaisActual, PaisDestino)
       - Esto evita deadlocks cuando hay movimientos cruzados A<->B en paralelo.
    ---------------------------------------------------------------------------------------- */
    IF v_Id_Pais_Actual = _Nuevo_Id_Pais THEN
        SET v_Pais_Low  = v_Id_Pais_Actual;
        SET v_Pais_High = v_Id_Pais_Actual;
    ELSE
        SET v_Pais_Low  = LEAST(v_Id_Pais_Actual, _Nuevo_Id_Pais);
        SET v_Pais_High = GREATEST(v_Id_Pais_Actual, _Nuevo_Id_Pais);
    END IF;

    /* 2.1) Bloquear País LOW (debe existir) */
    SET v_Existe = NULL;

    SELECT 1
      INTO v_Existe
    FROM Pais
    WHERE Id_Pais = v_Pais_Low
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: País (low) no existe.';
    END IF;

    /* 2.2) Bloquear País HIGH (si es distinto) */
    IF v_Pais_High <> v_Pais_Low THEN
        SET v_Existe = NULL;

        SELECT 1
          INTO v_Existe
        FROM Pais
        WHERE Id_Pais = v_Pais_High
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: País (high) no existe.';
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) Validar País destino ACTIVO (contrato con UI)
       ----------------------------------------------------------------------------------------
       - La UI normalmente lista solo países activos.
       - Aquí lo exigimos para impedir:
           * “guardar” hacia un país que se desactivó mientras el usuario editaba.
       - FOR UPDATE aquí es redundante porque ya bloqueamos el país en PASO 2,
         pero lo dejamos por claridad del “contrato”.
    ---------------------------------------------------------------------------------------- */
    SET v_Existe = NULL;

    SELECT 1
      INTO v_Existe
    FROM Pais
    WHERE Id_Pais = _Nuevo_Id_Pais
      AND Activo = 1
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El País destino no existe o está inactivo.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) SIN CAMBIOS (salida temprana)
       ----------------------------------------------------------------------------------------
       - Si no cambió:
           * Código
           * Nombre
           * País
         devolvemos “SIN_CAMBIOS”.
       - COMMIT inmediato => libera locks rápido (mejor concurrencia).
    ---------------------------------------------------------------------------------------- */
    IF v_Codigo_Actual = _Nuevo_Codigo
       AND v_Nombre_Actual = _Nuevo_Nombre
       AND v_Id_Pais_Actual = _Nuevo_Id_Pais THEN

        COMMIT;

        SELECT 'Sin cambios: El Estado ya tiene esos datos y ya pertenece a ese País.' AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Id_Estado AS Id_Estado,
               _Nuevo_Id_Pais AS Id_Pais,           -- alias compatible (como tu SP actual)
               v_Id_Pais_Actual AS Id_Pais_Anterior,
               _Nuevo_Id_Pais AS Id_Pais_Nuevo;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5) Pre-check duplicidad por CÓDIGO en el País destino (excluyendo el mismo Id)
       ----------------------------------------------------------------------------------------
       - Reglas:
         * Dentro del mismo País destino, el Código debe ser único.
         * Excluimos el mismo Id_Estado para permitir actualización del propio registro.
       - ORDER BY Id_Estado:
         * lock determinístico (si hubiera datos sucios o escenarios raros).
       - FOR UPDATE:
         * si encuentra duplicado, bloquea esa fila durante tu TX.
    ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_Estado
      INTO v_DupId
    FROM Estado
    WHERE Fk_Id_Pais = _Nuevo_Id_Pais
      AND Codigo = _Nuevo_Codigo
      AND Id_Estado <> _Id_Estado
    ORDER BY Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRO Estado con ese CÓDIGO en el País destino.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 6) Pre-check duplicidad por NOMBRE en el País destino (excluyendo el mismo Id)
    ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_Estado
      INTO v_DupId
    FROM Estado
    WHERE Fk_Id_Pais = _Nuevo_Id_Pais
      AND Nombre = _Nuevo_Nombre
      AND Id_Estado <> _Id_Estado
    ORDER BY Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRO Estado con ese NOMBRE en el País destino.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7) UPDATE FINAL (aquí puede aparecer 1062 por carrera)
       ----------------------------------------------------------------------------------------
       - Reseteamos v_Dup=0 antes del UPDATE para detectar si el handler se disparó aquí.
    ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    UPDATE Estado
    SET Codigo = _Nuevo_Codigo,
        Nombre = _Nuevo_Nombre,
        Fk_Id_Pais = _Nuevo_Id_Pais,
        updated_at = NOW()
    WHERE Id_Estado = _Id_Estado;

    /* ----------------------------------------------------------------------------------------
       PASO 8) Si hubo 1062 => CONFLICTO CONTROLADO
       ----------------------------------------------------------------------------------------
       - ROLLBACK: no guardamos nada.
       - Buscamos el Id_Estado que “ganó” el valor en el País destino:
           * primero por CODIGO
           * si no, por NOMBRE
       - Devolvemos respuesta clara para UI.
    ---------------------------------------------------------------------------------------- */
    IF v_Dup = 1 THEN
        ROLLBACK;

        SET v_Id_Conflicto = NULL;
        SET v_Campo_Conflicto = NULL;

        /* 8.1) Conflicto por CODIGO */
        SELECT Id_Estado
          INTO v_Id_Conflicto
        FROM Estado
        WHERE Fk_Id_Pais = _Nuevo_Id_Pais
          AND Codigo = _Nuevo_Codigo
          AND Id_Estado <> _Id_Estado
        ORDER BY Id_Estado
        LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
            SET v_Campo_Conflicto = 'CODIGO';
        ELSE
            /* 8.2) Conflicto por NOMBRE */
            SELECT Id_Estado
              INTO v_Id_Conflicto
            FROM Estado
            WHERE Fk_Id_Pais = _Nuevo_Id_Pais
              AND Nombre = _Nuevo_Nombre
              AND Id_Estado <> _Id_Estado
            ORDER BY Id_Estado
            LIMIT 1;

            IF v_Id_Conflicto IS NOT NULL THEN
                SET v_Campo_Conflicto = 'NOMBRE';
            END IF;
        END IF;

        SELECT 'No se guardó: otro usuario se adelantó. Refresca y vuelve a intentar.' AS Mensaje,
               'CONFLICTO' AS Accion,
               v_Campo_Conflicto AS Campo,
               v_Id_Conflicto AS Id_Conflicto,
               _Id_Estado AS Id_Estado_Que_Intentabas_Editar,
               _Nuevo_Id_Pais AS Id_Pais_Destino,
               v_Id_Pais_Actual AS Id_Pais_Anterior,
               _Nuevo_Id_Pais AS Id_Pais_Nuevo;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 9) ÉXITO
    ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 'Estado actualizado correctamente' AS Mensaje,
           'ACTUALIZADA' AS Accion,
           _Id_Estado AS Id_Estado,
           _Nuevo_Id_Pais AS Id_Pais,           -- alias compatible (como tu SP actual)
           v_Id_Pais_Actual AS Id_Pais_Anterior,
           _Nuevo_Id_Pais AS Id_Pais_Nuevo;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarMunicipio  (VERSIÓN PRO “REAL”: Locks determinísticos + JOIN atómico + SIN CAMBIOS + 1062)
   ============================================================================================

   CONTEXTO DE UI (CÓMO FUNCIONA TU FORMULARIO)
   --------------------------------------------
   1) El frontend precarga el registro con SP_ConsultarMunicipioEspecifico:
      - Código, Nombre, timestamps
      - País actual (derivado: Municipio -> Estado -> País)
      - Estado actual

   2) El usuario puede:
      - Cambiar Código y/o Nombre
      - Cambiar Estado destino (dentro del País actual)
      - O cambiar País (dropdown) => recarga Estados del País => elegir nuevo Estado destino

   IMPORTANTE (DISEÑO DE DATOS)
   ----------------------------
   - Municipio NO tiene Fk_Id_Pais.
   - El “País” de un Municipio se determina por el Estado:
         Municipio.Fk_Id_Estado -> Estado.Fk_Id_Pais
   - Entonces “cambiar País” realmente significa:
         elegir un Estado destino que pertenezca al País elegido.

   ¿POR QUÉ ESTE SP RECIBE _Id_Pais_Seleccionado SI YA RECIBE _Id_Estado_Destino?
   ------------------------------------------------------------------------------
   - Porque tu UI trabaja en cascada País -> Estado.
   - En teoría el Estado elegido SIEMPRE pertenece a ese País.
   - PERO en backend se valida para blindar contra:
       * requests manipuladas
       * bugs del frontend
       * catálogos cambiaron mientras el usuario editaba
       * estados cacheados

   OBJETIVO
   --------
   Editar un Municipio existente permitiendo:
   - Cambiar Código
   - Cambiar Nombre
   - Moverlo a otro Estado (Estado destino)

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   1) El Municipio a editar DEBE existir.
   2) El País seleccionado DEBE existir y estar Activo=1.
   3) El Estado destino DEBE:
      - existir
      - estar Activo=1
      - pertenecer al País seleccionado
   4) Anti-duplicados dentro del Estado destino:
      - NO puede existir OTRO Municipio con el mismo Código en el Estado destino
      - NO puede existir OTRO Municipio con el mismo Nombre en el Estado destino
      (se excluye el mismo Id_Municipio)
   5) Si el usuario realmente no cambió nada => “SIN_CAMBIOS” (no “ACTUALIZADA”).
   6) Se ejecuta el UPDATE.

   CONCURRENCIA (POR QUÉ EXISTE HANDLER 1062 EN UPDATE)
   ----------------------------------------------------
   Aunque hagas pre-checks, puede pasar una carrera:
   - Usuario A y B editan al mismo tiempo hacia el mismo (Codigo/Nombre + Estado destino)
   - Ambos “ven” que no hay duplicado
   - A guarda primero
   - B choca con UNIQUE => MySQL lanza 1062

   SOLUCIÓN PRO EN EDICIÓN: 1062 => CONFLICTO (NO “REUSAR”)
   --------------------------------------------------------
   En EDITAR no queremos usar el registro del otro usuario.
   Queremos avisar:
     - Accion = 'CONFLICTO'
     - Campo  = 'CODIGO' o 'NOMBRE'
     - Id_Conflicto = Id del municipio que ya tomó ese valor

   ¿QUÉ CAMBIA vs TU SP ACTUAL?
   ----------------------------
   A) “LOCK DETERMINÍSTICO DE PAÍSES”
      - Si el municipio está en País A y lo mueves a País B, dos usuarios cruzados (A->B y B->A)
        pueden provocar deadlocks si bloquean Países en diferente orden.
      - SOLUCIÓN: bloquear SIEMPRE en orden por Id:
          1) Pais LOW  (min(IdPaisActual, IdPaisSeleccionado))
          2) Pais HIGH (max(IdPaisActual, IdPaisSeleccionado))

   B) “JOIN ÚNICO PAÍS -> ESTADO DESTINO”
      - En lugar de validar País y Estado por separado, se valida TODO de un jalón:
          * País existe y Activo=1
          * Estado existe, Activo=1
          * Estado pertenece a ese País
      - Esto evita inconsistencias y deja el contrato más blindado.

   C) “SIN CAMBIOS”
      - Si Código, Nombre y Estado destino son iguales al actual:
        - COMMIT inmediato (para liberar locks)
        - Accion = 'SIN_CAMBIOS'

   NOTA IMPORTANTE: RESET A NULL ANTES DE SELECT ... INTO
   ------------------------------------------------------
   En MySQL, si un SELECT ... INTO no encuentra filas, las variables NO se limpian.
   Por eso hacemos SET var = NULL antes de cada SELECT ... INTO.

   RESULTADO
   ---------
   ÉXITO:
     - Mensaje
     - Accion = 'ACTUALIZADA'
     - Id_Municipio
     - Id_Estado_Anterior
     - Id_Estado_Nuevo
     - Id_Pais_Seleccionado

   SIN CAMBIOS:
     - Mensaje
     - Accion = 'SIN_CAMBIOS'
     - Id_Municipio
     - Id_Estado_Anterior
     - Id_Estado_Nuevo
     - Id_Pais_Seleccionado

   CONFLICTO (1062):
     - Mensaje
     - Accion = 'CONFLICTO'
     - Campo ('CODIGO'|'NOMBRE')
     - Id_Conflicto
     - Id_Municipio_Que_Intentabas_Editar
     - Id_Estado_Anterior
     - Id_Estado_Nuevo
     - Id_Pais_Seleccionado

============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_EditarMunicipio$$
CREATE PROCEDURE SP_EditarMunicipio(
    IN _Id_Municipio INT,
    IN _Nuevo_Codigo VARCHAR(50),
    IN _Nuevo_Nombre VARCHAR(255),
    IN _Id_Pais_Seleccionado INT,
    IN _Id_Estado_Destino INT
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0) VARIABLES
       ======================================================================================== */

    /* Datos actuales del municipio (para "SIN CAMBIOS") */
    DECLARE v_Codigo_Actual VARCHAR(50) DEFAULT NULL;
    DECLARE v_Nombre_Actual VARCHAR(255) DEFAULT NULL;

    /* “Estado anterior” (para respuesta y para saber si se movió o no) */
    DECLARE v_Estado_Anterior INT DEFAULT NULL;

    /* País actual del municipio (derivado del Estado anterior) */
    DECLARE v_Id_Pais_Actual INT DEFAULT NULL;

    /* Variable auxiliar genérica para existencia / validaciones */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Para pre-checks de duplicados */
    DECLARE v_DupId INT DEFAULT NULL;

    /* Bandera para detectar choque 1062 en UPDATE */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* Datos para respuesta de conflicto controlado */
    DECLARE v_Id_Conflicto INT DEFAULT NULL;
    DECLARE v_Campo_Conflicto VARCHAR(20) DEFAULT NULL;

    /* Para lock determinístico de países */
    DECLARE v_Pais_Low INT DEFAULT NULL;
    DECLARE v_Pais_High INT DEFAULT NULL;

    /* ========================================================================================
       PARTE 1) HANDLERS (CONCURRENCIA Y ERRORES)
       ======================================================================================== */

    /* 1062 (Duplicate entry):
       - No abortamos inmediatamente, marcamos v_Dup=1 para responder “CONFLICTO” controlado.
       - Esto solo tiene sentido si el 1062 ocurre en el UPDATE (por eso reseteamos v_Dup=0 antes).
    */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* Cualquier otro error SQL:
       - rollback y re-lanzar el error para que el backend lo vea tal cual.
    */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ========================================================================================
       PARTE 2) NORMALIZACIÓN DE INPUTS (defensivo)
       ======================================================================================== */

    /* TRIM para quitar espacios invisibles.
       NULLIF('', '') para impedir guardar vacío como “valor válido” cuando tu negocio lo considera inválido. */
    SET _Nuevo_Codigo = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');

    /* ========================================================================================
       PARTE 3) VALIDACIONES BÁSICAS (antes de abrir TX)
       ======================================================================================== */

    IF _Id_Municipio IS NULL OR _Id_Municipio <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_Municipio inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL OR _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Código y Nombre del Municipio son obligatorios.';
    END IF;

    IF _Id_Pais_Seleccionado IS NULL OR _Id_Pais_Seleccionado <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: País seleccionado inválido.';
    END IF;

    IF _Id_Estado_Destino IS NULL OR _Id_Estado_Destino <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Estado destino inválido.';
    END IF;

    /* ========================================================================================
       PARTE 4) TRANSACCIÓN PRINCIPAL
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1) Bloquear el Municipio a editar y leer su estado anterior + datos actuales
       ----------------------------------------------------------------------------------------
       - Aquí bloqueamos SOLO la fila del Municipio (FOR UPDATE).
       - ¿Por qué?
         * Evita que otro usuario cambie este mismo Municipio mientras tú lo editas.
         * Nos permite obtener:
             - v_Estado_Anterior (para respuesta)
             - v_Codigo_Actual y v_Nombre_Actual (para detectar “SIN CAMBIOS”)
       - NOTA: NO bloqueamos Estado/Pais aquí para minimizar riesgo de deadlocks cruzados
         (luego bloqueamos Países en orden determinístico).
    ---------------------------------------------------------------------------------------- */
    SET v_Estado_Anterior = NULL;
    SET v_Codigo_Actual = NULL;
    SET v_Nombre_Actual = NULL;

    SELECT
        M.Fk_Id_Estado,
        M.Codigo,
        M.Nombre
    INTO
        v_Estado_Anterior,
        v_Codigo_Actual,
        v_Nombre_Actual
    FROM Municipio M
    WHERE M.Id_Municipio = _Id_Municipio
    LIMIT 1
    FOR UPDATE;

    IF v_Estado_Anterior IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El Municipio no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 1.1) Obtener País ACTUAL del municipio (derivado del Estado anterior)
       ----------------------------------------------------------------------------------------
       - Aquí solo necesitamos el Id del país actual para poder:
         * hacer lock determinístico de países (actual vs seleccionado)
       - Si el Estado anterior no existe por alguna inconsistencia, abortamos.
       - No usamos FOR UPDATE aquí (evitamos meter locks antes del orden determinístico).
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Pais_Actual = NULL;

    SELECT E.Fk_Id_Pais
      INTO v_Id_Pais_Actual
    FROM Estado E
    WHERE E.Id_Estado = v_Estado_Anterior
    LIMIT 1;

    IF v_Id_Pais_Actual IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Inconsistencia: el Estado actual del Municipio no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) LOCK DETERMINÍSTICO DE PAÍSES (anti-deadlocks)
       ----------------------------------------------------------------------------------------
       PROBLEMA QUE RESUELVE:
       - Si dos transacciones intentan mover municipios entre País A y País B en direcciones opuestas,
         y cada una bloquea primero un país distinto, se puede generar DEADLOCK.
       SOLUCIÓN:
       - Bloqueamos SIEMPRE en el mismo orden:
         1) v_Pais_Low  = min(PaisActual, PaisSeleccionado)
         2) v_Pais_High = max(PaisActual, PaisSeleccionado)
       - Así todas las transacciones compiten por los locks en el mismo orden.
    ---------------------------------------------------------------------------------------- */
    IF v_Id_Pais_Actual = _Id_Pais_Seleccionado THEN
        SET v_Pais_Low = v_Id_Pais_Actual;
        SET v_Pais_High = v_Id_Pais_Actual;
    ELSE
        SET v_Pais_Low = LEAST(v_Id_Pais_Actual, _Id_Pais_Seleccionado);
        SET v_Pais_High = GREATEST(v_Id_Pais_Actual, _Id_Pais_Seleccionado);
    END IF;

    /* 2.1) Bloquear País LOW (debe existir)
       - OJO: el País actual podría estar inactivo y aún así queremos permitir editar,
              lo que exigimos activo es el País “seleccionado/destino”.
    */
    SET v_Existe = NULL;

    SELECT 1
      INTO v_Existe
    FROM Pais
    WHERE Id_Pais = v_Pais_Low
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: País (low) no existe.';
    END IF;

    /* 2.2) Bloquear País HIGH (si es distinto) */
    IF v_Pais_High <> v_Pais_Low THEN
        SET v_Existe = NULL;

        SELECT 1
          INTO v_Existe
        FROM Pais
        WHERE Id_Pais = v_Pais_High
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: País (high) no existe.';
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) Validación ATÓMICA (JOIN único): País seleccionado + Estado destino
       ----------------------------------------------------------------------------------------
       Validamos TODO en un solo SELECT:
       - País existe y Activo=1
       - Estado existe y Activo=1
       - Estado pertenece al País seleccionado
       Además:
       - FOR UPDATE aquí bloquea la fila del Estado destino (y el País seleccionado ya está bloqueado).
       - STRAIGHT_JOIN fuerza el orden de la consulta para que el optimizador no “reordene” joins.
    ---------------------------------------------------------------------------------------- */
    SET v_Existe = NULL;

    SELECT 1
      INTO v_Existe
    FROM Pais P
    STRAIGHT_JOIN Estado E ON E.Fk_Id_Pais = P.Id_Pais
    WHERE P.Id_Pais = _Id_Pais_Seleccionado
      AND P.Activo = 1
      AND E.Id_Estado = _Id_Estado_Destino
      AND E.Activo = 1
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El Estado destino no pertenece al País seleccionado o el País/Estado están inactivos.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) SIN CAMBIOS (salida temprana)
       ----------------------------------------------------------------------------------------
       - Si:
         * Código igual al actual
         * Nombre igual al actual
         * Estado destino igual al estado anterior
       - Entonces no hacemos pre-checks ni UPDATE.
       - COMMIT inmediato para liberar locks (importante para concurrencia).
    ---------------------------------------------------------------------------------------- */
    IF v_Codigo_Actual = _Nuevo_Codigo
       AND v_Nombre_Actual = _Nuevo_Nombre
       AND v_Estado_Anterior = _Id_Estado_Destino THEN

        COMMIT;

        SELECT 'Sin cambios: El Municipio ya tiene esos datos y ya está en ese Estado.' AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Id_Municipio AS Id_Municipio,
               v_Estado_Anterior AS Id_Estado_Anterior,
               _Id_Estado_Destino AS Id_Estado_Nuevo,
               _Id_Pais_Seleccionado AS Id_Pais_Seleccionado;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5) Pre-check duplicidad por CÓDIGO en el Estado destino (excluyendo el mismo Id)
       ----------------------------------------------------------------------------------------
       - “¿Existe OTRO municipio en ese mismo Estado destino con ese Código?”
       - FOR UPDATE:
         * si encuentra la fila duplicada, la bloquea y evita que cambie en medio de tu TX.
       - ORDER BY Id_Municipio:
         * lock determinístico (si hubiera más de uno por datos sucios, eliges siempre el mismo).
    ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_Municipio
      INTO v_DupId
    FROM Municipio
    WHERE Fk_Id_Estado = _Id_Estado_Destino
      AND Codigo = _Nuevo_Codigo
      AND Id_Municipio <> _Id_Municipio
    ORDER BY Id_Municipio
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe OTRO Municipio con ese CÓDIGO en el Estado destino.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 6) Pre-check duplicidad por NOMBRE en el Estado destino (excluyendo el mismo Id)
       ----------------------------------------------------------------------------------------
       - “¿Existe OTRO municipio en ese mismo Estado destino con ese Nombre?”
    ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_Municipio
      INTO v_DupId
    FROM Municipio
    WHERE Fk_Id_Estado = _Id_Estado_Destino
      AND Nombre = _Nuevo_Nombre
      AND Id_Municipio <> _Id_Municipio
    ORDER BY Id_Municipio
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe OTRO Municipio con ese NOMBRE en el Estado destino.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7) UPDATE (aquí puede ocurrir 1062 por carrera)
       ----------------------------------------------------------------------------------------
       - Reseteamos v_Dup = 0 antes del UPDATE para saber si el handler 1062 se disparó aquí.
       - Si el handler se dispara, v_Dup = 1 y pasamos al PASO 8.
    ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    UPDATE Municipio
    SET Codigo = _Nuevo_Codigo,
        Nombre = _Nuevo_Nombre,
        Fk_Id_Estado = _Id_Estado_Destino,
        updated_at = NOW()
    WHERE Id_Municipio = _Id_Municipio;

    /* ----------------------------------------------------------------------------------------
       PASO 8) Si hubo 1062 => CONFLICTO CONTROLADO
       ----------------------------------------------------------------------------------------
       - Hacemos ROLLBACK porque NO queremos guardar nada parcial.
       - Determinamos SI el conflicto fue por:
         * CODIGO (en el Estado destino)
         * NOMBRE (en el Estado destino)
       - Regresamos “CONFLICTO” con Id_Conflicto para que el frontend muestre mensaje claro.
    ---------------------------------------------------------------------------------------- */
    IF v_Dup = 1 THEN
        ROLLBACK;

        SET v_Id_Conflicto = NULL;
        SET v_Campo_Conflicto = NULL;

        /* 8.1) Intentar detectar conflicto por CODIGO */
        SELECT Id_Municipio
          INTO v_Id_Conflicto
        FROM Municipio
        WHERE Fk_Id_Estado = _Id_Estado_Destino
          AND Codigo = _Nuevo_Codigo
          AND Id_Municipio <> _Id_Municipio
        ORDER BY Id_Municipio
        LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
            SET v_Campo_Conflicto = 'CODIGO';
        ELSE
            /* 8.2) Si no fue CODIGO, intentar conflicto por NOMBRE */
            SELECT Id_Municipio
              INTO v_Id_Conflicto
            FROM Municipio
            WHERE Fk_Id_Estado = _Id_Estado_Destino
              AND Nombre = _Nuevo_Nombre
              AND Id_Municipio <> _Id_Municipio
            ORDER BY Id_Municipio
            LIMIT 1;

            IF v_Id_Conflicto IS NOT NULL THEN
                SET v_Campo_Conflicto = 'NOMBRE';
            END IF;
        END IF;

        SELECT 'No se guardó: otro usuario se adelantó. Refresca y vuelve a intentar.' AS Mensaje,
               'CONFLICTO' AS Accion,
               v_Campo_Conflicto AS Campo,
               v_Id_Conflicto AS Id_Conflicto,
               _Id_Municipio AS Id_Municipio_Que_Intentabas_Editar,
               v_Estado_Anterior AS Id_Estado_Anterior,
               _Id_Estado_Destino AS Id_Estado_Nuevo,
               _Id_Pais_Seleccionado AS Id_Pais_Seleccionado;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 9) ÉXITO (commit final + respuesta estándar)
    ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 'Municipio actualizado correctamente' AS Mensaje,
           'ACTUALIZADA' AS Accion,
           _Id_Municipio AS Id_Municipio,
           v_Estado_Anterior AS Id_Estado_Anterior,
           _Id_Estado_Destino AS Id_Estado_Nuevo,
           _Id_Pais_Seleccionado AS Id_Pais_Seleccionado;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarDireccion  (VERSIÓN PRO “REAL”: Lock determinístico + SIN CAMBIOS + 1062 controlado)
   ============================================================================================

   OBJETIVO
   --------
   Editar Clave y Nombre de una Dirección, con:
   - Validaciones previas entendibles (mensajes claros)
   - “SIN_CAMBIOS” (si el usuario no cambió nada, no hacemos UPDATE)
   - Blindaje contra duplicados (Clave única / Nombre único)
   - Manejo “PRO” de concurrencia: 1062 => respuesta controlada “CONFLICTO”
   - Lock determinístico de filas para minimizar deadlocks en escenarios de “intercambio” (swap)

   ESCENARIO CLÁSICO DE DEADLOCK (POR QUÉ AQUÍ SÍ IMPORTA “LOCK DETERMINÍSTICO”)
   ----------------------------------------------------------------------------
   Caso:
   - Usuario A edita Dirección #1 (FIN) y lo quiere cambiar a Clave='RH'
   - Usuario B edita Dirección #2 (RH) y lo quiere cambiar a Clave='FIN'
   Sin lock determinístico, podría ocurrir:
   - A bloquea Dirección #1 (FOR UPDATE)
   - B bloquea Dirección #2 (FOR UPDATE)
   - A intenta bloquear Dirección #2 (para validar duplicado por clave)
   - B intenta bloquear Dirección #1 (para validar duplicado por clave)
   => DEADLOCK.

   SOLUCIÓN
   --------
   En vez de “bloquear primero la dirección a editar y luego el posible conflicto” en orden variable,
   hacemos un lock determinístico de TODAS las filas relevantes (máximo 3):
      - La Dirección que se edita (_Id_CatDirecc)
      - La Dirección que ya tenga la nueva Clave (si existe)
      - La Dirección que ya tenga el nuevo Nombre (si existe)
   Y las bloqueamos SIEMPRE en orden ascendente de Id.

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   1) La Dirección a editar DEBE existir.
   2) _Nuevo_Clave y _Nuevo_Nombre son obligatorios.
   3) No puede existir OTRA Dirección con:
      - la misma Clave
      - el mismo Nombre
      (excluimos el mismo Id_CatDirecc para permitir guardar sin cambios)
   4) Si no cambió nada => Accion = 'SIN_CAMBIOS'
   5) Si en UPDATE ocurre 1062 => Accion = 'CONFLICTO' (controlado)

   SOBRE LOS RESETEOS A NULL ANTES DE SELECT ... INTO
   -------------------------------------------------
   En MySQL, si un SELECT ... INTO no encuentra filas:
   - NO asigna nada y la variable conserva el valor anterior.
   Por eso antes de cada SELECT ... INTO hacemos SET var = NULL.

   RESULTADO
   ---------
   ÉXITO:
      - Mensaje
      - Accion = 'ACTUALIZADA'
      - Id_CatDirecc

   SIN CAMBIOS:
      - Mensaje
      - Accion = 'SIN_CAMBIOS'
      - Id_CatDirecc

   CONFLICTO (1062):
      - Mensaje
      - Accion = 'CONFLICTO'
      - Campo = 'CLAVE' | 'NOMBRE'
      - Id_Conflicto
      - Id_Direccion_Que_Intentabas_Editar
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_EditarDireccion$$
CREATE PROCEDURE SP_EditarDireccion(
    IN _Id_CatDirecc INT,
    IN _Nuevo_Clave VARCHAR(50),
    IN _Nuevo_Nombre VARCHAR(255)
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0) VARIABLES
       ======================================================================================== */

    /* Valores actuales de la dirección (para “SIN_CAMBIOS”) */
    DECLARE v_Clave_Actual  VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre_Actual VARCHAR(255) DEFAULT NULL;

    /* Posibles filas “en conflicto” (por clave o por nombre) */
    DECLARE v_Id_Direc_DupClave INT DEFAULT NULL;
    DECLARE v_Id_Direc_DupNombre INT DEFAULT NULL;

    /* Auxiliar genérico para validar existencia en locks */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Auxiliar para pre-checks finales (duplicidad) */
    DECLARE v_DupId INT DEFAULT NULL;

    /* Bandera de choque 1062 en UPDATE */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* Para respuesta de conflicto controlado */
    DECLARE v_Id_Conflicto INT DEFAULT NULL;
    DECLARE v_Campo_Conflicto VARCHAR(20) DEFAULT NULL;

    /* Para lock determinístico (3 ids máximo) */
    DECLARE v_L1 INT DEFAULT NULL;
    DECLARE v_L2 INT DEFAULT NULL;
    DECLARE v_L3 INT DEFAULT NULL;
    DECLARE v_Min INT DEFAULT NULL;

    /* ========================================================================================
       PARTE 1) HANDLERS
       ======================================================================================== */

    /* 1062 (Duplicate entry):
       - No abortamos el SP de golpe.
       - Marcamos v_Dup=1 para devolver “CONFLICTO” controlado.
    */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* Cualquier otro error SQL:
       - rollback + relanzar el error real
    */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ========================================================================================
       PARTE 2) NORMALIZACIÓN
       ======================================================================================== */
    SET _Nuevo_Clave = NULLIF(TRIM(_Nuevo_Clave), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');

    /* ========================================================================================
       PARTE 3) VALIDACIONES BÁSICAS
       ======================================================================================== */
    IF _Id_CatDirecc IS NULL OR _Id_CatDirecc <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_CatDirecc inválido.';
    END IF;

    IF _Nuevo_Clave IS NULL OR _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Clave y Nombre son obligatorios.';
    END IF;

    /* ========================================================================================
       PARTE 4) TRANSACCIÓN PRINCIPAL
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1) Lectura inicial de la Dirección a editar (SIN bloquear todavía)
       ----------------------------------------------------------------------------------------
       - Aquí solo verificamos que exista y obtenemos valores actuales.
       - OJO: aún NO bloqueamos para poder hacer lock determinístico después.
       - Si alguien cambia algo en microsegundos, lo corregimos en PASO 4 (re-lectura con lock).
    ---------------------------------------------------------------------------------------- */
    SET v_Clave_Actual = NULL;
    SET v_Nombre_Actual = NULL;

    SELECT Clave, Nombre
      INTO v_Clave_Actual, v_Nombre_Actual
    FROM Cat_Direcciones
    WHERE Id_CatDirecc = _Id_CatDirecc
    LIMIT 1;

    IF v_Clave_Actual IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: La Dirección no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) Descubrir “posibles conflictos” (SIN bloquear todavía)
       ----------------------------------------------------------------------------------------
       - Buscamos qué fila (si existe) YA tiene la nueva Clave o el nuevo Nombre.
       - Esto nos permite saber QUÉ filas hay que bloquear en orden determinístico.
       - NO usamos FOR UPDATE aquí, justamente para NO inducir locks en orden variable.
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Direc_DupClave = NULL;

    SELECT Id_CatDirecc
      INTO v_Id_Direc_DupClave
    FROM Cat_Direcciones
    WHERE Clave = _Nuevo_Clave
      AND Id_CatDirecc <> _Id_CatDirecc
    LIMIT 1;

    SET v_Id_Direc_DupNombre = NULL;

    SELECT Id_CatDirecc
      INTO v_Id_Direc_DupNombre
    FROM Cat_Direcciones
    WHERE Nombre = _Nuevo_Nombre
      AND Id_CatDirecc <> _Id_CatDirecc
    LIMIT 1;

    /* ----------------------------------------------------------------------------------------
       PASO 3) LOCK DETERMINÍSTICO de filas relevantes (hasta 3)
       ----------------------------------------------------------------------------------------
       - Construimos la lista (Id a editar, Id por clave, Id por nombre)
       - Quitamos NULLs y duplicados
       - Bloqueamos SIEMPRE en orden ascendente:
           lock #1: el menor Id
           lock #2: el siguiente
           lock #3: el siguiente
       - Cada lock se hace con SELECT ... FOR UPDATE que NO devuelve result sets “extra”.
    ---------------------------------------------------------------------------------------- */
    SET v_L1 = _Id_CatDirecc;
    SET v_L2 = v_Id_Direc_DupClave;
    SET v_L3 = v_Id_Direc_DupNombre;

    /* Remover duplicados obvios */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 IS NOT NULL AND v_L2 IS NOT NULL AND v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* 3.1) Lock del menor */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SET v_Existe = NULL;

        SELECT 1 INTO v_Existe
        FROM Cat_Direcciones
        WHERE Id_CatDirecc = v_Min
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: fila a bloquear ya no existe (lock #1).';
        END IF;

        /* “Consumimos” el id bloqueado */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* 3.2) Lock del siguiente menor */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SET v_Existe = NULL;

        SELECT 1 INTO v_Existe
        FROM Cat_Direcciones
        WHERE Id_CatDirecc = v_Min
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: fila a bloquear ya no existe (lock #2).';
        END IF;

        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* 3.3) Lock del último (si existe) */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SET v_Existe = NULL;

        SELECT 1 INTO v_Existe
        FROM Cat_Direcciones
        WHERE Id_CatDirecc = v_Min
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: fila a bloquear ya no existe (lock #3).';
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) Re-lectura de la Dirección objetivo YA con lock (consistencia)
       ----------------------------------------------------------------------------------------
       - Ahora sí, ya tenemos un punto estable:
         la fila _Id_CatDirecc está bloqueada dentro de esta transacción.
       - Actualizamos “actuales” por si cambiaron entre PASO 1 y PASO 3.
    ---------------------------------------------------------------------------------------- */
    SET v_Clave_Actual = NULL;
    SET v_Nombre_Actual = NULL;

    SELECT Clave, Nombre
      INTO v_Clave_Actual, v_Nombre_Actual
    FROM Cat_Direcciones
    WHERE Id_CatDirecc = _Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_Clave_Actual IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: La Dirección no existe (desapareció durante la edición).';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5) SIN CAMBIOS (salida temprana)
       ----------------------------------------------------------------------------------------
       - Si el usuario no cambió ni Clave ni Nombre:
         devolvemos “SIN_CAMBIOS” y liberamos locks rápido (COMMIT).
    ---------------------------------------------------------------------------------------- */
    IF v_Clave_Actual = _Nuevo_Clave
       AND v_Nombre_Actual = _Nuevo_Nombre THEN

        COMMIT;

        SELECT 'Sin cambios: La Dirección ya tiene esa Clave y ese Nombre.' AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Id_CatDirecc AS Id_CatDirecc;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 6) Pre-check duplicidad por CLAVE (otro Id)
       ----------------------------------------------------------------------------------------
       - Aquí ya estamos bajo locks determinísticos, así reducimos deadlocks.
       - Excluimos el mismo Id_CatDirecc (edición del propio registro).
    ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_CatDirecc
      INTO v_DupId
    FROM Cat_Direcciones
    WHERE Clave = _Nuevo_Clave
      AND Id_CatDirecc <> _Id_CatDirecc
    ORDER BY Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRA Dirección con esa CLAVE.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7) Pre-check duplicidad por NOMBRE (otro Id)
    ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_CatDirecc
      INTO v_DupId
    FROM Cat_Direcciones
    WHERE Nombre = _Nuevo_Nombre
      AND Id_CatDirecc <> _Id_CatDirecc
    ORDER BY Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRA Dirección con ese NOMBRE.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 8) UPDATE FINAL (aquí puede aparecer 1062 por carrera)
       ----------------------------------------------------------------------------------------
       - Reseteamos v_Dup = 0 justo antes del UPDATE.
       - Si alguien “se coló” entre nuestros checks y el update (concurrencia real),
         el UNIQUE dispara 1062 y nuestro handler marca v_Dup=1.
    ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    UPDATE Cat_Direcciones
    SET Clave = _Nuevo_Clave,
        Nombre = _Nuevo_Nombre,
        updated_at = NOW()
    WHERE Id_CatDirecc = _Id_CatDirecc;

    /* ----------------------------------------------------------------------------------------
       PASO 9) Si hubo 1062 => CONFLICTO CONTROLADO
       ----------------------------------------------------------------------------------------
       - ROLLBACK: no guardamos nada.
       - Re-consultamos quién causó el choque:
           * primero por Clave
           * si no, por Nombre
       - Devolvemos datos para UI (mensaje + Id_Conflicto).
    ---------------------------------------------------------------------------------------- */
    IF v_Dup = 1 THEN
        ROLLBACK;

        SET v_Id_Conflicto = NULL;
        SET v_Campo_Conflicto = NULL;

        /* 9.1) Conflicto por Clave */
        SELECT Id_CatDirecc
          INTO v_Id_Conflicto
        FROM Cat_Direcciones
        WHERE Clave = _Nuevo_Clave
          AND Id_CatDirecc <> _Id_CatDirecc
        ORDER BY Id_CatDirecc
        LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
            SET v_Campo_Conflicto = 'CLAVE';
        ELSE
            /* 9.2) Conflicto por Nombre */
            SELECT Id_CatDirecc
              INTO v_Id_Conflicto
            FROM Cat_Direcciones
            WHERE Nombre = _Nuevo_Nombre
              AND Id_CatDirecc <> _Id_CatDirecc
            ORDER BY Id_CatDirecc
            LIMIT 1;

            IF v_Id_Conflicto IS NOT NULL THEN
                SET v_Campo_Conflicto = 'NOMBRE';
            END IF;
        END IF;

        SELECT 'No se guardó: otro usuario se adelantó. Refresca y vuelve a intentar.' AS Mensaje,
               'CONFLICTO' AS Accion,
               v_Campo_Conflicto AS Campo,
               v_Id_Conflicto AS Id_Conflicto,
               _Id_CatDirecc AS Id_Direccion_Que_Intentabas_Editar;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       ÉXITO
    ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 'Dirección actualizada correctamente' AS Mensaje,
           'ACTUALIZADA' AS Accion,
           _Id_CatDirecc AS Id_CatDirecc;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarSubdireccion  (VERSIÓN PRO “REAL”: Lock determinístico + SIN CAMBIOS + 1062 controlado)
   ============================================================================================

   OBJETIVO
   --------
   Editar una Subdirección existente permitiendo:
   - Cambiar Clave
   - Cambiar Nombre
   - (Opcionalmente) moverla a otra Dirección (Fk_Id_CatDirecc)

   ¿CUÁNDO SE USA?
   --------------
   - Formulario “Editar Subdirección”
   - El usuario modifica:
        * _Nuevo_Clave
        * _Nuevo_Nombre
     y elige en -- DROPdown:
        * _Nuevo_Id_Direccion (solo direcciones activas listadas por UI)

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   1) La Subdirección a editar DEBE existir.
      - Se bloquea su fila con FOR UPDATE para que nadie la edite al mismo tiempo.
   2) La Dirección destino DEBE existir y estar Activa=1.
      - La UI normalmente solo lista activas, pero aquí lo exigimos en backend.
   3) Anti-duplicados en la Dirección destino:
      - NO puede existir OTRA Subdirección en la Dirección destino con la misma Clave.
        (UNIQUE compuesto: (Fk_Id_CatDirecc, Clave))
      - NO puede existir OTRA Subdirección en la Dirección destino con el mismo Nombre.
        (UNIQUE compuesto: (Fk_Id_CatDirecc, Nombre))
      - Se excluye el mismo Id_CatSubDirec para permitir “guardar sin cambios”.
   4) Si el usuario no cambió nada (Clave, Nombre y Dirección iguales) => “SIN_CAMBIOS”.
   5) Se ejecuta el UPDATE.
   6) Si por concurrencia ocurre 1062 en UPDATE => respuesta “CONFLICTO” controlada.

   PRO “DE VERDAD”: LOCK DETERMINÍSTICO DE DIRECCIONES (ANTI-DEADLOCKS)
   --------------------------------------------------------------------
   PROBLEMA:
   - Si una transacción mueve Subdirección X de Dirección A -> Dirección B
     y otra transacción mueve Subdirección Y de Dirección B -> Dirección A
     pueden terminar bloqueando direcciones en orden diferente => deadlock.
   SOLUCIÓN:
   - Bloquear direcciones SIEMPRE en el mismo orden numérico:
        Dir_Low  = min(DirActual, DirDestino)
        Dir_High = max(DirActual, DirDestino)
     y se bloquean en ese orden con FOR UPDATE.

   RESULTADO
   ---------
   ÉXITO:
      - Mensaje, Accion='ACTUALIZADA', Id_CatSubDirec, Id_Direccion...

   SIN CAMBIOS:
      - Mensaje, Accion='SIN_CAMBIOS', Id_CatSubDirec...

   CONFLICTO (1062):
      - Mensaje, Accion='CONFLICTO', Campo='CLAVE'|'NOMBRE', Id_Conflicto...
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_EditarSubdireccion$$
CREATE PROCEDURE SP_EditarSubdireccion(
    IN _Id_CatSubDirec INT,
    IN _Nuevo_Clave VARCHAR(50),
    IN _Nuevo_Nombre VARCHAR(255),
    IN _Nuevo_Id_Direccion INT
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0) VARIABLES
       ======================================================================================== */

    /* Datos actuales (para poder detectar “SIN CAMBIOS”) */
    DECLARE v_Clave_Actual VARCHAR(50)   DEFAULT NULL;
    DECLARE v_Nombre_Actual VARCHAR(255) DEFAULT NULL;
    DECLARE v_Id_Direccion_Actual INT    DEFAULT NULL;

    /* Auxiliares de validación / duplicidad */
    DECLARE v_Existe INT DEFAULT NULL;
    DECLARE v_DupId INT DEFAULT NULL;

    /* Bandera de choque 1062 en UPDATE */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* Datos para respuesta de conflicto controlado */
    DECLARE v_Id_Conflicto INT DEFAULT NULL;
    DECLARE v_Campo_Conflicto VARCHAR(20) DEFAULT NULL;

    /* Para lock determinístico de direcciones */
    DECLARE v_Dir_Low INT DEFAULT NULL;
    DECLARE v_Dir_High INT DEFAULT NULL;

    /* ========================================================================================
       PARTE 1) HANDLERS
       ======================================================================================== */

    /* 1062 (Duplicate entry):
       - No abortamos el SP de golpe.
       - Marcamos v_Dup = 1 para regresar “CONFLICTO” controlado.
    */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* Cualquier otro error SQL:
       - rollback + relanzar error real
    */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ========================================================================================
       PARTE 2) NORMALIZACIÓN
       ======================================================================================== */
    SET _Nuevo_Clave = NULLIF(TRIM(_Nuevo_Clave), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');

    /* ========================================================================================
       PARTE 3) VALIDACIONES BÁSICAS
       ======================================================================================== */
    IF _Id_CatSubDirec IS NULL OR _Id_CatSubDirec <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_CatSubDirec inválido.';
    END IF;

    IF _Nuevo_Id_Direccion IS NULL OR _Nuevo_Id_Direccion <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_Direccion destino inválido.';
    END IF;

    IF _Nuevo_Clave IS NULL OR _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Clave y Nombre de la Subdirección son obligatorios.';
    END IF;

    /* ========================================================================================
       PARTE 4) TRANSACCIÓN PRINCIPAL
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1) Bloquear la Subdirección a editar y leer sus valores actuales
       ----------------------------------------------------------------------------------------
       - FOR UPDATE bloquea la fila de la Subdirección => nadie la edita en paralelo.
       - De aquí sacamos:
           * v_Clave_Actual
           * v_Nombre_Actual
           * v_Id_Direccion_Actual (para lock determinístico entre Dirección actual y destino)
       ---------------------------------------------------------------------------------------- */
    SET v_Clave_Actual = NULL;
    SET v_Nombre_Actual = NULL;
    SET v_Id_Direccion_Actual = NULL;

    SELECT
        S.Clave,
        S.Nombre,
        S.Fk_Id_CatDirecc
    INTO
        v_Clave_Actual,
        v_Nombre_Actual,
        v_Id_Direccion_Actual
    FROM Cat_Subdirecciones S
    WHERE S.Id_CatSubDirec = _Id_CatSubDirec
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Direccion_Actual IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: La Subdirección no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) LOCK DETERMINÍSTICO DE DIRECCIONES (anti-deadlocks)
       ----------------------------------------------------------------------------------------
       - Vamos a bloquear SIEMPRE las direcciones en el mismo orden numérico:
           Dir_Low  = min(DirActual, DirDestino)
           Dir_High = max(DirActual, DirDestino)
       - Esto evita deadlocks cuando hay movimientos cruzados A<->B en paralelo.
       ---------------------------------------------------------------------------------------- */
    IF v_Id_Direccion_Actual = _Nuevo_Id_Direccion THEN
        SET v_Dir_Low  = v_Id_Direccion_Actual;
        SET v_Dir_High = v_Id_Direccion_Actual;
    ELSE
        SET v_Dir_Low  = LEAST(v_Id_Direccion_Actual, _Nuevo_Id_Direccion);
        SET v_Dir_High = GREATEST(v_Id_Direccion_Actual, _Nuevo_Id_Direccion);
    END IF;

    /* 2.1) Bloquear Dirección LOW (debe existir) */
    SET v_Existe = NULL;

    SELECT 1
      INTO v_Existe
    FROM Cat_Direcciones
    WHERE Id_CatDirecc = v_Dir_Low
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: Dirección (low) no existe.';
    END IF;

    /* 2.2) Bloquear Dirección HIGH (si es distinta) */
    IF v_Dir_High <> v_Dir_Low THEN
        SET v_Existe = NULL;

        SELECT 1
          INTO v_Existe
        FROM Cat_Direcciones
        WHERE Id_CatDirecc = v_Dir_High
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: Dirección (high) no existe.';
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) Validar Dirección destino ACTIVA (contrato con UI)
       ----------------------------------------------------------------------------------------
       - La UI normalmente lista solo direcciones activas.
       - Aquí lo exigimos para impedir:
           * “guardar” hacia una dirección que se desactivó mientras el usuario editaba.
       - FOR UPDATE aquí es redundante porque ya bloqueamos en PASO 2,
         pero lo dejamos por claridad del “contrato”.
       ---------------------------------------------------------------------------------------- */
    SET v_Existe = NULL;

    SELECT 1
      INTO v_Existe
    FROM Cat_Direcciones
    WHERE Id_CatDirecc = _Nuevo_Id_Direccion
      AND Activo = 1
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: La Dirección destino no existe o está inactiva.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) SIN CAMBIOS (salida temprana)
       ----------------------------------------------------------------------------------------
       - Si no cambió:
           * Clave
           * Nombre
           * Dirección
         devolvemos “SIN_CAMBIOS”.
       - COMMIT inmediato => libera locks rápido (mejor concurrencia).
       ---------------------------------------------------------------------------------------- */
    IF v_Clave_Actual = _Nuevo_Clave
       AND v_Nombre_Actual = _Nuevo_Nombre
       AND v_Id_Direccion_Actual = _Nuevo_Id_Direccion THEN

        COMMIT;

        SELECT 'Sin cambios: La Subdirección ya tiene esos datos y ya pertenece a esa Dirección.' AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Id_CatSubDirec AS Id_CatSubDirec,
               _Nuevo_Id_Direccion AS Id_Direccion,            -- alias compatible
               v_Id_Direccion_Actual AS Id_Direccion_Anterior,
               _Nuevo_Id_Direccion AS Id_Direccion_Nueva;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5) Pre-check duplicidad por CLAVE en la Dirección destino (excluyendo el mismo Id)
       ----------------------------------------------------------------------------------------
       - Reglas:
         * Dentro de la misma Dirección destino, la Clave debe ser única.
         * Excluimos el mismo Id_CatSubDirec para permitir actualización del propio registro.
       - ORDER BY Id: lock determinístico.
       - FOR UPDATE: si encuentra duplicado, bloquea esa fila durante tu TX.
       ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_CatSubDirec
      INTO v_DupId
    FROM Cat_Subdirecciones
    WHERE Fk_Id_CatDirecc = _Nuevo_Id_Direccion
      AND Clave = _Nuevo_Clave
      AND Id_CatSubDirec <> _Id_CatSubDirec
    ORDER BY Id_CatSubDirec
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRA Subdirección con esa CLAVE en la Dirección destino.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 6) Pre-check duplicidad por NOMBRE en la Dirección destino (excluyendo el mismo Id)
       ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_CatSubDirec
      INTO v_DupId
    FROM Cat_Subdirecciones
    WHERE Fk_Id_CatDirecc = _Nuevo_Id_Direccion
      AND Nombre = _Nuevo_Nombre
      AND Id_CatSubDirec <> _Id_CatSubDirec
    ORDER BY Id_CatSubDirec
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRA Subdirección con ese NOMBRE en la Dirección destino.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7) UPDATE FINAL (aquí puede aparecer 1062 por carrera)
       ----------------------------------------------------------------------------------------
       - Reseteamos v_Dup=0 antes del UPDATE para detectar si el handler se disparó aquí.
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    UPDATE Cat_Subdirecciones
    SET Clave = _Nuevo_Clave,
        Nombre = _Nuevo_Nombre,
        Fk_Id_CatDirecc = _Nuevo_Id_Direccion,
        updated_at = NOW()
    WHERE Id_CatSubDirec = _Id_CatSubDirec;

    /* ----------------------------------------------------------------------------------------
       PASO 8) Si hubo 1062 => CONFLICTO CONTROLADO
       ----------------------------------------------------------------------------------------
       - ROLLBACK: no guardamos nada.
       - Buscamos el Id_CatSubDirec que “ganó” el valor en la Dirección destino:
           * primero por CLAVE
           * si no, por NOMBRE
       - Devolvemos respuesta clara para UI.
       ---------------------------------------------------------------------------------------- */
    IF v_Dup = 1 THEN
        ROLLBACK;

        SET v_Id_Conflicto = NULL;
        SET v_Campo_Conflicto = NULL;

        /* 8.1) Conflicto por CLAVE */
        SELECT Id_CatSubDirec
          INTO v_Id_Conflicto
        FROM Cat_Subdirecciones
        WHERE Fk_Id_CatDirecc = _Nuevo_Id_Direccion
          AND Clave = _Nuevo_Clave
          AND Id_CatSubDirec <> _Id_CatSubDirec
        ORDER BY Id_CatSubDirec
        LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
            SET v_Campo_Conflicto = 'CLAVE';
        ELSE
            /* 8.2) Conflicto por NOMBRE */
            SELECT Id_CatSubDirec
              INTO v_Id_Conflicto
            FROM Cat_Subdirecciones
            WHERE Fk_Id_CatDirecc = _Nuevo_Id_Direccion
              AND Nombre = _Nuevo_Nombre
              AND Id_CatSubDirec <> _Id_CatSubDirec
            ORDER BY Id_CatSubDirec
            LIMIT 1;

            IF v_Id_Conflicto IS NOT NULL THEN
                SET v_Campo_Conflicto = 'NOMBRE';
            END IF;
        END IF;

        SELECT 'No se guardó: otro usuario se adelantó. Refresca y vuelve a intentar.' AS Mensaje,
               'CONFLICTO' AS Accion,
               v_Campo_Conflicto AS Campo,
               v_Id_Conflicto AS Id_Conflicto,
               _Id_CatSubDirec AS Id_Subdireccion_Que_Intentabas_Editar,
               _Nuevo_Id_Direccion AS Id_Direccion_Destino,
               v_Id_Direccion_Actual AS Id_Direccion_Anterior,
               _Nuevo_Id_Direccion AS Id_Direccion_Nueva;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 9) ÉXITO
       ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 'Subdirección actualizada correctamente' AS Mensaje,
           'ACTUALIZADA' AS Accion,
           _Id_CatSubDirec AS Id_CatSubDirec,
           _Nuevo_Id_Direccion AS Id_Direccion,            -- alias compatible
           v_Id_Direccion_Actual AS Id_Direccion_Anterior,
           _Nuevo_Id_Direccion AS Id_Direccion_Nueva;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarGerencia  (VERSIÓN PRO “REAL”: Locks determinísticos + JOIN atómico + SIN CAMBIOS + 1062)
   ============================================================================================

   CONTEXTO DE UI (CÓMO FUNCIONA TU FORMULARIO)
   --------------------------------------------
   1) El frontend precarga el registro con SP_ConsultarGerenciaEspecifica:
      - Clave, Nombre, timestamps
      - Dirección actual (Abuelo)
      - Subdirección actual (Padre)

   2) El usuario puede:
      - Cambiar Clave y/o Nombre
      - Cambiar Subdirección destino (dentro de la Dirección actual)
      - O cambiar Dirección (-- DROPdown) => recarga Subdirecciones => elegir nueva Subdirección

   IMPORTANTE (DISEÑO DE DATOS)
   ----------------------------
   - Gerencia NO tiene Fk_Id_CatDirecc.
   - La “Dirección” de una Gerencia se determina por la Subdirección:
         Gerencia.Fk_Id_CatSubDirec -> Subdirección.Fk_Id_CatDirecc
   - Entonces “cambiar Dirección” realmente significa:
         elegir una Subdirección destino que pertenezca a la Dirección elegida.

   ¿POR QUÉ ESTE SP RECIBE _Id_Direccion_Seleccionada SI YA RECIBE _Id_Subdireccion_Destino?
   -----------------------------------------------------------------------------------------
   - Porque tu UI trabaja en cascada Dirección -> Subdirección.
   - En teoría la Subdirección elegida SIEMPRE pertenece a esa Dirección.
   - PERO en backend se valida para blindar contra:
       * requests manipuladas
       * bugs del frontend
       * catálogos cambiaron mientras el usuario editaba
       * subdirecciones cacheadas

   OBJETIVO
   --------
   Editar una Gerencia existente permitiendo:
   - Cambiar Clave
   - Cambiar Nombre
   - Moverla a otra Subdirección (y posiblemente otra Dirección)

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   1) La Gerencia a editar DEBE existir.
   2) La Dirección seleccionada DEBE existir y estar Activa=1.
   3) La Subdirección destino DEBE:
      - existir
      - estar Activa=1
      - pertenecer a la Dirección seleccionada
   4) Anti-duplicados dentro de la Subdirección destino:
      - NO puede existir OTRA Gerencia con la misma Clave en la Subdirección destino.
      - NO puede existir OTRA Gerencia con el mismo Nombre en la Subdirección destino.
      (se excluye el mismo Id_CatGeren)
   5) Si el usuario realmente no cambió nada => “SIN_CAMBIOS” (no “ACTUALIZADA”).
   6) Se ejecuta el UPDATE.

   CONCURRENCIA (POR QUÉ EXISTE HANDLER 1062 EN UPDATE)
   ----------------------------------------------------
   Aunque hagas pre-checks, puede pasar una carrera:
   - Usuario A y B editan al mismo tiempo hacia la misma (Clave/Nombre + Subdirección destino).
   - Ambos “ven” que no hay duplicado.
   - A guarda primero.
   - B choca con UNIQUE => MySQL lanza 1062.

   SOLUCIÓN PRO EN EDICIÓN: 1062 => CONFLICTO (NO “REUSAR”)
   --------------------------------------------------------
   En EDITAR no queremos usar el registro del otro usuario.
   Queremos avisar:
     - Accion = 'CONFLICTO'
     - Campo  = 'CLAVE' o 'NOMBRE'
     - Id_Conflicto = Id de la gerencia que ya tomó ese valor

   ¿QUÉ CAMBIA vs TU SP ACTUAL?
   ----------------------------
   A) “LOCK DETERMINÍSTICO DE DIRECCIONES”
      - Si la gerencia está en Dirección A y la mueves a Dirección B, dos usuarios cruzados
        pueden provocar deadlocks si bloquean Direcciones en diferente orden.
      - SOLUCIÓN: bloquear SIEMPRE en orden por Id:
          1) Dir LOW  (min(DirActual, DirSeleccionada))
          2) Dir HIGH (max(DirActual, DirSeleccionada))

   B) “JOIN ÚNICO DIRECCIÓN -> SUBDIRECCIÓN DESTINO”
      - En lugar de validar Dirección y Subdirección por separado, se valida TODO de un jalón.

   C) “SIN CAMBIOS”
      - Si Clave, Nombre y Subdirección destino son iguales al actual:
        - COMMIT inmediato (para liberar locks)
        - Accion = 'SIN_CAMBIOS'

   RESULTADO
   ---------
   ÉXITO:
     - Mensaje, Accion='ACTUALIZADA', Id_CatGeren, Id_Subdireccion_Anterior, Id_Subdireccion_Nueva...

   SIN CAMBIOS:
     - Mensaje, Accion='SIN_CAMBIOS', Id_CatGeren...

   CONFLICTO (1062):
     - Mensaje, Accion='CONFLICTO', Campo, Id_Conflicto...
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_EditarGerencia$$
CREATE PROCEDURE SP_EditarGerencia(
    IN _Id_CatGeren INT,
    IN _Nuevo_Clave VARCHAR(50),
    IN _Nuevo_Nombre VARCHAR(255),
    IN _Id_Direccion_Seleccionada INT,
    IN _Id_Subdireccion_Destino INT
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0) VARIABLES
       ======================================================================================== */

    /* Datos actuales de la gerencia (para "SIN CAMBIOS") */
    DECLARE v_Clave_Actual  VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre_Actual VARCHAR(255) DEFAULT NULL;

    /* “Subdirección anterior” (para respuesta y para saber si se movió o no) */
    DECLARE v_Subdireccion_Anterior INT DEFAULT NULL;

    /* Dirección actual de la gerencia (derivada de la Subdirección anterior) */
    DECLARE v_Id_Direccion_Actual INT DEFAULT NULL;

    /* Variable auxiliar genérica para existencia / validaciones */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Para pre-checks de duplicados */
    DECLARE v_DupId INT DEFAULT NULL;

    /* Bandera para detectar choque 1062 en UPDATE */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* Datos para respuesta de conflicto controlado */
    DECLARE v_Id_Conflicto INT DEFAULT NULL;
    DECLARE v_Campo_Conflicto VARCHAR(20) DEFAULT NULL;

    /* Para lock determinístico de direcciones */
    DECLARE v_Dir_Low INT DEFAULT NULL;
    DECLARE v_Dir_High INT DEFAULT NULL;

    /* ========================================================================================
       PARTE 1) HANDLERS (CONCURRENCIA Y ERRORES)
       ======================================================================================== */

    /* 1062 (Duplicate entry):
       - No abortamos inmediatamente, marcamos v_Dup=1 para responder “CONFLICTO” controlado.
    */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* Cualquier otro error SQL:
       - rollback y re-lanzar el error para que el backend lo vea tal cual.
    */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ========================================================================================
       PARTE 2) NORMALIZACIÓN DE INPUTS (defensivo)
       ======================================================================================== */
    SET _Nuevo_Clave  = NULLIF(TRIM(_Nuevo_Clave), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');

    /* ========================================================================================
       PARTE 3) VALIDACIONES BÁSICAS (antes de abrir TX)
       ======================================================================================== */
    IF _Id_CatGeren IS NULL OR _Id_CatGeren <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_CatGeren inválido.';
    END IF;

    IF _Nuevo_Clave IS NULL OR _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Clave y Nombre de la Gerencia son obligatorios.';
    END IF;

    IF _Id_Direccion_Seleccionada IS NULL OR _Id_Direccion_Seleccionada <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Dirección seleccionada inválida.';
    END IF;

    IF _Id_Subdireccion_Destino IS NULL OR _Id_Subdireccion_Destino <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Subdirección destino inválida.';
    END IF;

    /* ========================================================================================
       PARTE 4) TRANSACCIÓN PRINCIPAL
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1) Bloquear la Gerencia a editar y leer su estado anterior + datos actuales
       ----------------------------------------------------------------------------------------
       - Aquí bloqueamos SOLO la fila de la Gerencia (FOR UPDATE).
       - ¿Por qué?
         * Evita que otro usuario cambie esta misma Gerencia mientras tú la editas.
         * Nos permite obtener:
             - v_Subdireccion_Anterior (para respuesta)
             - v_Clave_Actual y v_Nombre_Actual (para detectar “SIN CAMBIOS”)
       - NOTA: NO bloqueamos Subdirección/Dirección aquí para minimizar riesgo de deadlocks.
       ---------------------------------------------------------------------------------------- */
    SET v_Subdireccion_Anterior = NULL;
    SET v_Clave_Actual = NULL;
    SET v_Nombre_Actual = NULL;

    SELECT
        G.Fk_Id_CatSubDirec,
        G.Clave,
        G.Nombre
    INTO
        v_Subdireccion_Anterior,
        v_Clave_Actual,
        v_Nombre_Actual
    FROM Cat_Gerencias_Activos G
    WHERE G.Id_CatGeren = _Id_CatGeren
    LIMIT 1
    FOR UPDATE;

    IF v_Subdireccion_Anterior IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: La Gerencia no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 1.1) Obtener Dirección ACTUAL de la gerencia (derivado de la Subdirección anterior)
       ----------------------------------------------------------------------------------------
       - Solo necesitamos el Id de la dirección actual para hacer lock determinístico.
       - Si la Subdirección anterior no existe por alguna inconsistencia, abortamos.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Direccion_Actual = NULL;

    SELECT S.Fk_Id_CatDirecc
      INTO v_Id_Direccion_Actual
    FROM Cat_Subdirecciones S
    WHERE S.Id_CatSubDirec = v_Subdireccion_Anterior
    LIMIT 1;

    IF v_Id_Direccion_Actual IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Inconsistencia: la Subdirección actual de la Gerencia no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) LOCK DETERMINÍSTICO DE DIRECCIONES (anti-deadlocks)
       ----------------------------------------------------------------------------------------
       PROBLEMA QUE RESUELVE:
       - Si dos transacciones intentan mover gerencias entre Dirección A y Dirección B cruzadas,
         se puede generar DEADLOCK.
       SOLUCIÓN:
       - Bloqueamos SIEMPRE en el mismo orden:
         1) v_Dir_Low  = min(DirActual, DirSeleccionada)
         2) v_Dir_High = max(DirActual, DirSeleccionada)
       ---------------------------------------------------------------------------------------- */
    IF v_Id_Direccion_Actual = _Id_Direccion_Seleccionada THEN
        SET v_Dir_Low  = v_Id_Direccion_Actual;
        SET v_Dir_High = v_Id_Direccion_Actual;
    ELSE
        SET v_Dir_Low  = LEAST(v_Id_Direccion_Actual, _Id_Direccion_Seleccionada);
        SET v_Dir_High = GREATEST(v_Id_Direccion_Actual, _Id_Direccion_Seleccionada);
    END IF;

    /* 2.1) Bloquear Dirección LOW (debe existir) */
    SET v_Existe = NULL;

    SELECT 1 INTO v_Existe
    FROM Cat_Direcciones
    WHERE Id_CatDirecc = v_Dir_Low
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: Dirección (low) no existe.';
    END IF;

    /* 2.2) Bloquear Dirección HIGH (si es distinta) */
    IF v_Dir_High <> v_Dir_Low THEN
        SET v_Existe = NULL;

        SELECT 1 INTO v_Existe
        FROM Cat_Direcciones
        WHERE Id_CatDirecc = v_Dir_High
        LIMIT 1
        FOR UPDATE;

        IF v_Existe IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Inconsistencia: Dirección (high) no existe.';
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) Validación ATÓMICA (JOIN único): Dirección seleccionada + Subdirección destino
       ----------------------------------------------------------------------------------------
       Validamos TODO en un solo SELECT:
       - Dirección existe y Activo=1
       - Subdirección existe y Activo=1
       - Subdirección pertenece a la Dirección seleccionada
       Además:
       - FOR UPDATE aquí bloquea la fila de la Subdirección destino.
       ---------------------------------------------------------------------------------------- */
    SET v_Existe = NULL;

    SELECT 1 INTO v_Existe
    FROM Cat_Direcciones D
    STRAIGHT_JOIN Cat_Subdirecciones S ON S.Fk_Id_CatDirecc = D.Id_CatDirecc
    WHERE D.Id_CatDirecc = _Id_Direccion_Seleccionada
      AND D.Activo = 1
      AND S.Id_CatSubDirec = _Id_Subdireccion_Destino
      AND S.Activo = 1
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: La Subdirección destino no pertenece a la Dirección seleccionada o alguna está inactiva.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) SIN CAMBIOS (salida temprana)
       ----------------------------------------------------------------------------------------
       - Si Clave, Nombre y Subdirección destino son iguales al actual:
         COMMIT inmediato para liberar locks.
       ---------------------------------------------------------------------------------------- */
    IF v_Clave_Actual = _Nuevo_Clave
       AND v_Nombre_Actual = _Nuevo_Nombre
       AND v_Subdireccion_Anterior = _Id_Subdireccion_Destino THEN

        COMMIT;

        SELECT 'Sin cambios: La Gerencia ya tiene esos datos y ya está en esa Subdirección.' AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Id_CatGeren AS Id_CatGeren,
               v_Subdireccion_Anterior AS Id_Subdireccion_Anterior,
               _Id_Subdireccion_Destino AS Id_Subdireccion_Nueva,
               _Id_Direccion_Seleccionada AS Id_Direccion_Seleccionada;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5) Pre-check duplicidad por CLAVE en la Subdirección destino (excluyendo el mismo Id)
       ----------------------------------------------------------------------------------------
       - FOR UPDATE: si encuentra la fila duplicada, la bloquea.
       - ORDER BY Id: lock determinístico.
       ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_CatGeren
      INTO v_DupId
    FROM Cat_Gerencias_Activos
    WHERE Fk_Id_CatSubDirec = _Id_Subdireccion_Destino
      AND Clave = _Nuevo_Clave
      AND Id_CatGeren <> _Id_CatGeren
    ORDER BY Id_CatGeren
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRA Gerencia con esa CLAVE en la Subdirección destino.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 6) Pre-check duplicidad por NOMBRE en la Subdirección destino
       ---------------------------------------------------------------------------------------- */
    SET v_DupId = NULL;

    SELECT Id_CatGeren
      INTO v_DupId
    FROM Cat_Gerencias_Activos
    WHERE Fk_Id_CatSubDirec = _Id_Subdireccion_Destino
      AND Nombre = _Nuevo_Nombre
      AND Id_CatGeren <> _Id_CatGeren
    ORDER BY Id_CatGeren
    LIMIT 1
    FOR UPDATE;

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Ya existe OTRA Gerencia con ese NOMBRE en la Subdirección destino.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7) UPDATE (aquí puede ocurrir 1062 por carrera)
       ----------------------------------------------------------------------------------------
       - Reseteamos v_Dup = 0 antes del UPDATE.
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    UPDATE Cat_Gerencias_Activos
    SET Clave = _Nuevo_Clave,
        Nombre = _Nuevo_Nombre,
        Fk_Id_CatSubDirec = _Id_Subdireccion_Destino,
        updated_at = NOW()
    WHERE Id_CatGeren = _Id_CatGeren;

    /* ----------------------------------------------------------------------------------------
       PASO 8) Si hubo 1062 => CONFLICTO CONTROLADO
       ----------------------------------------------------------------------------------------
       - Hacemos ROLLBACK.
       - Determinamos si el conflicto fue por CLAVE o NOMBRE.
       ---------------------------------------------------------------------------------------- */
    IF v_Dup = 1 THEN
        ROLLBACK;

        SET v_Id_Conflicto = NULL;
        SET v_Campo_Conflicto = NULL;

        /* 8.1) Intentar detectar conflicto por CLAVE */
        SELECT Id_CatGeren
          INTO v_Id_Conflicto
        FROM Cat_Gerencias_Activos
        WHERE Fk_Id_CatSubDirec = _Id_Subdireccion_Destino
          AND Clave = _Nuevo_Clave
          AND Id_CatGeren <> _Id_CatGeren
        ORDER BY Id_CatGeren
        LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
            SET v_Campo_Conflicto = 'CLAVE';
        ELSE
            /* 8.2) Si no fue CLAVE, intentar conflicto por NOMBRE */
            SELECT Id_CatGeren
              INTO v_Id_Conflicto
            FROM Cat_Gerencias_Activos
            WHERE Fk_Id_CatSubDirec = _Id_Subdireccion_Destino
              AND Nombre = _Nuevo_Nombre
              AND Id_CatGeren <> _Id_CatGeren
            ORDER BY Id_CatGeren
            LIMIT 1;

            IF v_Id_Conflicto IS NOT NULL THEN
                SET v_Campo_Conflicto = 'NOMBRE';
            END IF;
        END IF;

        SELECT 'No se guardó: otro usuario se adelantó. Refresca y vuelve a intentar.' AS Mensaje,
               'CONFLICTO' AS Accion,
               v_Campo_Conflicto AS Campo,
               v_Id_Conflicto AS Id_Conflicto,
               _Id_CatGeren AS Id_Gerencia_Que_Intentabas_Editar,
               v_Subdireccion_Anterior AS Id_Subdireccion_Anterior,
               _Id_Subdireccion_Destino AS Id_Subdireccion_Nueva,
               _Id_Direccion_Seleccionada AS Id_Direccion_Seleccionada;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 9) ÉXITO
       ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 'Gerencia actualizada correctamente' AS Mensaje,
           'ACTUALIZADA' AS Accion,
           _Id_CatGeren AS Id_CatGeren,
           v_Subdireccion_Anterior AS Id_Subdireccion_Anterior,
           _Id_Subdireccion_Destino AS Id_Subdireccion_Nueva,
           _Id_Direccion_Seleccionada AS Id_Direccion_Seleccionada;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarDepartamento
   ============================================================================================
   AUTOR: Tu Equipo de Desarrollo / Gemini
   FECHA: 2025

   OBJETIVO DE NEGOCIO
   -------------------
   Actualizar la información operativa y ubicación de un Departamento existente.
   
   Este procedimiento no es un simple UPDATE; es un motor de validación que garantiza
   que la base de datos nunca quede en un estado inconsistente, incluso bajo condiciones
   de estrés (múltiples usuarios editando al mismo tiempo) o errores de capa de usuario.

   ARQUITECTURA DE INTEGRIDAD (POR QUÉ HACEMOS LO QUE HACEMOS)
   -----------------------------------------------------------
   
   1. VALIDACIÓN GEOGRÁFICA ATÓMICA (La Regla del "Lugar Imposible"):
      - Problema: Un usuario malintencionado o un bug en el Frontend podría enviar un ID de 
        Municipio que existe (ej: "Centro"), pero con un ID de Estado que no le corresponde 
        (ej: "Veracruz").
      - Solución: Realizamos un `STRAIGHT_JOIN` forzado entre País -> Estado -> Municipio.
      - Resultado: Solo permitimos el cambio si la cadena jerárquica es PERFECTA y si los
        tres niveles están ACTIVOS (1). Si el municipio "existe" pero su estado fue dado 
        de baja, la operación se bloquea.

   2. LA "TRIPLE RESTRICCIÓN" (Identidad Compuesta):
      - A diferencia de los Centros de Trabajo, la unicidad de un Departamento es compleja.
      - Regla: La combinación (Código + Nombre + Municipio) debe ser ÚNICA.
      - Escenario: 
         * Se permite 'DEP-RH' en Villahermosa y 'DEP-RH' en Paraíso.
         * Se bloquea 'DEP-RH' en Villahermosa si ya existe otro registro con esos mismos datos.
      - Implementación: Se realiza un "Pre-Check" excluyendo al propio ID (`Id <> _Id_CatDep`)
        para detectar colisiones antes de intentar escribir.

   3. BLOQUEO PESIMISTA (Pessimistic Locking):
      - Usamos `SELECT ... FOR UPDATE` al inicio.
      - Esto "congela" la fila del departamento. Nadie más puede editarla ni eliminarla
        hasta que terminemos. Esto evita el problema de "Lost Update" (dos usuarios sobreescribiéndose).

   4. IDEMPOTENCIA ("SIN CAMBIOS"):
      - Si los datos nuevos son idénticos a los actuales (incluyendo el manejo de NULLs en la dirección),
        el SP detecta que no hay trabajo que hacer.
      - Retorna éxito inmediato sin tocar el disco duro (ahorro de I/O) y sin ensuciar los logs de auditoría.

   5. MANEJO DE "RACE CONDITIONS" (Error 1062):
      - A pesar de los Pre-Checks, existe una probabilidad de 0.01% de que otro usuario inserte
        el duplicado justo en el milisegundo entre nuestro SELECT y nuestro UPDATE.
      - El `DECLARE HANDLER FOR 1062` actúa como red de seguridad final, capturando el error
        nativo de MySQL y traduciéndolo a un mensaje de negocio ("CONFLICTO") que la UI puede entender.

   RETORNO (TABLA DE RESULTADOS)
   -----------------------------
   - Mensaje: Feedback legible para el usuario.
   - Accion: 
       * 'ACTUALIZADA' (Cambio exitoso)
       * 'SIN_CAMBIOS' (No se tocó la BD)
       * 'CONFLICTO'   (Error de duplicidad/concurrencia)
   - Datos de Contexto: IDs para refrescar la vista del cliente.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarDepartamento`$$
CREATE PROCEDURE `SP_EditarDepartamento`(
    IN _Id_CatDep          INT,           -- Llave Primaria del registro a editar
    IN _Nuevo_Codigo       VARCHAR(50),   -- Nuevo Código (ej: 'DEP-001')
    IN _Nuevo_Nombre       VARCHAR(255),  -- Nuevo Nombre (ej: 'Recursos Humanos')
    IN _Nueva_Direccion    VARCHAR(255),  -- Nueva Dirección Física descriptiva
    IN _Nuevo_Id_Pais      INT,           -- Contexto para validación geográfica
    IN _Nuevo_Id_Estado    INT,           -- Contexto para validación geográfica
    IN _Nuevo_Id_Municipio INT            -- El dato real (FK) que se persistirá
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0: VARIABLES DE ESTADO (SNAPSHOTS)
       ======================================================================================== */
    /* Almacenan cómo está el registro AHORA (antes de editarlo) */
    DECLARE v_Codigo_Act    VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre_Act    VARCHAR(255) DEFAULT NULL;
    DECLARE v_Dir_Act       VARCHAR(255) DEFAULT NULL;
    DECLARE v_Mun_Act       INT          DEFAULT NULL;

    /* Variables auxiliares de control */
    DECLARE v_Existe        INT          DEFAULT NULL;
    DECLARE v_DupId         INT          DEFAULT NULL;
    DECLARE v_Dup           TINYINT(1)   DEFAULT 0; -- Bandera de error 1062

    /* Variables para reporte de conflictos */
    DECLARE v_Id_Conflicto  INT          DEFAULT NULL;

    /* ========================================================================================
       PARTE 1: HANDLERS (CONTROL DE ERRORES TÉCNICOS)
       ======================================================================================== */
    
    /* HANDLER 1062: Duplicate entry
       Si el UPDATE falla porque rompe el UNIQUE INDEX, no abortamos.
       Marcamos la bandera v_Dup = 1 y dejamos que el flujo llegue a la sección de manejo de errores. */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* HANDLER SQLEXCEPTION:
       Cualquier otro error (sintaxis, conexión, disco lleno) provoca un aborto seguro (ROLLBACK). */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ========================================================================================
       PARTE 2: NORMALIZACIÓN Y LIMPIEZA DE INPUTS
       ======================================================================================== */
    SET _Nuevo_Codigo    = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre    = NULLIF(TRIM(_Nuevo_Nombre), '');
    SET _Nueva_Direccion = NULLIF(TRIM(_Nueva_Direccion), '');

    /* Protección contra IDs inválidos (0 o negativos se convierten en NULL) */
    IF _Nuevo_Id_Pais <= 0      THEN SET _Nuevo_Id_Pais = NULL;      END IF;
    IF _Nuevo_Id_Estado <= 0    THEN SET _Nuevo_Id_Estado = NULL;    END IF;
    IF _Nuevo_Id_Municipio <= 0 THEN SET _Nuevo_Id_Municipio = NULL; END IF;

    /* ========================================================================================
       PARTE 3: VALIDACIONES BÁSICAS (FAIL FAST)
       Evitamos abrir transacciones si los datos mínimos no están presentes.
       ======================================================================================== */
    IF _Id_CatDep IS NULL OR _Id_CatDep <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: El ID del Departamento es inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL OR _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El Código y el Nombre son obligatorios.';
    END IF;

    IF _Nuevo_Id_Pais IS NULL OR _Nuevo_Id_Estado IS NULL OR _Nuevo_Id_Municipio IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: Debe seleccionar la ubicación completa (País, Estado y Municipio).';
    END IF;

    /* ========================================================================================
       PARTE 4: INICIO DE LA TRANSACCIÓN
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1: LEER Y BLOQUEAR EL REGISTRO ACTUAL
       ----------------------------------------------------------------------------------------
       Aplicamos `FOR UPDATE` para adquirir un "Write Lock" sobre la fila.
       Esto asegura que nadie más pueda modificar este departamento mientras nosotros decidimos qué hacer. */
    
    SET v_Codigo_Act = NULL;
    SET v_Nombre_Act = NULL; 
    SET v_Dir_Act = NULL; 
    SET v_Mun_Act = NULL;

    SELECT `Codigo`, `Nombre`, `Direccion_Fisica`, `Fk_Id_Municipio_CatDep`
      INTO v_Codigo_Act, v_Nombre_Act, v_Dir_Act, v_Mun_Act
    FROM `Cat_Departamentos`
    WHERE `Id_CatDep` = _Id_CatDep
    LIMIT 1
    FOR UPDATE;

    IF v_Codigo_Act IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE CONCURRENCIA: El Departamento que intenta editar ya no existe (fue eliminado por otro usuario).';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2: VALIDACIÓN ATÓMICA DE JERARQUÍA GEOGRÁFICA
       ----------------------------------------------------------------------------------------
       Validamos la cadena completa: País -> Estado -> Municipio.
       También bloqueamos la fila del Municipio destino para evitar que se desactive durante el guardado. */
    
    SET v_Existe = NULL;

    SELECT 1 INTO v_Existe
    FROM `Pais` P
    STRAIGHT_JOIN `Estado` E ON E.`Fk_Id_Pais` = P.`Id_Pais`
    STRAIGHT_JOIN `Municipio` M ON M.`Fk_Id_Estado` = E.`Id_Estado`
    WHERE P.`Id_Pais` = _Nuevo_Id_Pais       AND P.`Activo` = 1
      AND E.`Id_Estado` = _Nuevo_Id_Estado   AND E.`Activo` = 1
      AND M.`Id_Municipio` = _Nuevo_Id_Municipio AND M.`Activo` = 1
    LIMIT 1
    FOR UPDATE; /* Bloqueamos el municipio destino */

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD: La ubicación seleccionada es inconsistente (El Municipio no pertenece al Estado/País) o contiene elementos inactivos.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3: DETECCIÓN DE "SIN CAMBIOS" (OPTIMIZACIÓN)
       ----------------------------------------------------------------------------------------
       Comparamos campo por campo. Usamos `<=>` (Null-Safe Equality) para `Direccion_Fisica`
       porque puede ser NULL y `NULL = NULL` da NULL (falso), pero `NULL <=> NULL` da TRUE. */
    
    IF v_Codigo_Act = _Nuevo_Codigo 
       AND v_Nombre_Act = _Nuevo_Nombre 
       AND (v_Dir_Act <=> _Nueva_Direccion)
       AND (v_Mun_Act <=> _Nuevo_Id_Municipio) THEN
       
       COMMIT; -- Liberamos el lock inmediatamente
       
       SELECT 'No se detectaron cambios en la información.' AS Mensaje, 
              'SIN_CAMBIOS' AS Accion, 
              _Id_CatDep AS Id_Departamento;
       LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4: PRE-CHECK DE DUPLICADOS (LA TRIPLE RESTRICCIÓN)
       ----------------------------------------------------------------------------------------
       Buscamos si YA EXISTE otro registro (`Id <> _Id_CatDep`) que coincida con la nueva Triada.
       Esto previene el error 1062 proactivamente para dar un mensaje claro. */
    
    SET v_DupId = NULL;

    SELECT `Id_CatDep` INTO v_DupId
    FROM `Cat_Departamentos`
    WHERE `Codigo` = _Nuevo_Codigo
      AND `Nombre` = _Nuevo_Nombre
      AND `Fk_Id_Municipio_CatDep` = _Nuevo_Id_Municipio
      AND `Id_CatDep` <> _Id_CatDep -- CRUCIAL: Excluirme a mí mismo
    LIMIT 1
    FOR UPDATE; -- Bloqueamos al conflictivo para que no cambie mientras validamos

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: Ya existe otro Departamento con ese mismo CÓDIGO y NOMBRE en el MUNICIPIO seleccionado.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5: EJECUCIÓN DEL UPDATE (CRÍTICO)
       ----------------------------------------------------------------------------------------
       Si pasamos todas las validaciones, intentamos escribir.
       Aquí puede ocurrir el error 1062 si hay una "Race Condition" perfecta. */
    
    SET v_Dup = 0; -- Reset de bandera antes del intento

    UPDATE `Cat_Departamentos`
    SET `Codigo` = _Nuevo_Codigo,
        `Nombre` = _Nuevo_Nombre,
        `Direccion_Fisica` = _Nueva_Direccion,
        `Fk_Id_Municipio_CatDep` = _Nuevo_Id_Municipio
        /* `updated_at` se actualiza automáticamente por definición de tabla */
    WHERE `Id_CatDep` = _Id_CatDep;

    /* ----------------------------------------------------------------------------------------
       PASO 6: MANEJO DE COLISIÓN (SI HUBO ERROR 1062)
       ----------------------------------------------------------------------------------------
       Si v_Dup se activó, significa que el UPDATE falló.
       Hacemos Rollback y buscamos quién causó el conflicto para reportarlo al Frontend. */
    
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        SET v_Id_Conflicto = NULL;

        /* Buscamos el ID del registro que tiene nuestros datos */
        SELECT `Id_CatDep` INTO v_Id_Conflicto
        FROM `Cat_Departamentos`
        WHERE `Codigo` = _Nuevo_Codigo 
          AND `Nombre` = _Nuevo_Nombre
          AND `Fk_Id_Municipio_CatDep` = _Nuevo_Id_Municipio
          AND `Id_CatDep` <> _Id_CatDep
        LIMIT 1;

        SELECT 'Error de Concurrencia: Otro usuario guardó datos idénticos mientras usted editaba.' AS Mensaje,
               'CONFLICTO' AS Accion,
               'TRIADA_IDENTIDAD' AS Campo,
               v_Id_Conflicto AS Id_Conflicto;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7: CONFIRMACIÓN EXITOSA
       ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 'Departamento actualizado correctamente.' AS Mensaje,
           'ACTUALIZADA' AS Accion,
           _Id_CatDep AS Id_Departamento,
           _Nuevo_Id_Municipio AS Id_Municipio_Nuevo,
           v_Mun_Act AS Id_Municipio_Anterior;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarCentroTrabajo
   ============================================================================================
   
   OBJETIVO DE NEGOCIO
   -------------------
   Modificar la información de un Centro de Trabajo (CT), permitiendo cambios en su identidad
   (Código, Nombre) y, crucialmente, su REUBICACIÓN GEOGRÁFICA completa.

   ESCENARIOS DE USO (UX)
   ----------------------
   1. Corrección Simple: Corregir un error ortográfico en el Nombre.
   2. Reingeniería de Claves: Cambiar el Código Administrativo.
   3. Mudanza Local: Cambiar de Municipio dentro del mismo Estado.
   4. Mudanza Internacional/Nacional: Cambiar de País o Estado.
      - El usuario selecciona: País (ej: USA) -> Estado (ej: Texas) -> Municipio (ej: Houston).
      - El sistema debe validar que esa cadena jerárquica sea válida y activa.

   ARQUITECTURA DE SEGURIDAD Y CONCURRENCIA
   ----------------------------------------
   1. BLOQUEO PESIMISTA (Pessimistic Locking):
      - `SELECT ... FOR UPDATE` sobre el CT a editar.
      - "Congela" la fila para evitar que otro admin la borre o edite simultáneamente.

   2. VALIDACIÓN ATÓMICA DE JERARQUÍA GEOGRÁFICA:
      - Aunque solo guardamos `Id_Municipio`, recibimos `Id_Pais` e `Id_Estado`.
      - Hacemos un JOIN validador para asegurar que:
        a) El Municipio pertenece a ese Estado.
        b) El Estado pertenece a ese País.
        c) Los tres niveles están ACTIVOS (1).
      - Esto protege contra inyecciones de datos incoherentes desde el frontend.

   3. INTEGRIDAD DE DUPLICADOS (Excluyendo al propio registro):
      - Verificamos unicidad Global del Código.
      - Verificamos unicidad Local (Nombre + Municipio).
      - Siempre agregamos `AND Id_CatCT <> _Id_CatCT` para no chocar con nosotros mismos.

   4. MANEJO DE COLISIONES (Error 1062 - Race Condition):
      - Si dos usuarios intentan asignar el mismo Código al mismo tiempo:
        * Usuario A gana.
        * Usuario B choca en el UPDATE (Error 1062).
        * El SP captura el error y devuelve una respuesta controlada ("CONFLICTO") indicando
          qué campo causó el problema y quién ganó.

   5. DETECCIÓN DE "SIN CAMBIOS" (Idempotencia):
      - Si los datos nuevos son idénticos a los actuales, retornamos éxito inmediato sin
        tocar la base de datos (ahorro de I/O y Logs).

   RESULTADO
   ---------
   Retorna tabla con:
     - Mensaje: Feedback para usuario.
     - Accion: 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
     - Datos de contexto (IDs anteriores y nuevos).
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarCentroTrabajo`$$
CREATE PROCEDURE `SP_EditarCentroTrabajo`(
    IN _Id_CatCT             INT,           -- ID del registro a editar (PK)
    IN _Nuevo_Codigo         VARCHAR(50),   -- Nuevo Código
    IN _Nuevo_Nombre         VARCHAR(255),  -- Nuevo Nombre
    IN _Nueva_Direccion      VARCHAR(255),  -- Nueva Dirección Física
    IN _Nuevo_Id_Pais        INT,           -- Nuevo País (Contexto para validación)
    IN _Nuevo_Id_Estado      INT,           -- Nuevo Estado (Contexto para validación)
    IN _Nuevo_Id_Municipio   INT            -- Nuevo Municipio (Dato real a guardar)
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0) VARIABLES DE ESTADO
       ======================================================================================== */
    /* Snapshot de los datos actuales (para comparar "Sin Cambios") */
    DECLARE v_Codigo_Act    VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre_Act    VARCHAR(255) DEFAULT NULL;
    DECLARE v_Dir_Act       VARCHAR(255) DEFAULT NULL;
    DECLARE v_Mun_Act       INT          DEFAULT NULL;

    /* Variables auxiliares de validación */
    DECLARE v_Existe        INT          DEFAULT NULL;
    DECLARE v_DupId         INT          DEFAULT NULL;

    /* Bandera para detectar choque 1062 en UPDATE */
    DECLARE v_Dup           TINYINT(1)   DEFAULT 0;

    /* Datos para respuesta de conflicto controlado */
    DECLARE v_Id_Conflicto    INT          DEFAULT NULL;
    DECLARE v_Campo_Conflicto VARCHAR(20)  DEFAULT NULL;

    /* ========================================================================================
       PARTE 1) HANDLERS (CONTROL DE ERRORES)
       ======================================================================================== */
    
    /* 1062 (Duplicate entry):
       No abortamos. Marcamos bandera para manejarlo al final y dar feedback útil. */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* SQLEXCEPTION:
       Cualquier otro error técnico (conexión, sintaxis, disco) provoca Rollback total. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ========================================================================================
       PARTE 2) NORMALIZACIÓN DE INPUTS
       ======================================================================================== */
    SET _Nuevo_Codigo    = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre    = NULLIF(TRIM(_Nuevo_Nombre), '');
    SET _Nueva_Direccion = NULLIF(TRIM(_Nueva_Direccion), '');

    /* Protección contra IDs inválidos */
    IF _Nuevo_Id_Pais <= 0      THEN SET _Nuevo_Id_Pais = NULL;      END IF;
    IF _Nuevo_Id_Estado <= 0    THEN SET _Nuevo_Id_Estado = NULL;    END IF;
    IF _Nuevo_Id_Municipio <= 0 THEN SET _Nuevo_Id_Municipio = NULL; END IF;

    /* ========================================================================================
       PARTE 3) VALIDACIONES BÁSICAS (FAIL FAST)
       ======================================================================================== */
    IF _Id_CatCT IS NULL OR _Id_CatCT <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: ID de Centro de Trabajo inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL OR _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: Código y Nombre son obligatorios.';
    END IF;

    /* Validación estricta de la cadena geográfica */
    IF _Nuevo_Id_Pais IS NULL OR _Nuevo_Id_Estado IS NULL OR _Nuevo_Id_Municipio IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: Debe seleccionar la ubicación completa (País, Estado y Municipio).';
    END IF;

    /* ========================================================================================
       PARTE 4) INICIO DE TRANSACCIÓN
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1: LEER Y BLOQUEAR EL REGISTRO ACTUAL
       ----------------------------------------------------------------------------------------
       - FOR UPDATE: Bloqueamos la fila del CT. Nadie más puede editarla.
       - Obtenemos los valores actuales para detectar si hubo cambios reales.
       ---------------------------------------------------------------------------------------- */
    SET v_Codigo_Act = NULL, v_Nombre_Act = NULL, v_Dir_Act = NULL, v_Mun_Act = NULL;

    SELECT `Codigo`, `Nombre`, `Direccion_Fisica`, `Fk_Id_Municipio_CatCT`
      INTO v_Codigo_Act, v_Nombre_Act, v_Dir_Act, v_Mun_Act
    FROM `Cat_Centros_Trabajo`
    WHERE `Id_CatCT` = _Id_CatCT
    LIMIT 1
    FOR UPDATE;

    IF v_Codigo_Act IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE CONCURRENCIA: El Centro de Trabajo no existe (pudo ser eliminado por otro usuario).';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2: VALIDACIÓN ATÓMICA DE JERARQUÍA GEOGRÁFICA (JOIN ÚNICO)
       ----------------------------------------------------------------------------------------
       - Objetivo: Asegurar que el Municipio seleccionado pertenezca al Estado seleccionado, 
         y este al País seleccionado. Y que TODOS estén ACTIVOS.
       - Bloqueo: Bloqueamos la fila del Municipio destino (`FOR UPDATE`) para evitar que se 
         desactive mientras guardamos.
       - Optimización: Usamos `STRAIGHT_JOIN` para forzar el orden de validación (País->Edo->Mun).
       ---------------------------------------------------------------------------------------- */
    SET v_Existe = NULL;

    SELECT 1 INTO v_Existe
    FROM `Pais` P
    STRAIGHT_JOIN `Estado` E ON E.`Fk_Id_Pais` = P.`Id_Pais`
    STRAIGHT_JOIN `Municipio` M ON M.`Fk_Id_Estado` = E.`Id_Estado`
    WHERE P.`Id_Pais` = _Nuevo_Id_Pais       AND P.`Activo` = 1
      AND E.`Id_Estado` = _Nuevo_Id_Estado   AND E.`Activo` = 1
      AND M.`Id_Municipio` = _Nuevo_Id_Municipio AND M.`Activo` = 1
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD: La ubicación seleccionada es inconsistente (Municipio no pertenece al Estado/País) o contiene elementos inactivos.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3: DETECCIÓN DE "SIN CAMBIOS"
       ----------------------------------------------------------------------------------------
       - Comparamos valores actuales vs nuevos.
       - Usamos `<=>` (Spaceship operator) para comparar NULLs en Dirección Física y Municipio.
       - Si todo es igual, salimos rápido.
       ---------------------------------------------------------------------------------------- */
    IF v_Codigo_Act = _Nuevo_Codigo 
       AND v_Nombre_Act = _Nuevo_Nombre 
       AND (v_Dir_Act <=> _Nueva_Direccion)
       AND (v_Mun_Act <=> _Nuevo_Id_Municipio) THEN
       
       COMMIT; -- Liberamos locks
       SELECT 'No se detectaron cambios en la información.' AS Mensaje, 
              'SIN_CAMBIOS' AS Accion, 
              _Id_CatCT AS Id_CatCT;
       LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4: PRE-CHECK DE DUPLICADOS (INTEGRIDAD REFERENCIAL)
       ---------------------------------------------------------------------------------------- */
    
    /* 4.1 Conflicto Global de CÓDIGO */
    SET v_DupId = NULL;
    
    SELECT `Id_CatCT` INTO v_DupId
    FROM `Cat_Centros_Trabajo`
    WHERE `Codigo` = _Nuevo_Codigo
      AND `Id_CatCT` <> _Id_CatCT -- Importante: Excluirme a mí mismo
    LIMIT 1
    FOR UPDATE; -- Bloqueamos al posible conflictivo

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: El Código ingresado ya está en uso por OTRO Centro de Trabajo.';
    END IF;

    /* 4.2 Conflicto Local de NOMBRE + MUNICIPIO */
    SET v_DupId = NULL;

    SELECT `Id_CatCT` INTO v_DupId
    FROM `Cat_Centros_Trabajo`
    WHERE `Nombre` = _Nuevo_Nombre
      AND `Fk_Id_Municipio_CatCT` = _Nuevo_Id_Municipio
      AND `Id_CatCT` <> _Id_CatCT -- Importante: Excluirme a mí mismo
    LIMIT 1
    FOR UPDATE; -- Bloqueamos al posible conflictivo

    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: Ya existe OTRO Centro de Trabajo con el mismo Nombre en el Municipio seleccionado.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5: EJECUCIÓN DEL UPDATE (CRÍTICO)
       ----------------------------------------------------------------------------------------
       - Aquí es donde podría ocurrir el Error 1062 si hay una "Race Condition" perfecta.
       - Reseteamos v_Dup a 0 antes del intento.
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    UPDATE `Cat_Centros_Trabajo`
    SET `Codigo` = _Nuevo_Codigo,
        `Nombre` = _Nuevo_Nombre,
        `Direccion_Fisica` = _Nueva_Direccion,
        `Fk_Id_Municipio_CatCT` = _Nuevo_Id_Municipio
        -- updated_at se actualiza solo
    WHERE `Id_CatCT` = _Id_CatCT;

    /* ----------------------------------------------------------------------------------------
       PASO 6: MANEJO DE COLISIÓN (SI HUBO ERROR 1062)
       ----------------------------------------------------------------------------------------
       - Si v_Dup = 1, el Handler se disparó.
       - Hacemos ROLLBACK.
       - Identificamos la causa (Código o Nombre) para decirselo al usuario.
       ---------------------------------------------------------------------------------------- */
    IF v_Dup = 1 THEN
        ROLLBACK;

        SET v_Id_Conflicto = NULL;
        SET v_Campo_Conflicto = NULL;

        /* 6.1 Revisar si fue por CÓDIGO */
        SELECT `Id_CatCT` INTO v_Id_Conflicto
        FROM `Cat_Centros_Trabajo`
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatCT` <> _Id_CatCT
        LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
            SET v_Campo_Conflicto = 'CODIGO';
        ELSE
            /* 6.2 Si no fue código, fue por NOMBRE+MUNICIPIO */
            SELECT `Id_CatCT` INTO v_Id_Conflicto
            FROM `Cat_Centros_Trabajo`
            WHERE `Nombre` = _Nuevo_Nombre 
              AND `Fk_Id_Municipio_CatCT` = _Nuevo_Id_Municipio
              AND `Id_CatCT` <> _Id_CatCT
            LIMIT 1;
            
            IF v_Id_Conflicto IS NOT NULL THEN
                SET v_Campo_Conflicto = 'NOMBRE_UBICACION';
            END IF;
        END IF;

        SELECT 'Error de Concurrencia: Otro usuario guardó un registro idéntico mientras usted editaba.' AS Mensaje,
               'CONFLICTO' AS Accion,
               v_Campo_Conflicto AS Campo,
               v_Id_Conflicto AS Id_Conflicto;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7: CONFIRMACIÓN EXITOSA
       ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 'Centro de Trabajo actualizado correctamente' AS Mensaje,
           'ACTUALIZADA' AS Accion,
           _Id_CatCT AS Id_CatCT,
			v_Mun_Act AS Id_Municipio_Anterior,
            _Nuevo_Id_Municipio AS Id_Municipio_Nuevo;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarSede
   ============================================================================================
   OBJETIVO DE NEGOCIO
   -------------------
   Modificar la información integral de una Sede (CASES), permitiendo actualizar:
     - Identidad Administrativa (Código y Nombre).
     - Ubicación Geográfica (Mudanza de Municipio/Estado).
     - Capacidad Instalada (Actualización de inventario de Aulas, Botes, etc.).

   ARQUITECTURA DE INTEGRIDAD Y CONCURRENCIA
   -----------------------------------------
   1. BLOQUEO PESIMISTA (Pessimistic Locking):
      - Ejecutamos `SELECT ... FOR UPDATE` sobre el registro de la Sede al inicio de la transacción.
      - Esto "congela" la fila, impidiendo que otro administrador la elimine o edite 
        mientras nosotros validamos los nuevos datos.

   2. VALIDACIÓN GEOGRÁFICA ATÓMICA:
      - Aunque la Sede solo guarda `Fk_Id_Municipio`, el frontend envía la cadena completa:
        `Id_Pais`, `Id_Estado` e `Id_Municipio`.
      - Realizamos un `STRAIGHT_JOIN` de validación para asegurar que:
        a) El Municipio pertenece al Estado.
        b) El Estado pertenece al País.
        c) Los tres niveles están ACTIVOS (1).
      - Bloqueamos el Municipio destino para evitar que se desactive durante el guardado.

   3. INTEGRIDAD DE DUPLICADOS (Exclusión del Propio ID):
      - Verificamos unicidad Global del Código (`Uk_Codigo`).
      - Verificamos unicidad Global del Nombre (`Uk_Nombre`).
      - CRUCIAL: Siempre agregamos `AND Id_CatCases_Sedes <> _Id_Sede` en los checks.
        (Es legal que yo me llame igual a mí mismo, pero ilegal que me llame como mi vecino).

   4. MANEJO DE INVENTARIO (SANITIZACIÓN):
      - Si el usuario borra un input numérico en el frontend (envía NULL), 
        el SP lo convierte a `0` automáticamente antes de comparar o guardar.
      - Esto mantiene la integridad aritmética de la base de datos.

   5. DETECCIÓN DE "SIN CAMBIOS" (Idempotencia):
      - Comparamos TODOS los campos (Identidad + Ubicación + Inventario).
      - Si todo es idéntico, retornamos éxito inmediato sin tocar el disco duro (ahorro de I/O).

   6. MANEJO DE "RACE CONDITIONS" (Error 1062):
      - Si a pesar de los chequeos, otro usuario inserta un duplicado en el último milisegundo,
        el UPDATE fallará con error 1062.
      - Capturamos ese error y devolvemos una respuesta controlada ("CONFLICTO").

   RESULTADO
   ---------
   Retorna tabla con:
     - Mensaje: Feedback para usuario.
     - Accion: 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
     - Datos de contexto para refrescar la UI.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarSede`$$
CREATE PROCEDURE `SP_EditarSede`(
    /* Identidad */
    IN _Id_Sede              INT,           -- ID del registro a editar
    IN _Nuevo_Codigo         VARCHAR(50),
    IN _Nuevo_Nombre         VARCHAR(255),
    IN _Nueva_Dir_Fisica     VARCHAR(255),  -- Puede ser NULL
    
    /* Ubicación (Para validación jerárquica) */
    IN _Nuevo_Id_Pais        INT, 
    IN _Nuevo_Id_Estado      INT, 
    IN _Nuevo_Id_Municipio   INT,           -- El dato real (FK)
    
    /* Infraestructura (Inventario - Si es NULL se asume 0) */
    IN _Cap_Total            INT,
    IN _Aulas                TINYINT,
    IN _Salas                TINYINT,
    IN _Alberca              TINYINT,
    IN _CampoPracticas       TINYINT,
    IN _Muelle               TINYINT,
    IN _BotesCap             TINYINT
)
SP: BEGIN
    /* ========================================================================================
       PARTE 0: VARIABLES DE ESTADO (SNAPSHOTS)
       ======================================================================================== */
    /* Variables para guardar la "foto" de cómo está el registro AHORA */
    DECLARE v_Cod_Act       VARCHAR(50);
    DECLARE v_Nom_Act       VARCHAR(255);
    DECLARE v_Dir_Act       VARCHAR(255);
    DECLARE v_Mun_Act       INT;
    
    /* Variables de Inventario Actual */
    DECLARE v_Cap_Act       INT;
    DECLARE v_Aulas_Act     TINYINT;
    DECLARE v_Salas_Act     TINYINT;
    DECLARE v_Alb_Act       TINYINT;
    DECLARE v_Camp_Act      TINYINT;
    DECLARE v_Muelle_Act    TINYINT;
    DECLARE v_Botes_Act     TINYINT;

    /* Variables de Control */
    DECLARE v_Existe        INT DEFAULT NULL;
    DECLARE v_DupId         INT DEFAULT NULL;
    DECLARE v_Dup           TINYINT(1) DEFAULT 0; -- Bandera 1062
    
    /* Para reporte de conflictos */
    DECLARE v_Id_Conflicto  INT DEFAULT NULL;
    DECLARE v_Campo_Error   VARCHAR(50) DEFAULT NULL;

    /* ========================================================================================
       PARTE 1: HANDLERS (CONTROL DE ERRORES)
       ======================================================================================== */
    
    /* 1062: Duplicate entry. No abortamos, marcamos bandera para manejarlo al final. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;
    
    /* SQLEXCEPTION: Fallo técnico grave. Abortamos todo. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN ROLLBACK; RESIGNAL; END;

    /* ========================================================================================
       PARTE 2: NORMALIZACIÓN Y SANITIZACIÓN
       ======================================================================================== */
    /* 2.1 Strings */
    SET _Nuevo_Codigo     = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre     = NULLIF(TRIM(_Nuevo_Nombre), '');
    SET _Nueva_Dir_Fisica = NULLIF(TRIM(_Nueva_Dir_Fisica), '');
    
    /* 2.2 IDs Geográficos (0 o negativos -> NULL) */
    IF _Nuevo_Id_Pais <= 0      THEN SET _Nuevo_Id_Pais = NULL;      END IF;
    IF _Nuevo_Id_Estado <= 0    THEN SET _Nuevo_Id_Estado = NULL;    END IF;
    IF _Nuevo_Id_Municipio <= 0 THEN SET _Nuevo_Id_Municipio = NULL; END IF;
    
    /* 2.3 Inventario (NULL -> 0) */
    /* Esta conversión es vital para poder comparar contra la BD (que tiene DEFAULT 0) */
    SET _Cap_Total      = IFNULL(_Cap_Total, 0);
    SET _Aulas          = IFNULL(_Aulas, 0);
    SET _Salas          = IFNULL(_Salas, 0);
    SET _Alberca        = IFNULL(_Alberca, 0);
    SET _CampoPracticas = IFNULL(_CampoPracticas, 0);
    SET _Muelle         = IFNULL(_Muelle, 0);
    SET _BotesCap       = IFNULL(_BotesCap, 0);

    /* ========================================================================================
       PARTE 3: VALIDACIONES BÁSICAS (FAIL FAST)
       ======================================================================================== */
    IF _Id_Sede IS NULL OR _Id_Sede <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: ID de Sede inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El CÓDIGO es obligatorio.';
    END IF;

    IF _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El NOMBRE es obligatorio.';
    END IF;

    IF _Nuevo_Id_Pais IS NULL OR _Nuevo_Id_Estado IS NULL OR _Nuevo_Id_Municipio IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: La ubicación geográfica está incompleta.';
    END IF;

    /* ========================================================================================
       PARTE 4: INICIO DE TRANSACCIÓN
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1: LEER Y BLOQUEAR EL REGISTRO ACTUAL
       ----------------------------------------------------------------------------------------
       - `FOR UPDATE`: Bloqueamos la Sede para asegurar exclusividad en la edición.
       - Leemos TODOS los campos (incluyendo inventario) para la comparación "Sin Cambios". */
    
    SELECT 
        Codigo, Nombre, DescripcionDireccion, Fk_Id_Municipio,
        Capacidad_Total, Aulas, Salas, Alberca, CampoPracticas_Escenario, Muelle_Entrenamiento_Botes, BoteSalvavida_Capacidad
    INTO 
        v_Cod_Act, v_Nom_Act, v_Dir_Act, v_Mun_Act,
        v_Cap_Act, v_Aulas_Act, v_Salas_Act, v_Alb_Act, v_Camp_Act, v_Muelle_Act, v_Botes_Act
    FROM `Cat_Cases_Sedes`
    WHERE `Id_CatCases_Sedes` = _Id_Sede
    LIMIT 1
    FOR UPDATE;

    IF v_Cod_Act IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE CONCURRENCIA: La Sede que intenta editar ya no existe (fue eliminada por otro usuario).';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2: VALIDACIÓN GEOGRÁFICA ATÓMICA
       ----------------------------------------------------------------------------------------
       - Verificamos que País -> Estado -> Municipio sea una cadena válida.
       - Bloqueamos el Municipio destino para que no se desactive mientras guardamos. */
    
    SET v_Existe = NULL;
    
    SELECT 1 INTO v_Existe
    FROM `Pais` P
    STRAIGHT_JOIN `Estado` E ON E.Fk_Id_Pais = P.Id_Pais
    STRAIGHT_JOIN `Municipio` M ON M.Fk_Id_Estado = E.Id_Estado
    WHERE P.Id_Pais = _Nuevo_Id_Pais       AND P.Activo = 1
      AND E.Id_Estado = _Nuevo_Id_Estado   AND E.Activo = 1
      AND M.Id_Municipio = _Nuevo_Id_Municipio AND M.Activo = 1
    LIMIT 1 
    FOR UPDATE; -- Bloqueo del municipio destino

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD: La ubicación seleccionada es incoherente o contiene elementos inactivos.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3: DETECCIÓN DE "SIN CAMBIOS" (OPTIMIZACIÓN)
       ----------------------------------------------------------------------------------------
       - Comparamos valores actuales vs nuevos.
       - Usamos `<=>` para campos nulables (Dirección).
       - Comparamos todos los números del inventario. */
       
    IF v_Cod_Act = _Nuevo_Codigo 
       AND v_Nom_Act = _Nuevo_Nombre 
       AND (v_Dir_Act <=> _Nueva_Dir_Fisica) 
       AND v_Mun_Act = _Nuevo_Id_Municipio
       /* Comparación de Inventario */
       AND v_Cap_Act = _Cap_Total 
       AND v_Aulas_Act = _Aulas 
       AND v_Salas_Act = _Salas
       AND v_Alb_Act = _Alberca 
       AND v_Camp_Act = _CampoPracticas 
       AND v_Muelle_Act = _Muelle 
       AND v_Botes_Act = _BotesCap THEN
       
       COMMIT; -- Liberar locks
       SELECT 'No se detectaron cambios en la información.' AS Mensaje, 
              'SIN_CAMBIOS' AS Accion, 
              _Id_Sede AS Id_Sede;
       LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4: PRE-CHECK DE DUPLICADOS (Excluyendo al propio ID)
       ---------------------------------------------------------------------------------------- */
    
    /* 4.1. Conflicto Global de CÓDIGO */
    SET v_DupId = NULL;
    
    SELECT `Id_CatCases_Sedes` INTO v_DupId FROM `Cat_Cases_Sedes`
    WHERE `Codigo` = _Nuevo_Codigo 
      AND `Id_CatCases_Sedes` <> _Id_Sede -- Excluirme a mí mismo
    LIMIT 1 FOR UPDATE;
    
    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: El CÓDIGO ingresado ya pertenece a otra Sede.';
    END IF;

    /* 4.2. Conflicto Global de NOMBRE */
    SET v_DupId = NULL;
    
    SELECT `Id_CatCases_Sedes` INTO v_DupId FROM `Cat_Cases_Sedes`
    WHERE `Nombre` = _Nuevo_Nombre 
      AND `Id_CatCases_Sedes` <> _Id_Sede -- Excluirme a mí mismo
    LIMIT 1 FOR UPDATE;
    
    IF v_DupId IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: El NOMBRE ingresado ya pertenece a otra Sede.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5: EJECUCIÓN DEL UPDATE (CRÍTICO)
       ----------------------------------------------------------------------------------------
       - Reseteamos v_Dup a 0.
       - Actualizamos Identidad, Ubicación e Inventario. */
       
    SET v_Dup = 0;

    UPDATE `Cat_Cases_Sedes`
    SET `Codigo`               = _Nuevo_Codigo,
        `Nombre`               = _Nuevo_Nombre,
        `DescripcionDireccion` = _Nueva_Dir_Fisica,
        `Fk_Id_Municipio`      = _Nuevo_Id_Municipio,
        /* Actualización de Infraestructura */
        `Capacidad_Total`            = _Cap_Total,
        `Aulas`                      = _Aulas,
        `Salas`                      = _Salas,
        `Alberca`                    = _Alberca,
        `CampoPracticas_Escenario`   = _CampoPracticas,
        `Muelle_Entrenamiento_Botes` = _Muelle,
        `BoteSalvavida_Capacidad`    = _BotesCap,
        `updated_at`                 = NOW()
    WHERE `Id_CatCases_Sedes` = _Id_Sede;

    /* ----------------------------------------------------------------------------------------
       PASO 6: MANEJO DE CONCURRENCIA (SI HUBO ERROR 1062)
       ----------------------------------------------------------------------------------------
       - Si v_Dup = 1, el Handler saltó. Hacemos Rollback y diagnosticamos. */
       
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        SET v_Id_Conflicto = NULL;
        
        /* Diagnóstico: ¿Fue el Código? */
        SELECT `Id_CatCases_Sedes` INTO v_Id_Conflicto FROM `Cat_Cases_Sedes`
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatCases_Sedes` <> _Id_Sede LIMIT 1;
        
        IF v_Id_Conflicto IS NOT NULL THEN 
            SET v_Campo_Error = 'CODIGO';
        ELSE 
            /* Si no fue código, fue el Nombre */
            SET v_Campo_Error = 'NOMBRE';
            SELECT `Id_CatCases_Sedes` INTO v_Id_Conflicto FROM `Cat_Cases_Sedes`
            WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatCases_Sedes` <> _Id_Sede LIMIT 1;
        END IF;

        SELECT 'Error de Concurrencia: Conflicto detectado al guardar.' AS Mensaje,
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo, 
               v_Id_Conflicto AS Id_Conflicto;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 7: CONFIRMACIÓN EXITOSA
       ---------------------------------------------------------------------------------------- */
    COMMIT;
    
    SELECT 'Sede actualizada correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Sede AS Id_Sede, 
           _Nuevo_Id_Municipio AS Id_Municipio_Nuevo;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarRegimen
   ============================================================================================
   1. OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------
   Modificar los atributos fundamentales de un "Régimen de Contratación" existente, asegurando
   la persistencia de datos íntegros y válidos.
   
   Este procedimiento impone reglas de negocio más estrictas que la propia estructura de la tabla:
   aunque la base de datos permita nulos, la lógica de negocio para la EDICIÓN exige que el
   Código y el Nombre siempre tengan valor.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ---------------------------------------------------
   A) OBLIGATORIEDAD DE CAMPOS:
      - Regla: "Todo o Nada". No se permite guardar cambios si el Código o el Nombre están vacíos.
      - Justificación: En la operación diaria, un Régimen sin código puede causar errores en 
        interfaces con sistemas legados (nómina). Por tanto, al editar, se fuerza la captura.

   B) UNICIDAD GLOBAL (EXCLUSIÓN PROPIA):
      - Se verifica que el nuevo Código no pertenezca a OTRO registro (`Id <> _Id_Regimen`).
      - Se verifica que el nuevo Nombre no pertenezca a OTRO registro.
      - Es perfectamente legal "actualizarse a sí mismo" (ej: cambiar solo la descripción).

   3. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   ---------------------------------------------------------------
   Para prevenir **Deadlocks** (Abrazos Mortales) en un entorno donde múltiples administradores
   podrían estar intercambiando nombres o códigos entre registros simultáneamente, se implementa
   una estrategia de BLOQUEO DETERMINÍSTICO:

   - Paso 1: Identificación. Antes de bloquear nada, identificamos qué filas están involucradas:
       a) La fila que queremos editar (Target).
       b) La fila que (posiblemente) ya tiene el Código que queremos usar (Conflicto A).
       c) La fila que (posiblemente) ya tiene el Nombre que queremos usar (Conflicto B).
   
   - Paso 2: Ordenamiento. Ordenamos estos IDs de menor a mayor.
   
   - Paso 3: Ejecución de Bloqueos. Aplicamos `FOR UPDATE` siguiendo estrictamente ese orden.
     Al adquirir los recursos siempre en la misma secuencia (Ascendente), eliminamos matemáticamente
     la posibilidad de un ciclo de espera (Deadlock).

   4. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   ------------------------------------------
   - Antes de escribir en disco, el SP compara el estado actual (`Snapshot`) contra los nuevos valores.
   - Si son idénticos, retorna éxito ('SIN_CAMBIOS') inmediatamente. Esto evita escrituras innecesarias
     en el Log de Transacciones y mantiene intacta la fecha `updated_at`.

   RESULTADO (OUTPUT CONTRACT)
   ---------------------------
   Retorna un dataset con:
     - Mensaje: Feedback descriptivo.
     - Accion: 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
     - Id_Regimen: Identificador del recurso manipulado.
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarRegimen`$$
CREATE PROCEDURE `SP_EditarRegimen`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Recibimos los datos crudos del formulario.
       ----------------------------------------------------------------- */
    IN _Id_Regimen   INT,           -- OBLIGATORIO: ID del registro a modificar
    IN _Nuevo_Codigo VARCHAR(50),   -- OBLIGATORIO: Nueva Clave (ej: 'CONF')
    IN _Nuevo_Nombre VARCHAR(255),  -- OBLIGATORIO: Nuevo Nombre (ej: 'Confianza')
    IN _Nueva_Desc   VARCHAR(255)   -- OPCIONAL: Descripción detallada
)
SP: BEGIN
    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO
       ======================================================================================== */
    
    /* Snapshots: Almacenan el estado actual del registro antes de la edición */
    DECLARE v_Cod_Act  VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nom_Act  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Desc_Act VARCHAR(255) DEFAULT NULL;

    /* IDs para la Estrategia de Bloqueo Determinístico */
    DECLARE v_Id_Conflicto_Cod INT DEFAULT NULL; -- ID del dueño actual del Código deseado
    DECLARE v_Id_Conflicto_Nom INT DEFAULT NULL; -- ID del dueño actual del Nombre deseado

    /* Variables auxiliares para el algoritmo de ordenamiento de locks */
    DECLARE v_L1 INT DEFAULT NULL;
    DECLARE v_L2 INT DEFAULT NULL;
    DECLARE v_L3 INT DEFAULT NULL;
    DECLARE v_Min INT DEFAULT NULL;
    DECLARE v_Existe INT DEFAULT NULL;

    /* Bandera de Error Crítico (Concurrency Collision) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* Variables para Diagnóstico de Errores */
    DECLARE v_Campo_Error VARCHAR(20) DEFAULT NULL;
    DECLARE v_Id_Error    INT DEFAULT NULL;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (SEGURIDAD Y ROBUSTEZ)
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Captura colisiones de Unique Key en el último milisegundo (Race Condition). */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Captura fallos técnicos (Desconexión, Disco lleno, Sintaxis). Aborta todo. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN (FAIL FAST)
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA DE DATOS
       Eliminamos espacios basura. Si queda vacío, se convierte a NULL. */
    SET _Nuevo_Codigo = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');
    SET _Nueva_Desc   = NULLIF(TRIM(_Nueva_Desc), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (REGLA DE NEGOCIO ESTRICTA)
       El formulario exige que Código y Nombre existan. */
    
    IF _Id_Regimen IS NULL OR _Id_Regimen <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: Identificador de Régimen inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El CÓDIGO es obligatorio para la edición.';
    END IF;

    IF _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El NOMBRE es obligatorio para la edición.';
    END IF;
    
    /* La descripción es opcional, pero si es obligatoria según tu regla "Todo es Obligatorio", descomentar: */
    
    IF _Nueva_Desc IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: La DESCRIPCIÓN es obligatoria.';
    END IF;
    
    /* ========================================================================================
       BLOQUE 3: ESTRATEGIA DE BLOQUEO DETERMINÍSTICO (PREVENCIÓN DE DEADLOCKS)
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RECONOCIMIENTO (LECTURA SUCIA / NO BLOQUEANTE)
       Primero "miramos" el panorama para saber qué filas están involucradas.
       ---------------------------------------------------------------------------------------- */
    
    /* A) Identificar el registro objetivo */
    SELECT `Codigo`, `Nombre` INTO v_Cod_Act, v_Nom_Act
    FROM `Cat_Regimenes_Trabajo` WHERE `Id_CatRegimen` = _Id_Regimen;

    IF v_Cod_Act IS NULL AND v_Nom_Act IS NULL THEN 
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO: El Régimen que intenta editar no existe.';
    END IF;

    /* B) Identificar posible conflicto de CÓDIGO (¿Alguien más ya tiene mi nuevo código?) */
    IF _Nuevo_Codigo <> IFNULL(v_Cod_Act, '') THEN
        SELECT `Id_CatRegimen` INTO v_Id_Conflicto_Cod 
        FROM `Cat_Regimenes_Trabajo` 
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatRegimen` <> _Id_Regimen LIMIT 1;
    END IF;

    /* C) Identificar posible conflicto de NOMBRE (¿Alguien más ya tiene mi nuevo nombre?) */
    IF _Nuevo_Nombre <> v_Nom_Act THEN
        SELECT `Id_CatRegimen` INTO v_Id_Conflicto_Nom 
        FROM `Cat_Regimenes_Trabajo` 
        WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatRegimen` <> _Id_Regimen LIMIT 1;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: EJECUCIÓN DE BLOQUEOS ORDENADOS
       Ordenamos los IDs (Propio, ConflictoCod, ConflictoNom) y bloqueamos de menor a mayor.
       Esto garantiza que todos los procesos adquieran recursos en la misma dirección.
       ---------------------------------------------------------------------------------------- */
    
    /* Llenamos el pool de IDs a bloquear */
    SET v_L1 = _Id_Regimen;
    SET v_L2 = v_Id_Conflicto_Cod;
    SET v_L3 = v_Id_Conflicto_Nom;

    /* Normalización: Eliminar duplicados en las variables (ej: si conflicto Cod y Nom son el mismo ID) */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* --- RONDA 1: Bloquear el ID Menor --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Regimenes_Trabajo` WHERE `Id_CatRegimen` = v_Min FOR UPDATE;
        /* Marcar como procesado */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 2: Bloquear el Siguiente ID --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Regimenes_Trabajo` WHERE `Id_CatRegimen` = v_Min FOR UPDATE;
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 3: Bloquear el ID Mayor --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Regimenes_Trabajo` WHERE `Id_CatRegimen` = v_Min FOR UPDATE;
    END IF;

    /* ========================================================================================
       BLOQUE 4: LÓGICA DE NEGOCIO (BAJO PROTECCIÓN DE LOCKS)
       ======================================================================================== */

    /* 4.1 RE-LECTURA AUTORIZADA
       Ahora que tenemos el bloqueo, leemos el estado definitivo. */
    SELECT `Codigo`, `Nombre`, `Descripcion` 
    INTO v_Cod_Act, v_Nom_Act, v_Desc_Act
    FROM `Cat_Regimenes_Trabajo` 
    WHERE `Id_CatRegimen` = _Id_Regimen; 

    IF v_Nom_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO: El registro desapareció durante la transacción.';
    END IF;

    /* 4.2 DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       Comparamos si los datos nuevos son matemáticamente iguales a los actuales. 
       Usamos <=> (Null-Safe Equality) para manejar correctamente los NULLs. */
    IF (v_Cod_Act <=> _Nuevo_Codigo) 
       AND (v_Nom_Act = _Nuevo_Nombre) 
       AND (v_Desc_Act <=> _Nueva_Desc) THEN
        
        COMMIT;
        SELECT 'No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion;
        LEAVE SP;
    END IF;

    /* 4.3 VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       Verificamos si existen duplicados. Al tener los registros bloqueados, esta verificación
       es 100% fiable (salvo inserciones fantasma, cubiertas por el Handler 1062). */
    
    /* Validación por CÓDIGO */
    SET v_Id_Error = NULL;
    SELECT `Id_CatRegimen` INTO v_Id_Error FROM `Cat_Regimenes_Trabajo` 
    WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatRegimen` <> _Id_Regimen LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: El CÓDIGO ya pertenece a otro Régimen.';
    END IF;

    /* Validación por NOMBRE */
    SET v_Id_Error = NULL;
    SELECT `Id_CatRegimen` INTO v_Id_Error FROM `Cat_Regimenes_Trabajo` 
    WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatRegimen` <> _Id_Regimen LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: El NOMBRE ya pertenece a otro Régimen.';
    END IF;

    /* ========================================================================================
       BLOQUE 5: PERSISTENCIA (UPDATE)
       ======================================================================================== */
    
    SET v_Dup = 0; -- Resetear bandera de error

    UPDATE `Cat_Regimenes_Trabajo`
    SET `Codigo`      = _Nuevo_Codigo,
        `Nombre`      = _Nuevo_Nombre,
        `Descripcion` = _Nueva_Desc,
        `updated_at`  = NOW()
    WHERE `Id_CatRegimen` = _Id_Regimen;

    /* ========================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       ========================================================================================
       Si v_Dup = 1, significa que otro usuario insertó un registro conflictivo en el 
       instante exacto entre nuestro SELECT de validación y el UPDATE. */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico Post-Mortem para el usuario */
        SET v_Campo_Error = 'DESCONOCIDO';
        SET v_Id_Error = NULL;

        /* ¿Fue conflicto de Código? */
        SELECT `Id_CatRegimen` INTO v_Id_Error FROM `Cat_Regimenes_Trabajo` 
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatRegimen` <> _Id_Regimen LIMIT 1;
        
        IF v_Id_Error IS NOT NULL THEN
            SET v_Campo_Error = 'CODIGO';
        ELSE
            /* Entonces fue conflicto de Nombre */
            SELECT `Id_CatRegimen` INTO v_Id_Error FROM `Cat_Regimenes_Trabajo` 
            WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatRegimen` <> _Id_Regimen LIMIT 1;
            SET v_Campo_Error = 'NOMBRE';
        END IF;

        SELECT 'Error de Concurrencia: Conflicto detectado al guardar (Otro usuario ganó).' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo, 
               v_Id_Error AS Id_Conflicto;
        LEAVE SP;
    END IF;

    /* ========================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       ======================================================================================== */
    COMMIT;
    
    SELECT 'Régimen actualizado correctamente.' AS Mensaje, 'ACTUALIZADA' AS Accion;

END$$

DELIMITER ;

/* ============================================================================================
   PROCEDIMIENTO: SP_EditarRegion
   ============================================================================================
   1. OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------
   Modificar los datos fundamentales de una "Región Operativa" existente en el catálogo.
   
   Este procedimiento no es un simple UPDATE; es un motor transaccional diseñado para operar
   en entornos de alta concurrencia, garantizando que:
     - No se generen duplicados (por Código o Nombre).
     - No se sobrescriban datos si no hubo cambios reales (Idempotencia).
     - No ocurran bloqueos mutuos (Deadlocks) entre usuarios.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ---------------------------------------------------
   A) OBLIGATORIEDAD DE CAMPOS:
      - Regla: "Todo o Nada". No se permite guardar cambios si el Código, el Nombre o la 
        Descripción son nulos o cadenas vacías.
      - Justificación: Mantener la calidad de los datos maestros para reportes ejecutivos.

   B) UNICIDAD GLOBAL (EXCLUSIÓN PROPIA):
      - Se verifica que el nuevo Código no pertenezca a OTRA región (`Id <> _Id_Region`).
      - Se verifica que el nuevo Nombre no pertenezca a OTRA región.
      - Nota: Es perfectamente legal que el registro choque consigo mismo (ej: cambiar solo la descripción
        manteniendo el mismo código).

   3. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   ---------------------------------------------------------------
   Para prevenir **Deadlocks** (Abrazos Mortales), implementamos una estrategia de BLOQUEO DETERMINÍSTICO.
   
   El Problema:
     - Usuario A quiere cambiar Región 1 -> Código 'B'.
     - Usuario B quiere cambiar Región 2 -> Código 'A'.
     - Si A bloquea 1 y luego intenta bloquear 2, mientras B bloquea 2 y luego intenta bloquear 1,
       el motor de base de datos mata uno de los procesos.

   La Solución (El Algoritmo):
     1. Identificación: Detectamos todos los IDs involucrados (El que edito + El que tiene mi código deseado + El que tiene mi nombre deseado).
     2. Ordenamiento: Ordenamos esos IDs de MENOR a MAYOR.
     3. Ejecución: Bloqueamos (`FOR UPDATE`) siguiendo estrictamente ese orden.
     
   Resultado: Todos los procesos compiten por los recursos en la misma dirección, eliminando matemáticamente el ciclo de espera.

   4. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   ------------------------------------------
   - Antes de escribir en disco, el SP compara el estado actual (`Snapshot`) contra los nuevos valores.
   - Si son idénticos, retorna éxito ('SIN_CAMBIOS') inmediatamente. Esto evita escrituras innecesarias
     en el Log de Transacciones y mantiene intacta la fecha `updated_at`.

   RESULTADO (OUTPUT CONTRACT)
   ---------------------------
   Retorna un dataset con:
     - Mensaje: Feedback descriptivo.
     - Accion: 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
     - Id_Region: Identificador del recurso manipulado.
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarRegion`$$
CREATE PROCEDURE `SP_EditarRegion`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Recibimos los datos crudos del formulario.
       ----------------------------------------------------------------- */
    IN _Id_Region    INT,           -- OBLIGATORIO: ID del registro a modificar (PK)
    IN _Nuevo_Codigo VARCHAR(50),   -- OBLIGATORIO: Nueva Clave (ej: 'RM-S')
    IN _Nuevo_Nombre VARCHAR(255),  -- OBLIGATORIO: Nuevo Nombre (ej: 'Región Sur')
    IN _Nueva_Desc   VARCHAR(255)   -- OBLIGATORIO: Descripción detallada
)
SP: BEGIN
    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO
       ======================================================================================== */
    
    /* Snapshots: Almacenan el estado actual del registro antes de la edición (para comparar cambios) */
    DECLARE v_Cod_Act  VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nom_Act  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Desc_Act VARCHAR(255) DEFAULT NULL;

    /* IDs para la Estrategia de Bloqueo Determinístico (Candidatos a conflicto) */
    DECLARE v_Id_Conflicto_Cod INT DEFAULT NULL; -- ID del dueño actual del Código deseado (si existe)
    DECLARE v_Id_Conflicto_Nom INT DEFAULT NULL; -- ID del dueño actual del Nombre deseado (si existe)

    /* Variables auxiliares para el algoritmo de ordenamiento de locks */
    DECLARE v_L1 INT DEFAULT NULL;
    DECLARE v_L2 INT DEFAULT NULL;
    DECLARE v_L3 INT DEFAULT NULL;
    DECLARE v_Min INT DEFAULT NULL;
    DECLARE v_Existe INT DEFAULT NULL; -- Auxiliar para validar bloqueos

    /* Bandera de Error Crítico (Concurrency Collision) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* Variables para Diagnóstico de Errores (Post-Mortem) */
    DECLARE v_Campo_Error VARCHAR(20) DEFAULT NULL;
    DECLARE v_Id_Error    INT DEFAULT NULL;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (SEGURIDAD Y ROBUSTEZ)
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Captura colisiones de Unique Key en el último milisegundo (Race Condition). 
       Permite manejar el error controladamente en lugar de abortar. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Captura fallos técnicos graves (Desconexión, Disco lleno, Sintaxis). Aborta todo. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN (FAIL FAST)
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA DE DATOS
       Eliminamos espacios basura. Si queda vacío, se convierte a NULL para activar las validaciones. */
    SET _Nuevo_Codigo = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');
    SET _Nueva_Desc   = NULLIF(TRIM(_Nueva_Desc), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (REGLA DE NEGOCIO ESTRICTA)
       El formulario exige que todos los campos existan. */
    
    IF _Id_Region IS NULL OR _Id_Region <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: Identificador de Región inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El CÓDIGO es obligatorio para la edición.';
    END IF;

    IF _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El NOMBRE es obligatorio para la edición.';
    END IF;
    
    IF _Nueva_Desc IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: La DESCRIPCIÓN es obligatoria para la edición.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: ESTRATEGIA DE BLOQUEO DETERMINÍSTICO (PREVENCIÓN DE DEADLOCKS)
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RECONOCIMIENTO (LECTURA SUCIA / NO BLOQUEANTE)
       Primero "miramos" el panorama para saber qué filas están involucradas sin bloquear nada aún.
       ---------------------------------------------------------------------------------------- */
    
    /* A) Identificar el registro objetivo (Target) */
    SELECT `Codigo`, `Nombre` INTO v_Cod_Act, v_Nom_Act
    FROM `Cat_Regiones_Trabajo` WHERE `Id_CatRegion` = _Id_Region;

    /* Si no encontramos el registro propio, abortamos (pudo ser borrado por otro admin) */
    IF v_Cod_Act IS NULL AND v_Nom_Act IS NULL THEN 
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO: La Región que intenta editar no existe.';
    END IF;

    /* B) Identificar posible conflicto de CÓDIGO (¿Alguien más ya tiene mi nuevo código?)
       Solo buscamos si el código cambió. */
    IF _Nuevo_Codigo <> IFNULL(v_Cod_Act, '') THEN
        SELECT `Id_CatRegion` INTO v_Id_Conflicto_Cod 
        FROM `Cat_Regiones_Trabajo` 
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatRegion` <> _Id_Region LIMIT 1;
    END IF;

    /* C) Identificar posible conflicto de NOMBRE (¿Alguien más ya tiene mi nuevo nombre?)
       Solo buscamos si el nombre cambió. */
    IF _Nuevo_Nombre <> v_Nom_Act THEN
        SELECT `Id_CatRegion` INTO v_Id_Conflicto_Nom 
        FROM `Cat_Regiones_Trabajo` 
        WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatRegion` <> _Id_Region LIMIT 1;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: EJECUCIÓN DE BLOQUEOS ORDENADOS
       Esta es la parte crítica para evitar Deadlocks.
       Ordenamos los IDs (Propio, ConflictoCod, ConflictoNom) y bloqueamos de MENOR a MAYOR.
       Esto garantiza que todos los procesos adquieran recursos en la misma dirección.
       ---------------------------------------------------------------------------------------- */
    
    /* Llenamos el pool de IDs a bloquear */
    SET v_L1 = _Id_Region;
    SET v_L2 = v_Id_Conflicto_Cod;
    SET v_L3 = v_Id_Conflicto_Nom;

    /* Normalización: Eliminar duplicados en las variables (ej: si conflicto Cod y Nom son el mismo ID externo) */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* --- RONDA 1: Bloquear el ID Menor --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Regiones_Trabajo` WHERE `Id_CatRegion` = v_Min FOR UPDATE;
        /* Marcar como procesado (borrar del pool) */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 2: Bloquear el Siguiente ID --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Regiones_Trabajo` WHERE `Id_CatRegion` = v_Min FOR UPDATE;
        /* Marcar como procesado */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 3: Bloquear el ID Mayor (Último) --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Regiones_Trabajo` WHERE `Id_CatRegion` = v_Min FOR UPDATE;
    END IF;

    /* ========================================================================================
       BLOQUE 4: LÓGICA DE NEGOCIO (BAJO PROTECCIÓN DE LOCKS)
       ======================================================================================== */

    /* 4.1 RE-LECTURA AUTORIZADA
       Ahora que tenemos los bloqueos, leemos el estado definitivo de nuestro registro.
       (Podría haber cambiado en los milisegundos previos al bloqueo). */
    SELECT `Codigo`, `Nombre`, `Descripcion` 
    INTO v_Cod_Act, v_Nom_Act, v_Desc_Act
    FROM `Cat_Regiones_Trabajo` 
    WHERE `Id_CatRegion` = _Id_Region; 

    IF v_Nom_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO: El registro desapareció durante la transacción.';
    END IF;

    /* 4.2 DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       Comparamos si los datos nuevos son matemáticamente iguales a los actuales. 
       Usamos `<=>` (Null-Safe Equality) para manejar correctamente los NULLs. */
    IF (v_Cod_Act <=> _Nuevo_Codigo) 
       AND (v_Nom_Act = _Nuevo_Nombre) 
       AND (v_Desc_Act <=> _Nueva_Desc) THEN
        
        COMMIT;
        /* Retorno anticipado para ahorrar I/O */
        SELECT 'No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion, _Id_Region AS Id_Region;
        LEAVE SP;
    END IF;

    /* 4.3 VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       Verificamos si existen duplicados REALES. Al tener los registros conflictivos bloqueados,
       esta verificación es 100% fiable. */
    
    /* Validación por CÓDIGO */
    SET v_Id_Error = NULL;
    SELECT `Id_CatRegion` INTO v_Id_Error FROM `Cat_Regiones_Trabajo` 
    WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatRegion` <> _Id_Region LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: El CÓDIGO ya pertenece a otra Región.';
    END IF;

    /* Validación por NOMBRE */
    SET v_Id_Error = NULL;
    SELECT `Id_CatRegion` INTO v_Id_Error FROM `Cat_Regiones_Trabajo` 
    WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatRegion` <> _Id_Region LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DUPLICIDAD: El NOMBRE ya pertenece a otra Región.';
    END IF;

    /* ========================================================================================
       BLOQUE 5: PERSISTENCIA (UPDATE)
       ======================================================================================== */
    
    SET v_Dup = 0; -- Resetear bandera de error antes de escribir

    UPDATE `Cat_Regiones_Trabajo`
    SET `Codigo`      = _Nuevo_Codigo,
        `Nombre`      = _Nuevo_Nombre,
        `Descripcion` = _Nueva_Desc,
        `updated_at`  = NOW()
    WHERE `Id_CatRegion` = _Id_Region;

    /* ========================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       ========================================================================================
       Si v_Dup = 1, significa que otro usuario insertó un registro conflictivo en el 
       instante exacto entre nuestro SELECT de validación y el UPDATE (Race Condition extrema). */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico Post-Mortem para el usuario */
        SET v_Campo_Error = 'DESCONOCIDO';
        SET v_Id_Error = NULL;

        /* ¿Fue conflicto de Código? */
        SELECT `Id_CatRegion` INTO v_Id_Error FROM `Cat_Regiones_Trabajo` 
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatRegion` <> _Id_Region LIMIT 1;
        
        IF v_Id_Error IS NOT NULL THEN
            SET v_Campo_Error = 'CODIGO';
        ELSE
            /* Entonces fue conflicto de Nombre */
            SELECT `Id_CatRegion` INTO v_Id_Error FROM `Cat_Regiones_Trabajo` 
            WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatRegion` <> _Id_Region LIMIT 1;
            SET v_Campo_Error = 'NOMBRE';
        END IF;

        SELECT 'Error de Concurrencia: Conflicto detectado al guardar (Otro usuario ganó).' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo, 
               v_Id_Error AS Id_Conflicto;
        LEAVE SP;
    END IF;

    /* ========================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       ======================================================================================== */
    COMMIT;
    
    SELECT 'Región actualizada correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Region AS Id_Region;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_EditarPuesto
   ====================================================================================================
   
   1. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento orquesta la modificación de los atributos descriptivos de un "Puesto de Trabajo"
   existente en el catálogo corporativo.
   
   No se trata de un simple `UPDATE`. Es un motor transaccional diseñado para operar en entornos de 
   alta concurrencia (múltiples administradores editando simultáneamente), garantizando las propiedades ACID:
     - Atomicidad: O se aplican todos los cambios, o ninguno.
     - Consistencia: No se permiten duplicados de Código o Nombre.
     - Aislamiento: Uso de bloqueos determinísticos para prevenir abrazos mortales (Deadlocks).
     - Durabilidad: Confirmación explícita (COMMIT) tras validar reglas.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ----------------------------------------------------------------------------------------------------
   A) OBLIGATORIEDAD DE CAMPOS:
      - Regla: "Todo o Nada". No se permite guardar cambios si el Código o el Nombre son cadenas vacías.
      - Justificación: Un puesto sin nombre pierde su valor semántico en los reportes históricos.

   B) UNICIDAD GLOBAL (EXCLUSIÓN PROPIA):
      - Se verifica que el nuevo Código no pertenezca a OTRO puesto (`Id <> _Id_Puesto`).
      - Se verifica que el nuevo Nombre no pertenezca a OTRO puesto.
      - Nota: Es perfectamente legal que el registro choque consigo mismo (ej: cambiar solo la descripción).

   3. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   ----------------------------------------------------------------------------------------------------
   Para prevenir **Deadlocks** (Bloqueos Mutuos) en escenarios de "Intercambio" (Swap Scenario) donde
   el Usuario A quiere renombrar el Puesto 1 como 'X', y el Usuario B quiere renombrar el Puesto 2 
   como 'Y' (cruzados), implementamos una estrategia de BLOQUEO DETERMINÍSTICO:

     - FASE 1 (Identificación): Detectamos todos los IDs involucrados en la transacción (El ID objetivo,
       el ID dueño del código deseado y el ID dueño del nombre deseado).
     - FASE 2 (Ordenamiento): Ordenamos estos IDs numéricamente de MENOR a MAYOR.
     - FASE 3 (Ejecución): Adquirimos los bloqueos (`FOR UPDATE`) siguiendo estrictamente ese orden.
   
   Resultado: Todos los procesos compiten por los recursos en la misma dirección ("fila india"), 
   eliminando matemáticamente la posibilidad de un ciclo de espera.

   4. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   ----------------------------------------------------------------------------------------------------
   - Antes de escribir en disco, el SP compara el estado actual (`Snapshot`) contra los nuevos valores.
   - Si son idénticos, retorna éxito ('SIN_CAMBIOS') inmediatamente.
   - Beneficio: Evita escrituras innecesarias en el Transaction Log y mantiene intacta la fecha `updated_at`.

   5. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset con:
     - Mensaje (VARCHAR): Feedback descriptivo.
     - Accion (VARCHAR): 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
     - Id_Puesto (INT): Identificador del recurso manipulado.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarPuesto`$$

CREATE PROCEDURE `SP_EditarPuesto`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Recibimos los datos crudos del formulario de edición.
       ----------------------------------------------------------------- */
    IN _Id_Puesto    INT,           -- OBLIGATORIO: ID del registro a modificar (PK)
    IN _Nuevo_Codigo VARCHAR(50),   -- OBLIGATORIO: Nueva Clave (ej: 'MED-ESP')
    IN _Nuevo_Nombre VARCHAR(255),  -- OBLIGATORIO: Nuevo Nombre (ej: 'Médico Especialista')
    IN _Nueva_Desc   VARCHAR(255)   -- OPCIONAL: Descripción detallada
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Inicializar los contenedores que gestionarán la lógica del procedimiento.
       ================================================================================================ */
    
    /* [Snapshots]: Almacenan el estado actual del registro antes de la edición (para comparar cambios) */
    DECLARE v_Cod_Act  VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nom_Act  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Desc_Act VARCHAR(255) DEFAULT NULL;

    /* [IDs de Conflicto]: Identificadores de filas que podrían chocar con nuestros nuevos datos */
    DECLARE v_Id_Conflicto_Cod INT DEFAULT NULL; -- ID del dueño actual del Código deseado (si existe)
    DECLARE v_Id_Conflicto_Nom INT DEFAULT NULL; -- ID del dueño actual del Nombre deseado (si existe)

    /* [Variables de Algoritmo de Bloqueo]: Auxiliares para ordenar los locks de Menor a Mayor */
    DECLARE v_L1 INT DEFAULT NULL;
    DECLARE v_L2 INT DEFAULT NULL;
    DECLARE v_L3 INT DEFAULT NULL;
    DECLARE v_Min INT DEFAULT NULL;
    DECLARE v_Existe INT DEFAULT NULL; -- Auxiliar para validar que el lock fue exitoso

    /* [Bandera de Control]: Semáforo para detectar errores de concurrencia (Error 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* [Variables de Diagnóstico]: Para reportar al usuario qué campo causó el error */
    DECLARE v_Campo_Error VARCHAR(20) DEFAULT NULL;
    DECLARE v_Id_Error    INT DEFAULT NULL;

    /* ================================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Garantizar una salida limpia ante errores técnicos o de concurrencia.
       ================================================================================================ */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Objetivo: Capturar colisiones de Unique Key en el último milisegundo (Race Condition).
       Acción: No abortamos. Encendemos la bandera v_Dup = 1 para manejar el conflicto controladamente al final. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos técnicos graves (Desconexión, Disco lleno, Sintaxis).
       Acción: Abortar inmediatamente (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST)
       Propósito: Rechazar datos inválidos antes de consumir recursos de transacción.
       ================================================================================================ */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios basura. Si queda vacío, se convierte a NULL para activar las validaciones. */
    SET _Nuevo_Codigo = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');
    SET _Nueva_Desc   = NULLIF(TRIM(_Nueva_Desc), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD
       El formulario exige que todos los campos críticos existan. */
    
    IF _Id_Puesto IS NULL OR _Id_Puesto <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: Identificador de Puesto inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO es obligatorio para la edición.';
    END IF;

    IF _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE es obligatorio para la edición.';
    END IF;
    
    /* ================================================================================================
       BLOQUE 3: ESTRATEGIA DE BLOQUEO DETERMINÍSTICO (PREVENCIÓN DE DEADLOCKS)
       Propósito: Adquirir los recursos necesarios en un orden estricto para evitar bloqueos mutuos.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: RECONOCIMIENTO (LECTURA SUCIA / NO BLOQUEANTE)
       Primero "miramos" el panorama para saber qué filas están involucradas sin bloquear nada aún.
       Esto nos permite armar la lista de IDs que necesitaremos bloquear.
       ------------------------------------------------------------------------------------------------ */
    
    /* A) Identificar el registro objetivo (Target) */
    SELECT `Codigo`, `Nombre` INTO v_Cod_Act, v_Nom_Act
    FROM `Cat_Puestos_Trabajo` WHERE `Id_CatPuesto` = _Id_Puesto;

    /* Si no encontramos el registro propio, abortamos (pudo ser borrado por otro admin hace instantes) */
    IF v_Cod_Act IS NULL AND v_Nom_Act IS NULL THEN 
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Puesto que intenta editar no existe.';
    END IF;

    /* B) Identificar posible conflicto de CÓDIGO (¿Alguien más ya tiene mi nuevo código?)
       Solo buscamos si el código cambió respecto al actual. */
    IF _Nuevo_Codigo <> IFNULL(v_Cod_Act, '') THEN
        SELECT `Id_CatPuesto` INTO v_Id_Conflicto_Cod 
        FROM `Cat_Puestos_Trabajo` 
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatPuesto` <> _Id_Puesto LIMIT 1;
    END IF;

    /* C) Identificar posible conflicto de NOMBRE (¿Alguien más ya tiene mi nuevo nombre?)
       Solo buscamos si el nombre cambió respecto al actual. */
    IF _Nuevo_Nombre <> v_Nom_Act THEN
        SELECT `Id_CatPuesto` INTO v_Id_Conflicto_Nom 
        FROM `Cat_Puestos_Trabajo` 
        WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatPuesto` <> _Id_Puesto LIMIT 1;
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: EJECUCIÓN DE BLOQUEOS ORDENADOS (ALGORITMO)
       Esta es la parte crítica. Ordenamos los IDs (Propio, ConflictoCod, ConflictoNom) y bloqueamos 
       de MENOR a MAYOR.
       
       Justificación: Si la Transacción A quiere bloquear (1, 5) y la Transacción B quiere bloquear (5, 1),
       al forzar el orden ascendente, ambas intentarán bloquear (1) primero. Una esperará a la otra. 
       Sin este orden, ocurriría un Deadlock.
       ------------------------------------------------------------------------------------------------ */
    
    /* Llenamos el pool de IDs a bloquear */
    SET v_L1 = _Id_Puesto;
    SET v_L2 = v_Id_Conflicto_Cod;
    SET v_L3 = v_Id_Conflicto_Nom;

    /* Normalización: Eliminar duplicados en las variables (ej: si conflicto Cod y Nom son el mismo ID externo) */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* --- RONDA 1: Bloquear el ID Menor --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Puestos_Trabajo` WHERE `Id_CatPuesto` = v_Min FOR UPDATE;
        /* Marcar como procesado (borrar del pool) para la siguiente ronda */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 2: Bloquear el Siguiente ID --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Puestos_Trabajo` WHERE `Id_CatPuesto` = v_Min FOR UPDATE;
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 3: Bloquear el ID Mayor (Último) --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Puestos_Trabajo` WHERE `Id_CatPuesto` = v_Min FOR UPDATE;
    END IF;

    /* ================================================================================================
       BLOQUE 4: LÓGICA DE NEGOCIO (BAJO PROTECCIÓN DE LOCKS)
       Propósito: Ahora que tenemos exclusividad sobre las filas, aplicamos las reglas de negocio.
       ================================================================================================ */

    /* 4.1 RE-LECTURA AUTORIZADA
       Ahora que tenemos los bloqueos, leemos el estado definitivo de nuestro registro.
       (El registro podría haber cambiado en los milisegundos previos al bloqueo). */
    SELECT `Codigo`, `Nombre`, `Descripcion` 
    INTO v_Cod_Act, v_Nom_Act, v_Desc_Act
    FROM `Cat_Puestos_Trabajo` 
    WHERE `Id_CatPuesto` = _Id_Puesto; 

    /* Safety Check: Si al bloquear descubrimos que el registro fue borrado */
    IF v_Nom_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [410]: El registro desapareció durante la transacción.';
    END IF;

    /* 4.2 DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       Comparamos si los datos nuevos son matemáticamente iguales a los actuales. 
       Usamos `<=>` (Null-Safe Equality) para manejar correctamente los NULLs en campos opcionales. */
    IF (v_Cod_Act <=> _Nuevo_Codigo) 
       AND (v_Nom_Act = _Nuevo_Nombre) 
       AND (v_Desc_Act <=> _Nueva_Desc) THEN
       
       COMMIT; -- Liberamos locks inmediatamente
       
       /* Retorno anticipado para ahorrar I/O y notificar al Frontend */
       SELECT 'AVISO: No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion, _Id_Puesto AS Id_Puesto;
       LEAVE THIS_PROC;
    END IF;

    /* 4.3 VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       Verificamos si existen duplicados REALES. Al tener los registros conflictivos bloqueados,
       esta verificación es 100% fiable. */
    
    /* A) Validación por CÓDIGO */
    SET v_Id_Error = NULL;
    SELECT `Id_CatPuesto` INTO v_Id_Error FROM `Cat_Puestos_Trabajo` 
    WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatPuesto` <> _Id_Puesto LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya pertenece a otro Puesto.';
    END IF;

    /* B) Validación por NOMBRE */
    SET v_Id_Error = NULL;
    SELECT `Id_CatPuesto` INTO v_Id_Error FROM `Cat_Puestos_Trabajo` 
    WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatPuesto` <> _Id_Puesto LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya pertenece a otro Puesto.';
    END IF;

    /* ================================================================================================
       BLOQUE 5: PERSISTENCIA Y FINALIZACIÓN (UPDATE)
       Propósito: Aplicar los cambios una vez superadas todas las barreras de seguridad.
       ================================================================================================ */
    
    SET v_Dup = 0; -- Resetear bandera de error antes de escribir

    UPDATE `Cat_Puestos_Trabajo`
    SET `Codigo`      = _Nuevo_Codigo,
        `Nombre`      = _Nuevo_Nombre,
        `Descripcion` = _Nueva_Desc,
        `updated_at`  = NOW() -- Auditoría automática
    WHERE `Id_CatPuesto` = _Id_Puesto;

    /* ================================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       Propósito: Gestionar el caso extremo donde un insert fantasma ocurre justo antes del update.
       ================================================================================================ */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico Post-Mortem para el usuario */
        SET v_Campo_Error = 'DESCONOCIDO';
        SET v_Id_Error = NULL;

        /* ¿Fue conflicto de Código? */
        SELECT `Id_CatPuesto` INTO v_Id_Error FROM `Cat_Puestos_Trabajo` 
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_CatPuesto` <> _Id_Puesto LIMIT 1;
        
        IF v_Id_Error IS NOT NULL THEN
            SET v_Campo_Error = 'CODIGO';
        ELSE
            /* Entonces fue conflicto de Nombre */
            SELECT `Id_CatPuesto` INTO v_Id_Error FROM `Cat_Puestos_Trabajo` 
            WHERE `Nombre` = _Nuevo_Nombre AND `Id_CatPuesto` <> _Id_Puesto LIMIT 1;
            SET v_Campo_Error = 'NOMBRE';
        END IF;

        SELECT 'Error de Concurrencia: Conflicto detectado al guardar (Otro usuario ganó).' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo, 
               v_Id_Error AS Id_Conflicto;
        LEAVE THIS_PROC;
    END IF;

    /* ================================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       Propósito: Confirmar la transacción y notificar al cliente.
       ================================================================================================ */
    COMMIT;
    
    SELECT 'ÉXITO: Puesto actualizado correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Puesto AS Id_Puesto;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO ALMACENADO: SP_EditarRol
   ====================================================================================================
   
   1. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento orquesta la modificación de los atributos descriptivos de un "Rol de Sistema"
   (`Cat_Roles`) existente en el catálogo de seguridad.
   
   No es un simple UPDATE; es un motor transaccional diseñado para operar en entornos de alta 
   concurrencia, garantizando las propiedades ACID:
     - Atomicidad: O se aplican todos los cambios, o ninguno.
     - Consistencia: No se permiten duplicados de Código o Nombre.
     - Aislamiento: Uso de bloqueos determinísticos para prevenir abrazos mortales (Deadlocks).
     - Durabilidad: Confirmación explícita (COMMIT) tras validar reglas.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ----------------------------------------------------------------------------------------------------
   A) OBLIGATORIEDAD DE CAMPOS:
      - Regla: "Todo o Nada". Código, Nombre y Descripción son MANDATORIOS.
      - Justificación: Un rol sin descripción clara es un riesgo de seguridad (ambigüedad de alcance).

   B) UNICIDAD GLOBAL (EXCLUSIÓN PROPIA):
      - Se verifica que el nuevo Código no pertenezca a OTRO rol (`Id <> _Id_Rol`).
      - Se verifica que el nuevo Nombre no pertenezca a OTRO rol.
      - Nota: Es perfectamente legal que el registro "choque consigo mismo" (ej: cambiar solo la descripción).

   3. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   ----------------------------------------------------------------------------------------------------
   Para prevenir **Deadlocks** (Bloqueos Mutuos) en escenarios de "Intercambio" (Swap Scenario) donde
   dos administradores intentan editar registros cruzados simultáneamente, implementamos una estrategia 
   de BLOQUEO DETERMINÍSTICO:

     - FASE 1 (Identificación): Detectamos todos los IDs involucrados en la transacción (El ID objetivo,
       el ID dueño del código deseado y el ID dueño del nombre deseado).
     - FASE 2 (Ordenamiento): Ordenamos estos IDs numéricamente de MENOR a MAYOR.
     - FASE 3 (Ejecución): Adquirimos los bloqueos (`FOR UPDATE`) siguiendo estrictamente ese orden.
   
   Resultado: Todos los procesos compiten por los recursos en la misma dirección ("fila india"), 
   eliminando matemáticamente la posibilidad de un ciclo de espera infinito.

   4. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   ----------------------------------------------------------------------------------------------------
   - Antes de escribir en disco, el SP compara el estado actual (`Snapshot`) contra los nuevos valores.
   - Si son idénticos, retorna éxito ('SIN_CAMBIOS') inmediatamente.
   - Beneficio: Evita escrituras innecesarias en el Transaction Log y mantiene intacta la fecha `updated_at`.

   5. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset con:
      - Mensaje (VARCHAR): Feedback descriptivo.
      - Accion (VARCHAR): 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
      - Id_Rol (INT): Identificador del recurso manipulado.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarRol`$$

CREATE PROCEDURE `SP_EditarRol`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Recibimos los datos crudos del formulario de edición.
       ----------------------------------------------------------------- */
    IN _Id_Rol      INT,           -- OBLIGATORIO: ID del registro a modificar (PK)
    IN _Nuevo_Codigo VARCHAR(50),   -- OBLIGATORIO: Nueva Clave (ej: 'ADMIN_SYS')
    IN _Nuevo_Nombre VARCHAR(255),  -- OBLIGATORIO: Nuevo Nombre (ej: 'Administrador de Sistema')
    IN _Nueva_Desc   VARCHAR(255)   -- OBLIGATORIO: Descripción detallada (Regla de Negocio)
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Inicializar los contenedores que gestionarán la lógica del procedimiento.
       ================================================================================================ */
    
    /* [Snapshots]: Almacenan el estado actual del registro antes de la edición (para comparar cambios) */
    DECLARE v_Cod_Act  VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nom_Act  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Desc_Act VARCHAR(255) DEFAULT NULL;

    /* [IDs de Conflicto]: Identificadores de filas que podrían chocar con nuestros nuevos datos */
    DECLARE v_Id_Conflicto_Cod INT DEFAULT NULL; 
    DECLARE v_Id_Conflicto_Nom INT DEFAULT NULL; 

    /* [Variables de Algoritmo de Bloqueo]: Auxiliares para ordenar los locks de Menor a Mayor */
    DECLARE v_L1 INT DEFAULT NULL;
    DECLARE v_L2 INT DEFAULT NULL;
    DECLARE v_L3 INT DEFAULT NULL;
    DECLARE v_Min INT DEFAULT NULL;
    DECLARE v_Existe INT DEFAULT NULL; -- Auxiliar para validar que el lock fue exitoso

    /* [Bandera de Control]: Semáforo para detectar errores de concurrencia (Error 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* [Variables de Diagnóstico]: Para reportar al usuario qué campo causó el error */
    DECLARE v_Campo_Error VARCHAR(20) DEFAULT NULL;
    DECLARE v_Id_Error    INT DEFAULT NULL;

    /* ================================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Garantizar una salida limpia ante errores técnicos o de concurrencia.
       ================================================================================================ */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Objetivo: Capturar colisiones de Unique Key en el último milisegundo (Race Condition).
       Acción: No abortamos. Encendemos la bandera v_Dup = 1 para manejar el conflicto controladamente al final. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos técnicos graves (Desconexión, Disco lleno, Sintaxis).
       Acción: Abortar inmediatamente (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST)
       Propósito: Rechazar datos inválidos antes de consumir recursos de transacción.
       ================================================================================================ */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios basura. Si queda vacío, se convierte a NULL para activar las validaciones. */
    SET _Nuevo_Codigo = NULLIF(TRIM(_Nuevo_Codigo), '');
    SET _Nuevo_Nombre = NULLIF(TRIM(_Nuevo_Nombre), '');
    SET _Nueva_Desc   = NULLIF(TRIM(_Nueva_Desc), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD
       El formulario exige que todos los campos críticos existan. */
    
    IF _Id_Rol IS NULL OR _Id_Rol <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: Identificador de Rol inválido.';
    END IF;

    IF _Nuevo_Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO es obligatorio para la edición.';
    END IF;

    IF _Nuevo_Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE es obligatorio para la edición.';
    END IF;
    
    /* Regla Estricta: Descripción obligatoria para asegurar la documentación del rol */
    IF _Nueva_Desc IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: La DESCRIPCIÓN es obligatoria.';
    END IF;
    
    /* ================================================================================================
       BLOQUE 3: ESTRATEGIA DE BLOQUEO DETERMINÍSTICO (PREVENCIÓN DE DEADLOCKS)
       Propósito: Adquirir los recursos necesarios en un orden estricto para evitar bloqueos mutuos.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: RECONOCIMIENTO (LECTURA SUCIA / NO BLOQUEANTE)
       Primero "miramos" el panorama para saber qué filas están involucradas sin bloquear nada aún.
       Esto nos permite armar la lista de IDs que necesitaremos bloquear.
       ------------------------------------------------------------------------------------------------ */
    
    /* A) Identificar el registro objetivo (Target) */
    SELECT `Codigo`, `Nombre` INTO v_Cod_Act, v_Nom_Act
    FROM `Cat_Roles` WHERE `Id_Rol` = _Id_Rol;

    /* Si no encontramos el registro propio, abortamos (pudo ser borrado por otro admin hace instantes) */
    IF v_Cod_Act IS NULL AND v_Nom_Act IS NULL THEN 
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Rol que intenta editar no existe.';
    END IF;

    /* B) Identificar posible conflicto de CÓDIGO (¿Alguien más ya tiene mi nuevo código?)
       Solo buscamos si el código cambió respecto al actual. */
    IF _Nuevo_Codigo <> IFNULL(v_Cod_Act, '') THEN
        SELECT `Id_Rol` INTO v_Id_Conflicto_Cod 
        FROM `Cat_Roles` 
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_Rol` <> _Id_Rol LIMIT 1;
    END IF;

    /* C) Identificar posible conflicto de NOMBRE (¿Alguien más ya tiene mi nuevo nombre?)
       Solo buscamos si el nombre cambió respecto al actual. */
    IF _Nuevo_Nombre <> v_Nom_Act THEN
        SELECT `Id_Rol` INTO v_Id_Conflicto_Nom 
        FROM `Cat_Roles` 
        WHERE `Nombre` = _Nuevo_Nombre AND `Id_Rol` <> _Id_Rol LIMIT 1;
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: EJECUCIÓN DE BLOQUEOS ORDENADOS (ALGORITMO)
       Esta es la parte crítica. Ordenamos los IDs (Propio, ConflictoCod, ConflictoNom) y bloqueamos 
       de MENOR a MAYOR.
       
       Justificación: Si la Transacción A quiere bloquear (1, 5) y la Transacción B quiere bloquear (5, 1),
       al forzar el orden ascendente, ambas intentarán bloquear (1) primero. Una esperará a la otra. 
       Sin este orden, ocurriría un Deadlock.
       ------------------------------------------------------------------------------------------------ */
    
    /* Llenamos el pool de IDs a bloquear */
    SET v_L1 = _Id_Rol;
    SET v_L2 = v_Id_Conflicto_Cod;
    SET v_L3 = v_Id_Conflicto_Nom;

    /* Normalización: Eliminar duplicados en las variables (ej: si conflicto Cod y Nom son el mismo ID externo) */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* --- RONDA 1: Bloquear el ID Menor --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Roles` WHERE `Id_Rol` = v_Min FOR UPDATE;
        /* Marcar como procesado (borrar del pool) para la siguiente ronda */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 2: Bloquear el Siguiente ID --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Roles` WHERE `Id_Rol` = v_Min FOR UPDATE;
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 3: Bloquear el ID Mayor (Último) --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Roles` WHERE `Id_Rol` = v_Min FOR UPDATE;
    END IF;

    /* ================================================================================================
       BLOQUE 4: LÓGICA DE NEGOCIO (BAJO PROTECCIÓN DE LOCKS)
       Propósito: Ahora que tenemos exclusividad sobre las filas, aplicamos las reglas de negocio.
       ================================================================================================ */

    /* 4.1 RE-LECTURA AUTORIZADA
       Ahora que tenemos los bloqueos, leemos el estado definitivo de nuestro registro.
       (El registro podría haber cambiado en los milisegundos previos al bloqueo). */
    SELECT `Codigo`, `Nombre`, `Descripcion` 
    INTO v_Cod_Act, v_Nom_Act, v_Desc_Act
    FROM `Cat_Roles` 
    WHERE `Id_Rol` = _Id_Rol; 

    /* Safety Check: Si al bloquear descubrimos que el registro fue borrado */
    IF v_Nom_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [410]: El registro desapareció durante la transacción.';
    END IF;

    /* 4.2 DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       Comparamos si los datos nuevos son matemáticamente iguales a los actuales. 
       Usamos <=> (Null-Safe Equality) para manejar correctamente los NULLs en campos opcionales. */
    IF (v_Cod_Act <=> _Nuevo_Codigo) 
       AND (v_Nom_Act = _Nuevo_Nombre) 
       AND (v_Desc_Act <=> _Nueva_Desc) THEN
        
        COMMIT; -- Liberamos locks inmediatamente
        
        /* Retorno anticipado para ahorrar I/O y notificar al Frontend */
        SELECT 'AVISO: No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion, _Id_Rol AS Id_Rol;
        LEAVE THIS_PROC;
    END IF;

    /* 4.3 VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       Verificamos si existen duplicados REALES. Al tener los registros conflictivos bloqueados,
       esta verificación es 100% fiable. */
    
    /* A) Validación por CÓDIGO */
    SET v_Id_Error = NULL;
    SELECT `Id_Rol` INTO v_Id_Error FROM `Cat_Roles` 
    WHERE `Codigo` = _Nuevo_Codigo AND `Id_Rol` <> _Id_Rol LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya pertenece a otro Rol.';
    END IF;

    /* B) Validación por NOMBRE */
    SET v_Id_Error = NULL;
    SELECT `Id_Rol` INTO v_Id_Error FROM `Cat_Roles` 
    WHERE `Nombre` = _Nuevo_Nombre AND `Id_Rol` <> _Id_Rol LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya pertenece a otro Rol.';
    END IF;

    /* ================================================================================================
       BLOQUE 5: PERSISTENCIA Y FINALIZACIÓN (UPDATE)
       Propósito: Aplicar los cambios una vez superadas todas las barreras de seguridad.
       ================================================================================================ */
    
    SET v_Dup = 0; -- Resetear bandera de error antes de escribir

    UPDATE `Cat_Roles`
    SET `Codigo`      = _Nuevo_Codigo,
        `Nombre`      = _Nuevo_Nombre,
        `Descripcion` = _Nueva_Desc,
        `updated_at`  = NOW() -- Auditoría automática
    WHERE `Id_Rol` = _Id_Rol;

    /* ================================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       Propósito: Gestionar el caso extremo donde un insert fantasma ocurre justo antes del update.
       ================================================================================================ */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico Post-Mortem para el usuario */
        SET v_Campo_Error = 'DESCONOCIDO';
        SET v_Id_Error = NULL;

        /* ¿Fue conflicto de Código? */
        SELECT `Id_Rol` INTO v_Id_Error FROM `Cat_Roles` 
        WHERE `Codigo` = _Nuevo_Codigo AND `Id_Rol` <> _Id_Rol LIMIT 1;
        
        IF v_Id_Error IS NOT NULL THEN
            SET v_Campo_Error = 'CODIGO';
        ELSE
            /* Entonces fue conflicto de Nombre */
            SELECT `Id_Rol` INTO v_Id_Error FROM `Cat_Roles` 
            WHERE `Nombre` = _Nuevo_Nombre AND `Id_Rol` <> _Id_Rol LIMIT 1;
            SET v_Campo_Error = 'NOMBRE';
        END IF;

        SELECT 'Error de Concurrencia: Conflicto detectado al guardar.' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo, 
               v_Id_Error AS Id_Conflicto;
        LEAVE THIS_PROC;
    END IF;

    /* ================================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       Propósito: Confirmar la transacción y notificar al cliente.
       ================================================================================================ */
    COMMIT;
    
    SELECT 'ÉXITO: Rol actualizado correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Rol AS Id_Rol;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarPerfilPropio
   ============================================================================================

   --------------------------------------------------------------------------------------------
   I. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------------------------------------------------------------
   [PROPÓSITO CENTRAL]:
   Orquestar la actualización atómica del "Expediente Digital" del usuario autenticado.
   Sustituye y unifica los flujos de "Completar Perfil" (Onboarding) y "Editar Mi Perfil".

   [PROBLEMA A RESOLVER]:
   En un sistema de alta concurrencia, permitir que el usuario edite sus propios datos presenta
   riesgos de integridad (asignarse a puestos inexistentes) y colisión (dos sesiones editando
   al mismo tiempo).
   
   Este SP actúa como un **Motor Transaccional Blindado** que garantiza:
   1. Consistencia: No se pueden guardar referencias a catálogos borrados o inactivos.
   2. Seguridad: El usuario no puede escalar privilegios ni modificar datos de otros.
   3. Eficiencia: No se toca el disco si no hubo cambios reales.

   --------------------------------------------------------------------------------------------
   II. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   --------------------------------------------------------------------------------------------
   [RN-01] VALIDACIÓN HÍBRIDA DE ADSCRIPCIÓN (LAZY & STRICT CHECK):
      - Contexto: La realidad operativa a veces supera a la actualización de catálogos.
      - Regla Estricta: 'Régimen' y 'Región' son OBLIGATORIOS (Datos macro siempre conocidos).
      - Regla Perezosa (Lazy): 'Puesto', 'CT', 'Depto', 'Gerencia' son OPCIONALES (Permiten NULL).
      - Integridad: Si el usuario envía un ID para un campo opcional, se valida estrictamente
        que exista y esté `Activo=1`. No se permiten IDs "zombis".

   [RN-02] PROTECCIÓN DE IDENTIDAD (IDENTITY COLLISION):
      - Se permite corregir la FICHA (error de dedo al registro).
      - Se valida que la nueva ficha no pertenezca a OTRO usuario (`Id != Me`).
      - El Email NO se toca aquí (se delega a un módulo de seguridad con re-autenticación).

   --------------------------------------------------------------------------------------------
   III. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   --------------------------------------------------------------------------------------------
   [BLOQUEO PESIMISTA - PESSIMISTIC LOCKING]:
   - Problema: "Race Condition". El usuario abre su perfil en dos pestañas, edita cosas distintas
     y guarda casi al mismo tiempo. El último "gana" y sobrescribe al primero sin saberlo.
   - Solución: Al inicio de la transacción, ejecutamos `SELECT ... FOR UPDATE`.
   - Efecto: La fila del usuario se "congela". Cualquier otra transacción que intente leerla
     o escribirla deberá esperar a que esta termine. Garantiza aislamiento total (SERIALIZABLE).

   --------------------------------------------------------------------------------------------
   IV. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   --------------------------------------------------------------------------------------------
   [MOTOR DE DETECCIÓN DE CAMBIOS]:
   - Antes de escribir, el SP compara el Snapshot (Valores Actuales) vs Inputs.
   - Usamos el operador `<=>` (Null-Safe Equality) para comparar campos que pueden ser NULL.
   - Si todo es idéntico, retornamos `ACCION: 'SIN_CAMBIOS'` y hacemos COMMIT inmediato.
   - Beneficio: Ahorro masivo de I/O de disco y evita ensuciar los logs de auditoría.

   --------------------------------------------------------------------------------------------
   V. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   --------------------------------------------------------------------------------------------
   Retorna un resultset estructurado para el Frontend:
      - Mensaje (VARCHAR): Feedback granular ("Se actualizó: Foto, Puesto").
      - Accion (VARCHAR): 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
      - Id_Usuario (INT): Contexto.
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarPerfilPropio`$$

CREATE PROCEDURE `SP_EditarPerfilPropio`(
    /* -----------------------------------------------------------------
       1. CONTEXTO DE SEGURIDAD (AUTH TOKEN)
       Este ID debe venir del Middleware de Autenticación.
       ----------------------------------------------------------------- */
    IN _Id_Usuario_Sesion INT,

    /* -----------------------------------------------------------------
       2. IDENTIDAD DIGITAL & VISUAL
       Datos para la tarjeta de presentación del usuario.
       ----------------------------------------------------------------- */
    IN _Ficha            VARCHAR(50),
    IN _Url_Foto         VARCHAR(255), 

    /* -----------------------------------------------------------------
       3. IDENTIDAD HUMANA (DEMOGRÁFICOS)
       Datos fundamentales para la Huella Humana.
       ----------------------------------------------------------------- */
    IN _Nombre            VARCHAR(255),
    IN _Apellido_Paterno  VARCHAR(255),
    IN _Apellido_Materno  VARCHAR(255),
    IN _Fecha_Nacimiento  DATE,
    IN _Fecha_Ingreso     DATE,

    /* -----------------------------------------------------------------
       4. MATRIZ DE ADSCRIPCIÓN (CATÁLOGOS)
       IDs provenientes de los -- DROPdowns. Algunos son obligatorios, otros opcionales.
       ----------------------------------------------------------------- */
    IN _Id_Regimen        INT, -- [OBLIGATORIO]
    IN _Id_Puesto         INT, -- [OPCIONAL]
    IN _Id_CentroTrabajo  INT, -- [OPCIONAL]
    IN _Id_Departamento   INT, -- [OPCIONAL]
    IN _Id_Region         INT, -- [OBLIGATORIO]
    IN _Id_Gerencia       INT, -- [OPCIONAL]
    
    /* -----------------------------------------------------------------
       5. METADATOS ADMINISTRATIVOS
       Datos tabulares informativos.
       ----------------------------------------------------------------- */
    IN _Nivel             VARCHAR(50),
    IN _Clasificacion     VARCHAR(100)
)
THIS_PROC: BEGIN
    
    /* ============================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Contenedores en memoria para la lógica de comparación y control de flujo.
       ============================================================================================ */
    
    /* Punteros de Relación y Banderas */
    DECLARE v_Id_InfoPersonal INT DEFAULT NULL; 
    DECLARE v_Es_Activo       TINYINT(1);       
    DECLARE v_Id_Duplicado    INT;              
    
    /* Variables de Normalización (Input '0' -> NULL BD) */
    DECLARE v_Id_Puesto_Norm  INT;
    DECLARE v_Id_CT_Norm      INT;
    DECLARE v_Id_Dep_Norm     INT;
    DECLARE v_Id_Gerencia_Norm INT;

    /* Variables de Snapshot (Para almacenar el estado "ANTES" de la edición) */
    DECLARE v_Ficha_Act       VARCHAR(50);
    DECLARE v_Foto_Act        VARCHAR(255);
    DECLARE v_Nombre_Act      VARCHAR(255);
    DECLARE v_Paterno_Act     VARCHAR(255);
    DECLARE v_Materno_Act     VARCHAR(255);
    DECLARE v_Nacim_Act       DATE;
    DECLARE v_Ingre_Act       DATE;
    DECLARE v_Regimen_Act     INT;
    DECLARE v_Puesto_Act      INT;
    DECLARE v_CT_Act          INT;
    DECLARE v_Dep_Act         INT;
    DECLARE v_Region_Act      INT;
    DECLARE v_Geren_Act       INT;
    DECLARE v_Nivel_Act       VARCHAR(50);
    DECLARE v_Clasif_Act      VARCHAR(100);

    /* Variable Acumuladora de Cambios (El "Chismoso" para Feedback Granular) */
    DECLARE v_Cambios_Detectados VARCHAR(500) DEFAULT '';

    /* ============================================================================================
       BLOQUE 1: HANDLERS (MECANISMOS DE DEFENSA)
       Propósito: Garantizar una salida limpia y mensajes humanos ante errores técnicos.
       ============================================================================================ */
    
    /* [1.1] Handler 1062: Colisión de Unicidad
       Objetivo: Capturar si otro usuario registró la misma Ficha en el último milisegundo. */
    DECLARE EXIT HANDLER FOR 1062
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE CONFLICTO [409]: La Ficha que intentas guardar ya existe.';
    END;

    /* [1.2] Handler 1452: Integridad Referencial Rota (CRÍTICO)
       Objetivo: Atrapa casos donde el ID enviado es válido numéricamente (ej: Puesto 5), 
       pero la fila padre fue borrada físicamente de la BD durante la transacción. 
       Evita que el sistema colapse con un error técnico. */
    DECLARE EXIT HANDLER FOR 1452
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD [409]: Uno de los catálogos seleccionados dejó de existir en el sistema.';
    END;

    /* [1.3] Handler Genérico: Fallos de sistema imprevistos */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ============================================================================================
       BLOQUE 2: SANITIZACIÓN Y NORMALIZACIÓN (INPUT HYGIENE)
       Propósito: Asegurar consistencia de datos (Mayúsculas, Sin espacios, Nulos correctos).
       ============================================================================================ */
    SET _Ficha            = TRIM(_Ficha);
    /* Limpieza de Foto: Si envían cadena vacía, se guarda NULL */
    SET _Url_Foto         = NULLIF(TRIM(_Url_Foto), '');
    
    SET _Nombre           = TRIM(UPPER(_Nombre));
    SET _Apellido_Paterno = TRIM(UPPER(_Apellido_Paterno));
    SET _Apellido_Materno = TRIM(UPPER(_Apellido_Materno));
    SET _Nivel            = TRIM(UPPER(_Nivel));
    SET _Clasificacion    = TRIM(UPPER(_Clasificacion));

    /* Normalización de IDs Opcionales: El Frontend puede enviar '0' para "Sin Selección". 
       La BD requiere NULL para mantener la integridad referencial y ahorrar espacio. */
    SET v_Id_Puesto_Norm   = NULLIF(_Id_Puesto, 0);
    SET v_Id_CT_Norm       = NULLIF(_Id_CentroTrabajo, 0);
    SET v_Id_Dep_Norm      = NULLIF(_Id_Departamento, 0);
    SET v_Id_Gerencia_Norm = NULLIF(_Id_Gerencia, 0);

    /* ============================================================================================
       BLOQUE 3: VALIDACIONES PREVIAS (FAIL FAST)
       Propósito: Rechazar peticiones inválidas antes de abrir transacción.
       ============================================================================================ */
    
    /* 3.1 Validación de Sesión */
    IF _Id_Usuario_Sesion IS NULL OR _Id_Usuario_Sesion <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SEGURIDAD [401]: Sesión no válida.';
    END IF;

    /* 3.2 Regla de Obligatoriedad Híbrida (Solo Régimen y Región son Hard Constraints) */
    IF (_Id_Regimen <= 0 OR _Id_Regimen IS NULL) OR 
       (_Id_Region <= 0 OR _Id_Region IS NULL) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: Régimen y Región son obligatorios.';
    END IF;

    /* ============================================================================================
       BLOQUE 4: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       Propósito: Asegurar aislamiento total para la lectura y escritura.
       ============================================================================================ */
    START TRANSACTION;

    /* 4.1 Bloqueo y Lectura de USUARIO (Parent Entity)
       Usamos `FOR UPDATE` para adquirir un "Write Lock". Nadie más puede tocar esta fila. */
    SELECT `Fk_Id_InfoPersonal`, `Ficha`, `Foto_Perfil_Url`
    INTO v_Id_InfoPersonal, v_Ficha_Act, v_Foto_Act
    FROM `Usuarios` 
    WHERE `Id_Usuario` = _Id_Usuario_Sesion
    FOR UPDATE;

    IF v_Id_InfoPersonal IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD [500]: Perfil de datos personales no encontrado.';
    END IF;

    /* 4.2 Bloqueo y Lectura de INFO_PERSONAL (Child Entity)
       Leemos el estado completo actual para alimentar el motor de detección de cambios. */
    SELECT 
        `Nombre`, `Apellido_Paterno`, `Apellido_Materno`, `Fecha_Nacimiento`, `Fecha_Ingreso`,
        `Fk_Id_CatRegimen`, `Fk_Id_CatPuesto`, `Fk_Id_CatCT`, `Fk_Id_CatDep`, `Fk_Id_CatRegion`, `Fk_Id_CatGeren`,
        `Nivel`, `Clasificacion`
    INTO 
        v_Nombre_Act, v_Paterno_Act, v_Materno_Act, v_Nacim_Act, v_Ingre_Act,
        v_Regimen_Act, v_Puesto_Act, v_CT_Act, v_Dep_Act, v_Region_Act, v_Geren_Act,
        v_Nivel_Act, v_Clasif_Act
    FROM `Info_Personal`
    WHERE `Id_InfoPersonal` = v_Id_InfoPersonal
    FOR UPDATE;

    /* ============================================================================================
       BLOQUE 5: MOTOR DE DETECCIÓN DE CAMBIOS (EL "CHISMOSO")
       Propósito: Construir el mensaje de feedback granular.
       Lógica: Comparamos campo por campo usando `<=>` (Null-Safe Equality).
       Si hay diferencias, agregamos una etiqueta legible al acumulador.
       ============================================================================================ */
    
    /* 5.1 Cambios en Identidad Digital */
    IF NOT (v_Ficha_Act <=> _Ficha) THEN SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Ficha Corporativa, '); END IF;
    IF NOT (v_Foto_Act <=> _Url_Foto) THEN SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Foto de Perfil, '); END IF;

    /* 5.2 Cambios en Datos Personales (Agrupados por semántica) */
    IF NOT (v_Nombre_Act <=> _Nombre) OR NOT (v_Paterno_Act <=> _Apellido_Paterno) OR 
       NOT (v_Materno_Act <=> _Apellido_Materno) OR NOT (v_Nacim_Act <=> _Fecha_Nacimiento) THEN
        SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Datos Personales, ');
    END IF;

    IF NOT (v_Ingre_Act <=> _Fecha_Ingreso) THEN SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Fecha de Ingreso, '); END IF;

    /* 5.3 Cambios Laborales (Adscripción y Ubicación) */
    IF NOT (v_Regimen_Act <=> _Id_Regimen) OR NOT (v_Region_Act <=> _Id_Region) OR
       NOT (v_Puesto_Act <=> v_Id_Puesto_Norm) OR NOT (v_CT_Act <=> v_Id_CT_Norm) OR
       NOT (v_Dep_Act <=> v_Id_Dep_Norm) OR NOT (v_Geren_Act <=> v_Id_Gerencia_Norm) OR
       NOT (v_Nivel_Act <=> _Nivel) OR NOT (v_Clasif_Act <=> _Clasificacion) THEN
       
       SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Datos Laborales/Ubicación, ');
    END IF;

    /* ============================================================================================
       BLOQUE 6: VERIFICACIÓN DE IDEMPOTENCIA
       Propósito: Optimización. Si el acumulador sigue vacío, el usuario guardó sin tocar nada.
       Acción: Retornamos éxito inmediato sin tocar disco.
       ============================================================================================ */
    IF v_Cambios_Detectados = '' THEN
        COMMIT; -- Liberamos locks
        SELECT 'No se detectaron cambios en la información.' AS Mensaje, _Id_Usuario_Sesion AS Id_Usuario, 'SIN_CAMBIOS' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* ============================================================================================
       BLOQUE 7: VALIDACIONES DE NEGOCIO (Solo se ejecutan si hubo cambios reales)
       Propósito: Proteger la integridad de los datos antes de escribir.
       ============================================================================================ */

    /* 7.1 Colisión de Ficha (Solo si cambió la ficha)
       Verificamos que la nueva ficha no pertenezca a OTRO usuario (`Id != Me`). */
    IF LOCATE('Ficha', v_Cambios_Detectados) > 0 THEN
        SELECT `Id_Usuario` INTO v_Id_Duplicado 
        FROM `Usuarios` WHERE `Ficha` = _Ficha AND `Id_Usuario` <> _Id_Usuario_Sesion LIMIT 1;
        
        IF v_Id_Duplicado IS NOT NULL THEN
            ROLLBACK;
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409]: La Ficha ingresada ya pertenece a otro usuario.';
        END IF;
    END IF;

    /* 7.2 Vigencia de Catálogos (Anti-Zombie Check) 
       Verificamos manualmente que los catálogos seleccionados sigan existiendo y estén `Activo=1`.
       Si alguno fue borrado, el Rollback ocurre aquí. */
    
    /* Obligatorios */
    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Regimenes_Trabajo` WHERE `Id_CatRegimen` = _Id_Regimen;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Régimen no válido.'; END IF;

    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Regiones_Trabajo` WHERE `Id_CatRegion` = _Id_Region;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Región no válida.'; END IF;

    /* Opcionales (Solo validamos si NO son NULL) */
    IF v_Id_Puesto_Norm IS NOT NULL THEN
        SELECT `Activo` INTO v_Es_Activo FROM `Cat_Puestos_Trabajo` WHERE `Id_CatPuesto` = v_Id_Puesto_Norm;
        IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Puesto inactivo.'; END IF;
    END IF;

    IF v_Id_CT_Norm IS NOT NULL THEN
        SELECT `Activo` INTO v_Es_Activo FROM `Cat_Centros_Trabajo` WHERE `Id_CatCT` = v_Id_CT_Norm;
        IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Centro de Trabajo inactivo.'; END IF;
    END IF;

    IF v_Id_Dep_Norm IS NOT NULL THEN
        SELECT `Activo` INTO v_Es_Activo FROM `Cat_Departamentos` WHERE `Id_CatDep` = v_Id_Dep_Norm;
        IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Departamento inactivo.'; END IF;
    END IF;

    IF v_Id_Gerencia_Norm IS NOT NULL THEN
        SELECT `Activo` INTO v_Es_Activo FROM `Cat_Gerencias_Activos` WHERE `Id_CatGeren` = v_Id_Gerencia_Norm;
        IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Gerencia inactiva.'; END IF;
    END IF;

    /* ============================================================================================
       BLOQUE 8: PERSISTENCIA (UPDATE)
       Propósito: Aplicar los cambios en la base de datos de manera atómica.
       ============================================================================================ */
    
    /* 8.1 Actualizar Info Personal */
    UPDATE `Info_Personal`
    SET 
        `Nombre` = _Nombre, `Apellido_Paterno` = _Apellido_Paterno, `Apellido_Materno` = _Apellido_Materno,
        `Fecha_Nacimiento` = _Fecha_Nacimiento, `Fecha_Ingreso` = _Fecha_Ingreso,
        `Fk_Id_CatRegimen` = _Id_Regimen, `Fk_Id_CatPuesto` = v_Id_Puesto_Norm,
        `Fk_Id_CatCT` = v_Id_CT_Norm, `Fk_Id_CatDep` = v_Id_Dep_Norm,
        `Fk_Id_CatRegion` = _Id_Region, `Fk_Id_CatGeren` = v_Id_Gerencia_Norm,
        `Nivel` = _Nivel, `Clasificacion` = _Clasificacion,
        `Fk_Id_Usuario_Updated_By` = _Id_Usuario_Sesion,
        `updated_at` = NOW()
    WHERE `Id_InfoPersonal` = v_Id_InfoPersonal;

    /* 8.2 Actualizar Usuario */
    UPDATE `Usuarios`
    SET
        `Ficha` = _Ficha,
        `Foto_Perfil_Url` = _Url_Foto,
        `Fk_Usuario_Updated_By` = _Id_Usuario_Sesion,
        `updated_at` = NOW()
    WHERE `Id_Usuario` = _Id_Usuario_Sesion;

    /* ============================================================================================
       BLOQUE 9: CONFIRMACIÓN Y RESPUESTA DINÁMICA
       Propósito: Cerrar la transacción y enviar el feedback al usuario.
       ============================================================================================ */
    COMMIT;

    /* Formateamos el mensaje final quitando la última coma sobrante y agregando el prefijo de éxito */
    /* Ejemplo salida: "ÉXITO: Se ha actualizado: Foto de Perfil, Datos Laborales." */
    SELECT 
        CONCAT('ÉXITO: Se ha actualizado: ', TRIM(TRAILING ', ' FROM v_Cambios_Detectados), '.') AS Mensaje,
        _Id_Usuario_Sesion AS Id_Usuario,
        'ACTUALIZADA' AS Accion;

END$$

DELIMITER ;

/* ============================================================================================
   PROCEDIMIENTO: SP_EditarUsuarioPorAdmin
   ============================================================================================

   --------------------------------------------------------------------------------------------
   I. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------------------------------------------------------------
   [QUÉ ES]: 
   Es el motor transaccional de "Edición Maestra" (Superusuario). Permite la modificación 
   arbitraria y completa de cualquier expediente digital en el sistema, ignorando las 
   restricciones de solo lectura que tienen los usuarios normales.

   [CASO DE USO]: 
   Utilizado exclusivamente por el Panel de Administración para:
     a) Corregir errores humanos en el alta (Fichas o Correos mal escritos).
     b) Gestión de Crisis (Resetear contraseñas olvidadas sin el password anterior).
     c) Reingeniería Organizacional (Mover empleados de Gerencia o Región masivamente).
     d) Escalado de Privilegios (Ascender un Usuario a Coordinador/Admin).

   --------------------------------------------------------------------------------------------
   II. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   --------------------------------------------------------------------------------------------
   A) INTEGRIDAD REFERENCIAL "ANTI-ZOMBIE":
      - Problema: Un Admin intenta mover un usuario a un Departamento que fue borrado hace 1 segundo.
      - Solución: Validación de existencia y vigencia (`Activo=1`) en tiempo real para todos
        los catálogos (Puesto, CT, Depto, etc.) antes de permitir el UPDATE.
      - Mecanismo: Handler SQLSTATE 1452 para capturar integridad rota.

   B) RESET DE CONTRASEÑA CONDICIONAL (SMART OVERRIDE):
      - Regla: "El Admin no necesita saber tu contraseña vieja para darte una nueva".
      - Lógica: 
         * Si `_Nueva_Contrasena` tiene valor -> Se encripta y sobrescribe la actual.
         * Si `_Nueva_Contrasena` es NULL/Vacío -> Se preserva el hash actual (No se toca).

   C) EXCLUSIÓN DE ESTATUS (ATOMICIDAD):
      - Este SP deliberadamente NO toca el campo `Activo`. La baja/reactivación se delega
        a un micro-servicio separado (`SP_CambiarEstatusUsuario`) para evitar accidentes.

   --------------------------------------------------------------------------------------------
   III. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   --------------------------------------------------------------------------------------------
   [EL PROBLEMA DE LA "CARRERA" (RACE CONDITION)]:
   Escenario: El Admin A abre el perfil de "Juan". El Admin B abre el mismo perfil.
   A cambia el Puesto. B cambia el Correo. Ambos guardan. El último sobrescribe al primero 
   sin saberlo ("Lost Update").

   [LA SOLUCIÓN BLINDADA]:
   Implementamos un **Bloqueo Pesimista** (`SELECT ... FOR UPDATE`) al inicio de la transacción.
     - Efecto: La fila del usuario `_Id_Usuario_Objetivo` queda "secuestrada" por la transacción.
     - Resultado: Si otro Admin intenta editar al mismo usuario simultáneamente, su petición 
       quedará en espera (Wait) hasta que la primera termine. Garantiza consistencia SERIALIZABLE.

   --------------------------------------------------------------------------------------------
   IV. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   --------------------------------------------------------------------------------------------
   [MOTOR DE DETECCIÓN DE CAMBIOS]:
   - Antes de escribir en disco, el SP extrae un "Snapshot" del estado actual del registro.
   - Compara matemáticamente cada campo nuevo contra el actual (usando `<=>` para NULLs).
   - Si `Delta = 0` (No hay cambios), retorna éxito inmediato (`SIN_CAMBIOS`) y libera la conexión.
   - Beneficio: Reduce la carga de I/O en el disco del servidor y evita logs de auditoría basura.

   --------------------------------------------------------------------------------------------
   V. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   --------------------------------------------------------------------------------------------
   Retorna un resultset único con:
      - Mensaje (VARCHAR): Feedback humano detallando qué cambió ("Se actualizó: Rol, Foto").
      - Accion (VARCHAR): Códigos de estado para el Frontend ('ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO').
      - Id_Usuario (INT): Contexto para refrescar la vista.
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarUsuarioPorAdmin`$$

CREATE PROCEDURE `SP_EditarUsuarioPorAdmin`(
    /* -----------------------------------------------------------------
       1. CONTEXTO DE AUDITORÍA (ACTORES)
       ----------------------------------------------------------------- */
    IN _Id_Admin_Ejecutor    INT,   -- Quién realiza el cambio (Auditoría)
    IN _Id_Usuario_Objetivo  INT,   -- A quién se le aplica el cambio (Target)

    /* -----------------------------------------------------------------
       2. INFO USUARIO (CRÍTICOS DE IDENTIDAD)
       ----------------------------------------------------------------- */
    IN _Ficha                VARCHAR(50),
    IN _Url_Foto             VARCHAR(255),

    /* -----------------------------------------------------------------
       3. IDENTIDAD HUMANA (DEMOGRÁFICOS)
       ----------------------------------------------------------------- */
    IN _Nombre               VARCHAR(255),
    IN _Apellido_Paterno     VARCHAR(255),
    IN _Apellido_Materno     VARCHAR(255),
    IN _Fecha_Nacimiento     DATE,
    IN _Fecha_Ingreso        DATE,

	/* -----------------------------------------------------------------
	   2.5 SEGURIDAD Y ACCESOS Y PRIVILEGIOS (CRÍTICOS DE SISTEMA)
	   ----------------------------------------------------------------- */
    IN _Email                VARCHAR(255),
    IN _Nueva_Contrasena     VARCHAR(255), -- OPCIONAL: Si viene lleno, se resetea el password
	IN _Id_Rol               INT,          -- [ADMIN POWER] Cambio de privilegios
    

    /* -----------------------------------------------------------------
       4. MATRIZ DE ADSCRIPCIÓN (UBICACIÓN EN EL ORGANIGRAMA)
       ----------------------------------------------------------------- */
    IN _Id_Regimen           INT, 
    IN _Id_Puesto            INT, 
    IN _Id_CentroTrabajo     INT, 
    IN _Id_Departamento      INT, 
    IN _Id_Region            INT, 
    IN _Id_Gerencia          INT, 
    
    /* -----------------------------------------------------------------
       5. METADATOS
       ----------------------------------------------------------------- */
    IN _Nivel                VARCHAR(50),
    IN _Clasificacion        VARCHAR(100)

)
THIS_PROC: BEGIN
    
    /* ============================================================================================
       BLOQUE 0: VARIABLES DE ESTADO Y CONTEXTO
       ============================================================================================ */
    DECLARE v_Id_InfoPersonal INT DEFAULT NULL; 
    DECLARE v_Es_Activo       TINYINT(1);       
    DECLARE v_Id_Duplicado    INT;              
    
    /* Normalización de IDs (Input '0' -> NULL BD) */
    DECLARE v_Id_Puesto_Norm   INT;
    DECLARE v_Id_CT_Norm       INT;
    DECLARE v_Id_Dep_Norm      INT;
    DECLARE v_Id_Gerencia_Norm INT;
    DECLARE v_Pass_Norm        VARCHAR(255); -- Para lógica de reset de password

    /* Snapshots (Estado Actual en BD para comparación) */
    DECLARE v_Ficha_Act       VARCHAR(50);
    DECLARE v_Email_Act       VARCHAR(255); 
    DECLARE v_Rol_Act         INT;
    DECLARE v_Foto_Act        VARCHAR(255);
    
    DECLARE v_Nombre_Act      VARCHAR(255);
    DECLARE v_Paterno_Act     VARCHAR(255);
    DECLARE v_Materno_Act     VARCHAR(255);
    DECLARE v_Nacim_Act       DATE;
    DECLARE v_Ingre_Act       DATE;
    
    DECLARE v_Regimen_Act     INT;
    DECLARE v_Puesto_Act      INT;
    DECLARE v_CT_Act          INT;
    DECLARE v_Dep_Act         INT;
    DECLARE v_Region_Act      INT;
    DECLARE v_Geren_Act       INT;
    DECLARE v_Nivel_Act       VARCHAR(50);
    DECLARE v_Clasif_Act      VARCHAR(100);

    /* Acumulador de Cambios (El "Chismoso") */
    DECLARE v_Cambios_Detectados VARCHAR(1000) DEFAULT '';

    /* ============================================================================================
       BLOQUE 1: HANDLERS DE SEGURIDAD (MECANISMOS DE DEFENSA)
       ============================================================================================ */
    
    /* [1.1] Colisión de Unicidad
       Objetivo: Capturar si se intenta asignar una Ficha/Email que ya existe en otro usuario. */
    DECLARE EXIT HANDLER FOR 1062
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE CONFLICTO [409]: La Ficha o el Email ingresados ya pertenecen a otro usuario.';
    END;

    /* [1.2] Integridad Referencial Rota (Error 1452)
       Objetivo: Proteger el sistema si un catálogo es eliminado físicamente mientras se edita. */
    DECLARE EXIT HANDLER FOR 1452
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD [409]: Uno de los catálogos seleccionados dejó de existir en el sistema.';
    END;

    /* [1.3] Handler Genérico (Crash Safety) */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ============================================================================================
       BLOQUE 2: SANITIZACIÓN Y NORMALIZACIÓN (INPUT HYGIENE)
       ============================================================================================ */
    SET _Ficha            = TRIM(_Ficha);
    SET _Email            = TRIM(_Email);
    SET _Url_Foto         = NULLIF(TRIM(_Url_Foto), '');
    
    /* Lógica de Password: Si viene vacío/null, normalizamos a NULL para que el COALESCE posterior funcione */
    SET v_Pass_Norm       = NULLIF(TRIM(_Nueva_Contrasena), '');

    SET _Nombre           = TRIM(UPPER(_Nombre));
    SET _Apellido_Paterno = TRIM(UPPER(_Apellido_Paterno));
    SET _Apellido_Materno = TRIM(UPPER(_Apellido_Materno));
    SET _Nivel            = TRIM(UPPER(_Nivel));
    SET _Clasificacion    = TRIM(UPPER(_Clasificacion));

    /* Normalización de IDs (Convertir 0 a NULL para integridad referencial) */
    SET v_Id_Puesto_Norm   = NULLIF(_Id_Puesto, 0);
    SET v_Id_CT_Norm       = NULLIF(_Id_CentroTrabajo, 0);
    SET v_Id_Dep_Norm      = NULLIF(_Id_Departamento, 0);
    SET v_Id_Gerencia_Norm = NULLIF(_Id_Gerencia, 0);

    /* ============================================================================================
       BLOQUE 3: VALIDACIONES PREVIAS (FAIL FAST)
       ============================================================================================ */
    
    /* 3.1 Integridad de Auditoría */
    IF _Id_Admin_Ejecutor IS NULL OR _Id_Admin_Ejecutor <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE AUDITORÍA [403]: ID de Administrador no válido. No se puede auditar el cambio.';
    END IF;

    IF _Id_Usuario_Objetivo IS NULL OR _Id_Usuario_Objetivo <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: ID de Usuario Objetivo no válido.';
    END IF;

    /* 3.2 Campos Críticos de Sistema (Admin no puede dejar esto vacío) */
    IF _Id_Rol <= 0 OR _Id_Rol IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El ROL es obligatorio. Un usuario no puede existir sin permisos.';
    END IF;

    /* 3.3 Regla de Adscripción Híbrida */
    IF (_Id_Regimen <= 0 OR _Id_Regimen IS NULL) OR 
       (_Id_Region <= 0 OR _Id_Region IS NULL) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: Régimen y Región son obligatorios para la estructura organizacional.';
    END IF;

    /* ============================================================================================
       BLOQUE 4: INICIO TRANSACCIÓN Y BLOQUEO PESIMISTA
       ============================================================================================ */
    START TRANSACTION;

    /* 4.1 Bloqueo del USUARIO OBJETIVO
       Usamos `FOR UPDATE` para adquirir un "Write Lock". Nadie más puede tocar esta fila. 
       Esto previene condiciones de carrera si dos admins editan al mismo usuario. */
    SELECT 
        `Fk_Id_InfoPersonal`, `Ficha`, `Email`, `Foto_Perfil_Url`, `Fk_Rol`
    INTO 
        v_Id_InfoPersonal, v_Ficha_Act, v_Email_Act, v_Foto_Act, v_Rol_Act
    FROM `Usuarios` 
    WHERE `Id_Usuario` = _Id_Usuario_Objetivo
    FOR UPDATE;

    IF v_Id_InfoPersonal IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El usuario objetivo no existe.';
    END IF;

    /* 4.2 Bloqueo de INFO_PERSONAL (Tabla Satélite) */
    SELECT 
        `Nombre`, `Apellido_Paterno`, `Apellido_Materno`, `Fecha_Nacimiento`, `Fecha_Ingreso`,
        `Fk_Id_CatRegimen`, `Fk_Id_CatPuesto`, `Fk_Id_CatCT`, `Fk_Id_CatDep`, `Fk_Id_CatRegion`, `Fk_Id_CatGeren`,
        `Nivel`, `Clasificacion`
    INTO 
        v_Nombre_Act, v_Paterno_Act, v_Materno_Act, v_Nacim_Act, v_Ingre_Act,
        v_Regimen_Act, v_Puesto_Act, v_CT_Act, v_Dep_Act, v_Region_Act, v_Geren_Act,
        v_Nivel_Act, v_Clasif_Act
    FROM `Info_Personal`
    WHERE `Id_InfoPersonal` = v_Id_InfoPersonal
    FOR UPDATE;

    /* ============================================================================================
       BLOQUE 5: MOTOR DE DETECCIÓN DE CAMBIOS (GRANULARIDAD)
       Compara Snapshot vs Inputs. Si hay diferencias, acumula el nombre del campo para el feedback.
       ============================================================================================ */
    
    /* 5.1 Credenciales y Seguridad [ADMIN POWER] */
    IF NOT (v_Ficha_Act <=> _Ficha) THEN SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Ficha, '); END IF;
    IF NOT (v_Email_Act <=> _Email) THEN SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Email, '); END IF;
    IF NOT (v_Rol_Act <=> _Id_Rol)  THEN SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Rol de Sistema, '); END IF;
    IF NOT (v_Foto_Act <=> _Url_Foto) THEN SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Foto de Perfil, '); END IF;
    
    /* ** Detección especial de Contraseña [ADMIN POWER] ** */
    /* Si v_Pass_Norm tiene valor, significa que el Admin quiere resetearla. Eso es un cambio explícito. */
    IF v_Pass_Norm IS NOT NULL THEN
        SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Contraseña (Reset), ');
    END IF;

    /* 5.2 Datos Personales */
    IF NOT (v_Nombre_Act <=> _Nombre) OR NOT (v_Paterno_Act <=> _Apellido_Paterno) OR 
       NOT (v_Materno_Act <=> _Apellido_Materno) OR NOT (v_Nacim_Act <=> _Fecha_Nacimiento) THEN
        SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Datos Personales, ');
    END IF;

    IF NOT (v_Ingre_Act <=> _Fecha_Ingreso) THEN SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Fecha Ingreso, '); END IF;

    /* 5.3 Datos Laborales */
    IF NOT (v_Regimen_Act <=> _Id_Regimen) OR NOT (v_Region_Act <=> _Id_Region) OR
       NOT (v_Puesto_Act <=> v_Id_Puesto_Norm) OR NOT (v_CT_Act <=> v_Id_CT_Norm) OR
       NOT (v_Dep_Act <=> v_Id_Dep_Norm) OR NOT (v_Geren_Act <=> v_Id_Gerencia_Norm) OR
       NOT (v_Nivel_Act <=> _Nivel) OR NOT (v_Clasif_Act <=> _Clasificacion) THEN
       
       SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Adscripción Laboral, ');
    END IF;

    /* ============================================================================================
       BLOQUE 6: VERIFICACIÓN DE IDEMPOTENCIA
       Si el acumulador sigue vacío, significa que el usuario guardó sin tocar nada.
       ============================================================================================ */
    IF v_Cambios_Detectados = '' THEN
        COMMIT; 
        SELECT 'No se detectaron cambios en el expediente.' AS Mensaje, _Id_Usuario_Objetivo AS Id_Usuario, 'SIN_CAMBIOS' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* ============================================================================================
       BLOQUE 7: VALIDACIONES DE NEGOCIO (POST-LOCK)
       Estas validaciones son 100% fiables porque tenemos el registro bloqueado.
       ============================================================================================ */

    /* 7.1 Colisión de Ficha (Excluyendo al usuario objetivo) */
    IF LOCATE('Ficha', v_Cambios_Detectados) > 0 THEN
        SELECT `Id_Usuario` INTO v_Id_Duplicado 
        FROM `Usuarios` WHERE `Ficha` = _Ficha AND `Id_Usuario` <> _Id_Usuario_Objetivo LIMIT 1;
        
        IF v_Id_Duplicado IS NOT NULL THEN
            ROLLBACK;
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409]: La Ficha asignada ya pertenece a otro usuario.';
        END IF;
    END IF;

    /* 7.2 Colisión de Email (Excluyendo al usuario objetivo) - [ADMIN POWER CHECK] */
    IF LOCATE('Email', v_Cambios_Detectados) > 0 THEN
        SELECT `Id_Usuario` INTO v_Id_Duplicado 
        FROM `Usuarios` WHERE `Email` = _Email AND `Id_Usuario` <> _Id_Usuario_Objetivo LIMIT 1;
        
        IF v_Id_Duplicado IS NOT NULL THEN
            ROLLBACK;
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409]: El Email asignado ya pertenece a otro usuario.';
        END IF;
    END IF;

    /* 7.3 Vigencia de Catálogos (Validación Manual para Feedback) */
    
    /* Rol (Mandatory) */
    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Roles` WHERE `Id_Rol` = _Id_Rol;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: El Rol seleccionado no existe o está inactivo.'; END IF;

    /* Laborales (Mandatory) */
    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Regimenes_Trabajo` WHERE `Id_CatRegimen` = _Id_Regimen;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Régimen no válido.'; END IF;

    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Regiones_Trabajo` WHERE `Id_CatRegion` = _Id_Region;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Región no válida.'; END IF;

    /* Laborales (Optional - Solo si traen datos) */
    IF v_Id_Puesto_Norm IS NOT NULL THEN
        SELECT `Activo` INTO v_Es_Activo FROM `Cat_Puestos_Trabajo` WHERE `Id_CatPuesto` = v_Id_Puesto_Norm;
        IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Puesto inactivo.'; END IF;
    END IF;

    IF v_Id_CT_Norm IS NOT NULL THEN
        SELECT `Activo` INTO v_Es_Activo FROM `Cat_Centros_Trabajo` WHERE `Id_CatCT` = v_Id_CT_Norm;
        IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Centro de Trabajo inactivo.'; END IF;
    END IF;

    IF v_Id_Dep_Norm IS NOT NULL THEN
        SELECT `Activo` INTO v_Es_Activo FROM `Cat_Departamentos` WHERE `Id_CatDep` = v_Id_Dep_Norm;
        IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Departamento inactivo.'; END IF;
    END IF;

    IF v_Id_Gerencia_Norm IS NOT NULL THEN
        SELECT `Activo` INTO v_Es_Activo FROM `Cat_Gerencias_Activos` WHERE `Id_CatGeren` = v_Id_Gerencia_Norm;
        IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VIGENCIA: Gerencia inactiva.'; END IF;
    END IF;

    /* ============================================================================================
       BLOQUE 8: PERSISTENCIA (UPDATE)
       ============================================================================================ */
    
    /* 8.1 Actualizar Info Personal (Datos Humanos) */
    UPDATE `Info_Personal`
    SET 
        `Nombre` = _Nombre, `Apellido_Paterno` = _Apellido_Paterno, `Apellido_Materno` = _Apellido_Materno,
        `Fecha_Nacimiento` = _Fecha_Nacimiento, `Fecha_Ingreso` = _Fecha_Ingreso,
        `Fk_Id_CatRegimen` = _Id_Regimen, `Fk_Id_CatPuesto` = v_Id_Puesto_Norm,
        `Fk_Id_CatCT` = v_Id_CT_Norm, `Fk_Id_CatDep` = v_Id_Dep_Norm,
        `Fk_Id_CatRegion` = _Id_Region, `Fk_Id_CatGeren` = v_Id_Gerencia_Norm,
        `Nivel` = _Nivel, `Clasificacion` = _Clasificacion,
        /* Auditoría Cruzada: Registramos al Admin como responsable */
        `Fk_Id_Usuario_Updated_By` = _Id_Admin_Ejecutor,
        `updated_at` = NOW()
    WHERE `Id_InfoPersonal` = v_Id_InfoPersonal;

    /* 8.2 Actualizar Usuario (Credenciales y Seguridad) [ADMIN POWER] */
    UPDATE `Usuarios`
    SET
        `Ficha` = _Ficha,
        `Email` = _Email,           -- Admin SÍ puede corregir email
        `Foto_Perfil_Url` = _Url_Foto,
        `Fk_Rol` = _Id_Rol,         -- Admin SÍ puede cambiar roles
        
        /* Reset de Password Condicional: Usamos COALESCE para preservar si es NULL */
        `Contraseña` = COALESCE(v_Pass_Norm, `Contraseña`),
        
        `Fk_Usuario_Updated_By` = _Id_Admin_Ejecutor,
        `updated_at` = NOW()
    WHERE `Id_Usuario` = _Id_Usuario_Objetivo;

    /* ============================================================================================
       BLOQUE 9: CONFIRMACIÓN Y RESPUESTA
       ============================================================================================ */
    COMMIT;

    /* Feedback Granular */
    SELECT 
        CONCAT('ÉXITO: Se ha actualizado: ', TRIM(TRAILING ', ' FROM v_Cambios_Detectados), '.') AS Mensaje,
        _Id_Usuario_Objetivo AS Id_Usuario,
        'ACTUALIZADA' AS Accion;

END$$

DELIMITER ;

/* ============================================================================================
   PROCEDIMIENTO: SP_ActualizarCredencialesPropio
   ============================================================================================

   --------------------------------------------------------------------------------------------
   I. PROPÓSITO Y OBJETIVO DE NEGOCIO (THE "WHAT")
   --------------------------------------------------------------------------------------------
   [QUÉ ES]: 
   Es el motor transaccional especializado para la gestión autónoma de credenciales de acceso 
   (Self-Service Security). Permite al usuario modificar sus llaves digitales sin intervención 
   administrativa.

   [ALCANCE OPERATIVO]:
   Gestiona la mutación de los dos vectores de autenticación:
     1. Login (Email): Identificador único de acceso.
     2. Secreto (Contraseña): Hash criptográfico de seguridad.

   [PRE-REQUISITO DE ARQUITECTURA]:
   Este SP asume que la capa de aplicación (Backend/API) YA realizó la validación de la 
   "Contraseña Anterior" antes de invocar este procedimiento. La base de datos confía en que 
   la solicitud es legítima y se limita a persistir los cambios y validar unicidad.

   --------------------------------------------------------------------------------------------
   II. REGLAS DE NEGOCIO (BUSINESS RULES)
   --------------------------------------------------------------------------------------------
   [RN-01] MODIFICACIÓN ATÓMICA Y PARCIAL (FLEXIBILIDAD):
      - El diseño soporta cambios independientes:
         * Solo Email (Password NULL).
         * Solo Password (Email NULL).
         * Ambos simultáneamente.
      - Si un parámetro llega NULL o vacío, se preserva el valor actual en la BD.

   [RN-02] BLINDAJE DE IDENTIDAD (ANTI-COLLISION):
      - Si el usuario intenta cambiar su Email, se verifica estrictamente que el nuevo correo 
        no pertenezca a otro usuario (`Id != Me`).
      - Si hay conflicto, se rechaza la operación con un error 409 controlado.

   [RN-03] IDEMPOTENCIA DE SEGURIDAD (OPTIMIZACIÓN):
      - Si el usuario envía datos idénticos a los actuales (mismo Email, mismo Hash), 
        el sistema detecta la redundancia, reporta éxito ("Sin Cambios") y no toca el disco.

   --------------------------------------------------------------------------------------------
   III. ESPECIFICACIÓN TÉCNICA
   --------------------------------------------------------------------------------------------
   - TIPO: Transacción ACID con Aislamiento de Lectura.
   - BLOQUEO: Pesimista (`FOR UPDATE`) sobre la fila del usuario para evitar condiciones de carrera.
   - TRAZABILIDAD: El usuario se registra a sí mismo como el autor del cambio (`Updated_By`).
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_ActualizarCredencialesPropio`$$

CREATE PROCEDURE `SP_ActualizarCredencialesPropio`(
    /* Contexto de Sesión */
    IN _Id_Usuario_Sesion  INT,          -- [TOKEN] Quién solicita el cambio

    /* Nuevas Credenciales (Opcionales) */
    IN _Nuevo_Email        VARCHAR(255), -- [LOGIN] NULL si no se quiere cambiar
    IN _Nueva_Contrasena   VARCHAR(255)  -- [HASH] NULL si no se quiere cambiar
)
THIS_PROC: BEGIN
    
    /* ========================================================================================
       BLOQUE 0: VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Contenedores para almacenar el estado actual y evaluar cambios.
       ======================================================================================== */
    DECLARE v_Email_Act    VARCHAR(255);
    DECLARE v_Pass_Act     VARCHAR(255);
    DECLARE v_Id_Duplicado INT;
    
    /* Variables Normalizadas */
    DECLARE v_Email_Norm   VARCHAR(255);
    DECLARE v_Pass_Norm    VARCHAR(255);

    /* Acumulador de Feedback */
    DECLARE v_Cambios_Detectados VARCHAR(255) DEFAULT '';

    /* ========================================================================================
       BLOQUE 1: HANDLERS (MECANISMOS DE DEFENSA)
       ======================================================================================== */
    
    /* [1.1] Handler para colisión de Email (Unique Key)
       Objetivo: Capturar si otro usuario registró el mismo correo en el último milisegundo. */
    DECLARE EXIT HANDLER FOR 1062
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE CONFLICTO [409]: El correo electrónico ingresado ya está siendo usado por otro usuario.';
    END;

    /* [1.2] Handler Genérico (Crash Safety) */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y NORMALIZACIÓN (INPUT HYGIENE)
       ======================================================================================== */
    
    /* 2.1 Integridad de Sesión */
    IF _Id_Usuario_Sesion IS NULL OR _Id_Usuario_Sesion <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SEGURIDAD [401]: Sesión no válida.';
    END IF;

    /* 2.2 Normalización de Inputs
       Convertimos cadenas vacías o espacios en NULL para que la lógica COALESCE funcione. */
    SET v_Email_Norm = NULLIF(TRIM(_Nuevo_Email), '');
    SET v_Pass_Norm  = NULLIF(TRIM(_Nueva_Contrasena), '');

    /* 2.3 Validación de Propósito
       Evitamos transacciones vacías. Al menos un dato debe venir para actualizar. */
    IF v_Email_Norm IS NULL AND v_Pass_Norm IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: Debe proporcionar al menos un dato para actualizar (Email o Contraseña).';
    END IF;

    /* ========================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       ======================================================================================== */
    START TRANSACTION;

    /* Bloqueo de Fila: Nadie puede modificar esta cuenta mientras cambiamos las llaves.
       Solo leemos las columnas necesarias para comparar. */
    SELECT `Email`, `Contraseña`
    INTO v_Email_Act, v_Pass_Act
    FROM `Usuarios`
    WHERE `Id_Usuario` = _Id_Usuario_Sesion
    FOR UPDATE;

    /* Safety Check: Si el usuario fue borrado justo antes de entrar aquí */
    IF v_Email_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [404]: La cuenta de usuario no existe.';
    END IF;

    /* ========================================================================================
       BLOQUE 4: DETECCIÓN DE CAMBIOS Y VALIDACIÓN DE UNICIDAD
       ======================================================================================== */

    /* 4.1 Análisis de Email */
    IF v_Email_Norm IS NOT NULL THEN
        IF v_Email_Norm <> v_Email_Act THEN
            /* Cambio detectado: Verificamos disponibilidad */
            SELECT `Id_Usuario` INTO v_Id_Duplicado 
            FROM `Usuarios` 
            WHERE `Email` = v_Email_Norm AND `Id_Usuario` <> _Id_Usuario_Sesion 
            LIMIT 1;

            IF v_Id_Duplicado IS NOT NULL THEN
                ROLLBACK;
                SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409]: El nuevo correo electrónico ya pertenece a otra cuenta.';
            END IF;

            SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Correo Electrónico, ');
        ELSE
            /* Falso Positivo: El usuario envió el mismo correo que ya tiene. Lo anulamos. */
            SET v_Email_Norm = NULL; 
        END IF;
    END IF;

    /* 4.2 Análisis de Contraseña */
    IF v_Pass_Norm IS NOT NULL THEN
        /* Comparamos el hash nuevo contra el actual. */
        IF v_Pass_Norm <> v_Pass_Act THEN
            SET v_Cambios_Detectados = CONCAT(v_Cambios_Detectados, 'Contraseña, ');
        ELSE
            SET v_Pass_Norm = NULL;
        END IF;
    END IF;

    /* ========================================================================================
       BLOQUE 5: VERIFICACIÓN DE IDEMPOTENCIA
       Si no hubo cambios reales, salimos sin tocar disco.
       ======================================================================================== */
    IF v_Cambios_Detectados = '' THEN
        COMMIT;
        SELECT 'No se detectaron cambios en las credenciales.' AS Mensaje, _Id_Usuario_Sesion AS Id_Usuario, 'SIN_CAMBIOS' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* ========================================================================================
       BLOQUE 6: PERSISTENCIA (UPDATE)
       ======================================================================================== */
    
    UPDATE `Usuarios`
    SET 
        /* Si v_Email_Norm es NULL (porque no cambió o no se envió), COALESCE mantiene el actual */
        `Email` = COALESCE(v_Email_Norm, `Email`),
        
        /* Si v_Pass_Norm es NULL, COALESCE mantiene la actual */
        `Contraseña` = COALESCE(v_Pass_Norm, `Contraseña`),

        /* Auditoría: El usuario modificó su propia seguridad */
        `Fk_Usuario_Updated_By` = _Id_Usuario_Sesion,
        `updated_at` = NOW()
    WHERE `Id_Usuario` = _Id_Usuario_Sesion;

    /* ========================================================================================
       BLOQUE 7: RESPUESTA DINÁMICA
       ======================================================================================== */
    COMMIT;

    /* Ejemplo Salida: "SEGURIDAD ACTUALIZADA: Se modificó: Correo Electrónico, Contraseña." */
    SELECT 
        CONCAT('SEGURIDAD ACTUALIZADA: Se modificó: ', TRIM(TRAILING ', ' FROM v_Cambios_Detectados), '.') AS Mensaje,
        _Id_Usuario_Sesion AS Id_Usuario,
        'ACTUALIZADA' AS Accion;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarTipoInstruccion
   ============================================================================================
   
   1. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   -------------------------------------------------------
   Este procedimiento gestiona la modificación de los atributos descriptivos de un "Tipo de Instrucción"
   (`Cat_Tipos_Instruccion_Cap`) existente en el catálogo pedagógico.
   
   No es un simple UPDATE; es un motor transaccional diseñado para operar en entornos de alta 
   concurrencia, garantizando las propiedades ACID y evitando la corrupción de datos por duplicidad.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ---------------------------------------------------
   A) OBLIGATORIEDAD DE CAMPOS:
      - Regla: "Todo o Nada". El Nombre es MANDATORIO.
      - Justificación: Un tipo de instrucción sin nombre rompe la integridad visual de los reportes.

   B) UNICIDAD GLOBAL (EXCLUSIÓN PROPIA):
      - Se verifica que el nuevo Nombre no pertenezca a OTRO tipo (`Id <> _Id_Tipo`).
      - Nota: Es perfectamente legal que el registro se llame igual a sí mismo (ej: cambiar solo la descripción).

   3. ARQUITECTURA DE CONCURRENCIA (PESSIMISTIC LOCKING PATTERN)
   -------------------------------------------------------------
   Para prevenir la "Edición Fantasma" (Lost Update) donde dos administradores editan el mismo
   registro al mismo tiempo:
   
      - FASE 1 (Bloqueo): Al inicio de la transacción, ejecutamos `SELECT ... FOR UPDATE` sobre el ID.
      - FASE 2 (Edición): La fila queda "congelada" para nuestra sesión. Nadie más puede escribir en ella.
      - FASE 3 (Liberación): Al hacer COMMIT, se libera el recurso.
   
   4. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   ------------------------------------------
   - Antes de escribir en disco, el SP compara el estado actual (`Snapshot`) contra los nuevos valores.
   - Si son idénticos, retorna éxito ('SIN_CAMBIOS') inmediatamente.
   - Beneficio: Evita escrituras innecesarias en el Transaction Log y mantiene intacta la fecha `updated_at`.

   5. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   ---------------------------------------
   Retorna un resultset con:
      - Mensaje (VARCHAR): Feedback descriptivo.
      - Accion (VARCHAR): 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
      - Id_Tipo (INT): Identificador del recurso manipulado.
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarTipoInstruccion`$$

CREATE PROCEDURE `SP_EditarTipoInstruccion`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Recibimos los datos crudos del formulario de edición.
       ----------------------------------------------------------------- */
    IN _Id_Tipo     INT,           -- OBLIGATORIO: ID del registro a modificar (PK)
    IN _Nombre      VARCHAR(255),  -- OBLIGATORIO: Nuevo Nombre (ej: 'Teórico-Práctico')
    IN _Descripcion VARCHAR(255)   -- OPCIONAL: Descripción detallada
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Inicializar los contenedores que gestionarán la lógica del procedimiento.
       ================================================================================================ */
    
    /* [Snapshots]: Almacenan el estado actual del registro antes de la edición (para comparar cambios) */
    DECLARE v_Nom_Act  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Desc_Act VARCHAR(255) DEFAULT NULL;

    /* [IDs de Conflicto]: Identificadores de filas que podrían chocar con nuestros nuevos datos */
    DECLARE v_Id_Conflicto INT DEFAULT NULL; 

    /* [Bandera de Control]: Semáforo para detectar errores de concurrencia (Error 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ================================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Garantizar una salida limpia ante errores técnicos o de concurrencia.
       ================================================================================================ */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Objetivo: Capturar colisiones de Unique Key en el último milisegundo (Race Condition).
       Acción: No abortamos. Encendemos la bandera v_Dup = 1 para manejar el conflicto controladamente. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos técnicos graves (Desconexión, Disco lleno, Sintaxis).
       Acción: Abortar inmediatamente (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST)
       Propósito: Rechazar datos inválidos antes de consumir recursos de transacción.
       ================================================================================================ */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios basura. Si queda vacío, se convierte a NULL. */
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD
       El formulario exige que los campos críticos existan. */
    
    IF _Id_Tipo IS NULL OR _Id_Tipo <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: Identificador de Tipo inválido.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE es obligatorio para la edición.';
    END IF;
    
    /* ================================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       Propósito: Adquirir exclusividad sobre el registro a editar.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: LEER Y BLOQUEAR EL REGISTRO ACTUAL
       
       Objetivo: Obtener los valores actuales y congelar la fila.
       Mecánica: `FOR UPDATE` asegura que si otro admin intenta editar esto al mismo tiempo,
       deberá esperar a que terminemos.
       ------------------------------------------------------------------------------------------------ */
    
    SELECT `Nombre`, `Descripcion` 
    INTO v_Nom_Act, v_Desc_Act
    FROM `Cat_Tipos_Instruccion_Cap` 
    WHERE `Id_CatTipoInstCap` = _Id_Tipo
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* Safety Check: Si al bloquear descubrimos que el registro fue borrado por otro usuario */
    IF v_Nom_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [410]: El registro desapareció durante la transacción (fue eliminado externamente).';
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       
       Objetivo: Evitar escrituras si el usuario guardó lo mismo.
       Lógica: Comparamos si los datos nuevos son matemáticamente iguales a los actuales. 
       Usamos <=> (Null-Safe Equality) para manejar correctamente los NULLs en la descripción.
       ------------------------------------------------------------------------------------------------ */
    IF (_Nombre = v_Nom_Act) 
       AND (_Descripcion <=> v_Desc_Act) THEN
        
        COMMIT; -- Liberamos locks inmediatamente
        
        /* Retorno anticipado para ahorrar I/O y notificar al Frontend */
        SELECT 'AVISO: No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion, _Id_Tipo AS Id_Tipo;
        LEAVE THIS_PROC;
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.3: VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       
       Objetivo: Verificar si existen duplicados REALES en OTROS registros.
       Regla: `Id <> _Id_Tipo` (Excluirme a mí mismo).
       ------------------------------------------------------------------------------------------------ */
    
    /* Validación por NOMBRE */
    SET v_Id_Conflicto = NULL;
    
    SELECT `Id_CatTipoInstCap` INTO v_Id_Conflicto 
    FROM `Cat_Tipos_Instruccion_Cap` 
    WHERE `Nombre` = _Nombre 
      AND `Id_CatTipoInstCap` <> _Id_Tipo 
    LIMIT 1
    FOR UPDATE; -- Bloqueamos también al posible conflicto para evitar carreras
    
    IF v_Id_Conflicto IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya pertenece a otro Tipo de Instrucción.';
    END IF;

    /* ================================================================================================
       BLOQUE 5: PERSISTENCIA Y FINALIZACIÓN (UPDATE)
       Propósito: Aplicar los cambios una vez superadas todas las barreras de seguridad.
       ================================================================================================ */
    
    SET v_Dup = 0; -- Resetear bandera de error antes de escribir

    UPDATE `Cat_Tipos_Instruccion_Cap`
    SET `Nombre`      = _Nombre,
        `Descripcion` = _Descripcion,
        `updated_at`  = NOW() -- Auditoría automática
    WHERE `Id_CatTipoInstCap` = _Id_Tipo;

    /* ================================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       Propósito: Gestionar el caso extremo donde un insert fantasma ocurre justo antes del update.
       ================================================================================================ */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico para el usuario */
        SET v_Id_Conflicto = NULL;

        SELECT `Id_CatTipoInstCap` INTO v_Id_Conflicto 
        FROM `Cat_Tipos_Instruccion_Cap` 
        WHERE `Nombre` = _Nombre 
          AND `Id_CatTipoInstCap` <> _Id_Tipo 
        LIMIT 1;

        SELECT 'Error de Concurrencia: Conflicto detectado al guardar.' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               'NOMBRE' AS Campo, 
               v_Id_Conflicto AS Id_Conflicto;
        LEAVE THIS_PROC;
    END IF;

    /* ================================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       Propósito: Confirmar la transacción y notificar al cliente.
       ================================================================================================ */
    COMMIT;
    
    SELECT 'ÉXITO: Tipo de Instrucción actualizado correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Tipo AS Id_Tipo;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_EditarTemaCapacitacion
   ============================================================================================

   --------------------------------------------------------------------------------------------
   I. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------------------------------------------------------------
   [QUÉ ES]:
   Es el motor transaccional encargado de modificar los atributos técnicos y pedagógicos de un
   "Tema de Capacitación" (Curso) existente en el catálogo.

   [ALCANCE]:
   Permite la actualización de:
     - Identidad: Código (Clave Única) y Nombre (Clave Semántica).
     - Contenido: Descripción y Duración (Carga Horaria).
     - Clasificación: Reasignación a otro "Tipo de Instrucción" (Padre).

   --------------------------------------------------------------------------------------------
   II. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   --------------------------------------------------------------------------------------------
   [RN-01] INTEGRIDAD DE DATOS (MANDATORY FIELDS):
      - Regla: "Todo o Nada" (excepto descripción).
      - Campos Obligatorios: Código, Nombre, Duración (>0) y Tipo de Instrucción.
      - Justificación: Un curso sin código o con duración cero es inoperable para la logística.

   [RN-02] IDENTIDAD UNÍVOCA (EXCLUSIÓN PROPIA):
      - Regla: El nuevo Código o Nombre no deben chocar con OTROS registros (`Id <> _Id_Tema`).
      - Excepción: Se permite que el registro coincida consigo mismo (Idempotencia).

   [RN-03] INTEGRIDAD JERÁRQUICA (PARENT VALIDATION):
      - Si se cambia el `Id_TipoInst`, el nuevo Padre debe existir y estar ACTIVO (`Activo=1`).
      - Esto evita mover un curso activo hacia una categoría obsoleta o eliminada.

   --------------------------------------------------------------------------------------------
   III. ARQUITECTURA DE CONCURRENCIA (PESSIMISTIC LOCKING PATTERN)
   --------------------------------------------------------------------------------------------
   Para prevenir la corrupción de datos y la "Edición Fantasma" (Lost Update):

      - FASE 1 (Bloqueo): Al inicio, ejecutamos `SELECT ... FOR UPDATE` sobre el ID del Tema.
      - FASE 2 (Congelamiento): La fila queda bloqueada para esta sesión. Nadie más puede
        editarla o eliminarla hasta que terminemos.
      - FASE 3 (Validación Segura): Al tener el bloqueo, nuestras verificaciones de duplicidad
        son 100% fiables (excepto inserciones fantasma milimétricas, cubiertas por el Handler 1062).

   --------------------------------------------------------------------------------------------
   IV. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   --------------------------------------------------------------------------------------------
   [MOTOR DE DETECCIÓN DE CAMBIOS]:
   - Antes de escribir en disco, comparamos el "Snapshot" (Estado Actual) vs "Inputs" (Nuevos).
   - Si no hay diferencias matemáticas, retornamos éxito ('SIN_CAMBIOS') inmediatamente.
   - Beneficio: Ahorro de I/O y preservación de la fecha de auditoría `updated_at`.

   --------------------------------------------------------------------------------------------
   V. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   --------------------------------------------------------------------------------------------
   Retorna un resultset con:
      - Mensaje: Feedback descriptivo.
      - Accion: 'ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO'.
      - Id_Tema: El identificador del recurso.
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarTemaCapacitacion`$$

CREATE PROCEDURE `SP_EditarTemaCapacitacion`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Recibimos los datos crudos del formulario.
       ----------------------------------------------------------------- */
    IN _Id_Tema         INT,           -- [OBLIGATORIO] PK del registro a editar
    IN _Codigo          VARCHAR(50),   -- [OBLIGATORIO] Nueva clave única
    IN _Nombre          VARCHAR(255),  -- [OBLIGATORIO] Nuevo nombre único
    IN _Descripcion     VARCHAR(255),  -- [OPCIONAL] Nueva descripción
    IN _Duracion_Horas  SMALLINT,      -- [OBLIGATORIO] Nueva duración (> 0)
    IN _Id_TipoInst     INT            -- [OBLIGATORIO] Nuevo Padre (FK)
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Inicializar los contenedores que gestionarán la lógica del procedimiento.
       ================================================================================================ */
    
    /* [Snapshots]: Estado actual del registro antes de la edición */
    DECLARE v_Cod_Act     VARCHAR(50);
    DECLARE v_Nom_Act     VARCHAR(255);
    DECLARE v_Desc_Act    VARCHAR(255);
    DECLARE v_Dur_Act     SMALLINT;
    DECLARE v_Tipo_Act    INT;
    
    /* [Variables de Validación Jerárquica] */
    DECLARE v_Padre_Activo TINYINT(1);

    /* [Variables de Conflicto]: Para pre-checks de duplicidad */
    DECLARE v_Id_Conflicto INT DEFAULT NULL;
    DECLARE v_Campo_Error  VARCHAR(20) DEFAULT NULL;

    /* [Bandera de Control]: Semáforo para detectar errores de concurrencia (Error 1062) */
    DECLARE v_Dup          TINYINT(1) DEFAULT 0;

    /* ================================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Garantizar una salida limpia ante errores técnicos o de concurrencia.
       ================================================================================================ */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Objetivo: Capturar colisiones de Unique Key en el último milisegundo (Race Condition).
       Acción: No abortamos. Encendemos la bandera v_Dup = 1 para manejar el conflicto controladamente. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos técnicos graves (Desconexión, Disco lleno).
       Acción: Abortar inmediatamente (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST)
       Propósito: Rechazar datos inválidos antes de consumir recursos de transacción.
       ================================================================================================ */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF) */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');
    
    /* Sanitización numérica: Convertir NULL o negativos a 0 para validación lógica */
    SET _Duracion_Horas = IFNULL(_Duracion_Horas, 0);

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (REGLAS DE NEGOCIO) */
    
    IF _Id_Tema IS NULL OR _Id_Tema <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: Identificador de Tema inválido.';
    END IF;

    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE es obligatorio.';
    END IF;

    IF _Duracion_Horas <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: La DURACIÓN debe ser mayor a 0 horas.';
    END IF;

    IF _Id_TipoInst IS NULL OR _Id_TipoInst <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: Debe seleccionar un TIPO DE INSTRUCCIÓN válido.';
    END IF;

    /* ================================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       Propósito: Adquirir exclusividad sobre el registro a editar.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: LEER Y BLOQUEAR EL REGISTRO ACTUAL
       
       Objetivo: Obtener los valores actuales y congelar la fila.
       Mecánica: `FOR UPDATE` asegura que si otro admin intenta editar esto al mismo tiempo,
       deberá esperar a que terminemos.
       ------------------------------------------------------------------------------------------------ */
    SELECT 
        `Codigo`, `Nombre`, `Descripcion`, `Duracion_Horas`, `Fk_Id_CatTipoInstCap`
    INTO 
        v_Cod_Act, v_Nom_Act, v_Desc_Act, v_Dur_Act, v_Tipo_Act
    FROM `Cat_Temas_Capacitacion`
    WHERE `Id_Cat_TemasCap` = _Id_Tema
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* Safety Check: Si al bloquear descubrimos que el registro fue borrado por otro usuario */
    IF v_Cod_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [404]: El Tema que intenta editar ya no existe (fue eliminado externamente).';
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       
       Objetivo: Evitar escrituras si el usuario guardó lo mismo.
       Lógica: Comparamos campo por campo. Usamos `<=>` para la descripción (nullable).
       ------------------------------------------------------------------------------------------------ */
    IF (v_Cod_Act = _Codigo) 
       AND (v_Nom_Act = _Nombre) 
       AND (v_Desc_Act <=> _Descripcion)
       AND (v_Dur_Act = _Duracion_Horas)
       AND (v_Tipo_Act = _Id_TipoInst) THEN
        
        COMMIT; -- Liberamos locks inmediatamente
        
        /* Retorno anticipado para ahorrar I/O y notificar al Frontend */
        SELECT 'AVISO: No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion, _Id_Tema AS Id_Tema;
        LEAVE THIS_PROC;
    END IF;

    /* ================================================================================================
       BLOQUE 4: VALIDACIONES DE NEGOCIO (BAJO PROTECCIÓN DE LOCKS)
       ================================================================================================ */

    /* 4.1 VALIDACIÓN JERÁRQUICA (SOLO SI CAMBIÓ EL PADRE)
       Si el usuario seleccionó un Tipo de Instrucción diferente al actual, verificamos que sea válido y activo. */
    IF v_Tipo_Act <> _Id_TipoInst THEN
        SET v_Padre_Activo = NULL;
        
        /* Consultamos el catálogo padre */
        SELECT `Activo` INTO v_Padre_Activo
        FROM `Cat_Tipos_Instruccion_Cap`
        WHERE `Id_CatTipoInstCap` = _Id_TipoInst; 

        IF v_Padre_Activo IS NULL THEN
             ROLLBACK;
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD [404]: El nuevo Tipo de Instrucción seleccionado no existe.';
        END IF;

        IF v_Padre_Activo = 0 THEN
             ROLLBACK;
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [409]: El nuevo Tipo de Instrucción seleccionado está INACTIVO.';
        END IF;
    END IF;

    /* 4.2 VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       Verificamos si existen duplicados REALES. Al tener el registro propio bloqueado, 
       validamos contra el resto de la tabla. */
    
    /* A) Validación por CÓDIGO (si cambió) */
    IF v_Cod_Act <> _Codigo THEN
        SET v_Id_Conflicto = NULL;
        SELECT `Id_Cat_TemasCap` INTO v_Id_Conflicto
        FROM `Cat_Temas_Capacitacion`
        WHERE `Codigo` = _Codigo AND `Id_Cat_TemasCap` <> _Id_Tema
        LIMIT 1
        FOR UPDATE; -- Bloqueo preventivo al conflicto

        IF v_Id_Conflicto IS NOT NULL THEN
            ROLLBACK;
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya pertenece a otro Tema.';
        END IF;
    END IF;

    /* B) Validación por NOMBRE (si cambió) */
    IF v_Nom_Act <> _Nombre THEN
        SET v_Id_Conflicto = NULL;
        SELECT `Id_Cat_TemasCap` INTO v_Id_Conflicto
        FROM `Cat_Temas_Capacitacion`
        WHERE `Nombre` = _Nombre AND `Id_Cat_TemasCap` <> _Id_Tema
        LIMIT 1
        FOR UPDATE; -- Bloqueo preventivo al conflicto

        IF v_Id_Conflicto IS NOT NULL THEN
            ROLLBACK;
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya pertenece a otro Tema.';
        END IF;
    END IF;

    /* ================================================================================================
       BLOQUE 5: PERSISTENCIA Y FINALIZACIÓN (UPDATE)
       Propósito: Aplicar los cambios una vez superadas todas las barreras de seguridad.
       ================================================================================================ */
    
    SET v_Dup = 0; -- Resetear bandera de error antes de escribir

    UPDATE `Cat_Temas_Capacitacion`
    SET 
        `Codigo`               = _Codigo,
        `Nombre`               = _Nombre,
        `Descripcion`          = _Descripcion,
        `Duracion_Horas`       = _Duracion_Horas,
        `Fk_Id_CatTipoInstCap` = _Id_TipoInst,
        `updated_at`           = NOW() -- Auditoría automática
    WHERE 
        `Id_Cat_TemasCap` = _Id_Tema;

    /* ================================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       Propósito: Gestionar el caso extremo donde un insert fantasma ocurre justo antes del update.
       ================================================================================================ */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico Post-Mortem para el usuario */
        SET v_Campo_Error = 'DESCONOCIDO';
        SET v_Id_Conflicto = NULL;

        /* ¿Fue conflicto de Código? */
        SELECT `Id_Cat_TemasCap` INTO v_Id_Conflicto FROM `Cat_Temas_Capacitacion` 
        WHERE `Codigo` = _Codigo AND `Id_Cat_TemasCap` <> _Id_Tema LIMIT 1;
        
        IF v_Id_Conflicto IS NOT NULL THEN
            SET v_Campo_Error = 'CODIGO';
        ELSE
            /* Entonces fue conflicto de Nombre */
            SELECT `Id_Cat_TemasCap` INTO v_Id_Conflicto FROM `Cat_Temas_Capacitacion` 
            WHERE `Nombre` = _Nombre AND `Id_Cat_TemasCap` <> _Id_Tema LIMIT 1;
            SET v_Campo_Error = 'NOMBRE';
        END IF;

        SELECT 'Error de Concurrencia: Conflicto detectado al guardar.' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo, 
               v_Id_Conflicto AS Id_Conflicto;
        LEAVE THIS_PROC;
    END IF;

    /* ================================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       Propósito: Confirmar la transacción y notificar al cliente.
       ================================================================================================ */
    COMMIT;
    
    SELECT 'ÉXITO: Tema actualizado correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Tema AS Id_Tema;

END$$

DELIMITER ;



/* ============================================================================================
   PROCEDIMIENTO: SP_EditarEstatusCapacitacion
   ============================================================================================
   
   --------------------------------------------------------------------------------------------
   I. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------------------------------------------------------------
   [QUÉ ES]:
   Es el motor transaccional blindado encargado de modificar los atributos descriptivos y la
   Lógica de Negocio (`Es_Final`) de un Estatus de Capacitación existente.

   [POR QUÉ ES CRÍTICO]:
   Este catálogo gobierna el comportamiento del sistema. 
   - Modificar un nombre es trivial.
   - Pero modificar la bandera `Es_Final` tiene consecuencias operativas masivas: puede liberar
     o bloquear la edición de miles de cursos e instructores asociados.
   
   Por ello, este SP no es un simple UPDATE. Es una orquestación de bloqueos y validaciones 
   diseñada para operar bajo fuego (alta concurrencia) sin corromper la data.

   --------------------------------------------------------------------------------------------
   II. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   --------------------------------------------------------------------------------------------
   [EL PROBLEMA DE LOS ABRAZOS MORTALES (DEADLOCKS)]:
   Imagina que el Admin A quiere renombrar el estatus 'X' a 'Y', y al mismo tiempo el Admin B
   quiere renombrar el estatus 'Y' a 'X'. 
   Si bloquean los registros en orden diferente, la base de datos mata uno de los procesos.

   [LA SOLUCIÓN MATEMÁTICA]:
   Implementamos el patrón de "Bloqueo Determinístico":
   1. Identificamos todos los IDs involucrados (El que edito + El que tiene el código que quiero + El que tiene el nombre que quiero).
   2. Los ordenamos de MENOR a MAYOR.
   3. Los bloqueamos (`FOR UPDATE`) siguiendo estrictamente ese orden "en fila india".
   Resultado: Cero Deadlocks garantizados.

   --------------------------------------------------------------------------------------------
   III. REGLAS DE BLINDAJE (HARD CONSTRAINTS)
   --------------------------------------------------------------------------------------------
   [RN-01] INTEGRIDAD TOTAL: Código, Nombre y Es_Final son obligatorios.
   [RN-02] EXCLUSIÓN PROPIA: Puedo llamarme igual a mí mismo, pero no igual a mi vecino.
   [RN-03] IDEMPOTENCIA: Si guardas sin cambios, el sistema lo detecta y no toca el disco duro.

   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarEstatusCapacitacion`$$

CREATE PROCEDURE `SP_EditarEstatusCapacitacion`(
    /* -----------------------------------------------------------------
       SECCIÓN DE PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos los datos crudos desde el formulario web.
       ----------------------------------------------------------------- */
    IN _Id_Estatus  INT,           -- [OBLIGATORIO] PK del registro a editar (Target).
    IN _Codigo      VARCHAR(50),   -- [OBLIGATORIO] Nuevo Código (o el mismo).
    IN _Nombre      VARCHAR(255),  -- [OBLIGATORIO] Nuevo Nombre (o el mismo).
    IN _Descripcion VARCHAR(255),  -- [OPCIONAL] Nueva Descripción (Contexto).
    IN _Es_Final    TINYINT(1)     -- [CRÍTICO] 0=Bloqueante (Vivo), 1=Liberador (Finalizado).
)
THIS_PROC: BEGIN

    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Inicializar los contenedores en memoria para la lógica del procedimiento.
       ======================================================================================== */
    
    /* [Snapshots]: Almacenan la "foto" del registro ANTES de editarlo. 
       Vitales para comparar si hubo cambios reales (Idempotencia). */
    DECLARE v_Cod_Act    VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nom_Act    VARCHAR(255) DEFAULT NULL;
    DECLARE v_Desc_Act   VARCHAR(255) DEFAULT NULL;
    DECLARE v_Final_Act  TINYINT(1)   DEFAULT NULL;
    
    /* [IDs de Conflicto]: Identifican a "los otros" registros que podrían estorbar. */
    DECLARE v_Id_Conflicto_Cod INT DEFAULT NULL; -- ¿Quién tiene ya este Código?
    DECLARE v_Id_Conflicto_Nom INT DEFAULT NULL; -- ¿Quién tiene ya este Nombre?
    
    /* --- CORRECCIÓN: SE AGREGA LA VARIABLE FALTANTE PARA EL BLOQUE 6 --- */
    DECLARE v_Id_Conflicto     INT DEFAULT NULL; -- Variable genérica para reportar errores

    /* [Variables de Algoritmo de Bloqueo]: Auxiliares para ordenar y ejecutar los locks. */
    DECLARE v_L1 INT DEFAULT NULL;   -- Candidato 1 a bloquear
    DECLARE v_L2 INT DEFAULT NULL;   -- Candidato 2 a bloquear
    DECLARE v_L3 INT DEFAULT NULL;   -- Candidato 3 a bloquear
    DECLARE v_Min INT DEFAULT NULL;  -- El menor de la ronda actual
    DECLARE v_Existe INT DEFAULT NULL; -- Validación de éxito del lock

    /* [Bandera de Control]: Semáforo para detectar errores de concurrencia (Error 1062). */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* [Variables de Diagnóstico]: Para el análisis Post-Mortem en caso de fallo. */
    DECLARE v_Campo_Error VARCHAR(20) DEFAULT NULL;
    DECLARE v_Id_Error    INT DEFAULT NULL;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (SISTEMA DE DEFENSA)
       Propósito: Capturar excepciones técnicas y convertirlas en respuestas controladas.
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Objetivo: Si ocurre una "Race Condition" en el último milisegundo (alguien insertó el duplicado
       justo antes de nuestro UPDATE), no abortamos. Activamos la bandera v_Dup. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Ante fallos catastróficos (Disco lleno, Red caída), abortamos todo (ROLLBACK). */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST)
       Propósito: Limpiar la entrada y rechazar basura antes de gastar recursos de transacción.
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA (TRIM & NULLIF)
       Quitamos espacios y convertimos cadenas vacías a NULL para validar. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');
    /* Sanitización de Lógica: Si Es_Final viene NULL, asumimos FALSE (0) por seguridad */
    SET _Es_Final    = IFNULL(_Es_Final, 0);

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (REGLAS DE NEGOCIO) */
    
    IF _Id_Estatus IS NULL OR _Id_Estatus <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: Identificador de Estatus inválido.';
    END IF;

    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE es obligatorio.';
    END IF;

    /* Validación de Dominio: Es_Final es binario */
    IF _Es_Final NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE LÓGICA [400]: El campo Es_Final solo acepta 0 o 1.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: ESTRATEGIA DE BLOQUEO DETERMINÍSTICO (PREVENCIÓN DE DEADLOCKS)
       Propósito: Adquirir recursos en orden estricto (Menor a Mayor) para evitar ciclos de espera.
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RECONOCIMIENTO (LECTURA SUCIA / NO BLOQUEANTE)
       Primero "escaneamos" el entorno para identificar a los actores involucrados sin bloquear.
       ---------------------------------------------------------------------------------------- */
    
    /* A) Identificar al Objetivo (Target) */
    SELECT `Codigo`, `Nombre` INTO v_Cod_Act, v_Nom_Act
    FROM `Cat_Estatus_Capacitacion` WHERE `Id_CatEstCap` = _Id_Estatus;

    /* Si no existe, abortamos. (Pudo ser borrado por otro admin hace un segundo) */
    IF v_Cod_Act IS NULL AND v_Nom_Act IS NULL THEN 
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Estatus que intenta editar no existe.';
    END IF;

    /* B) Identificar Conflicto de CÓDIGO (¿Alguien más tiene el código que quiero?) */
    IF _Codigo <> IFNULL(v_Cod_Act, '') THEN
        SELECT `Id_CatEstCap` INTO v_Id_Conflicto_Cod 
        FROM `Cat_Estatus_Capacitacion` 
        WHERE `Codigo` = _Codigo AND `Id_CatEstCap` <> _Id_Estatus LIMIT 1;
    END IF;

    /* C) Identificar Conflicto de NOMBRE (¿Alguien más tiene el nombre que quiero?) */
    IF _Nombre <> v_Nom_Act THEN
        SELECT `Id_CatEstCap` INTO v_Id_Conflicto_Nom 
        FROM `Cat_Estatus_Capacitacion` 
        WHERE `Nombre` = _Nombre AND `Id_CatEstCap` <> _Id_Estatus LIMIT 1;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: EJECUCIÓN DE BLOQUEOS ORDENADOS
       Ordenamos los IDs detectados y los bloqueamos secuencialmente.
       ---------------------------------------------------------------------------------------- */
    
    /* Llenamos el pool de candidatos */
    SET v_L1 = _Id_Estatus;
    SET v_L2 = v_Id_Conflicto_Cod;
    SET v_L3 = v_Id_Conflicto_Nom;

    /* Normalización: Eliminar duplicados en las variables */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* --- RONDA 1: Bloquear el ID Menor --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Estatus_Capacitacion` WHERE `Id_CatEstCap` = v_Min FOR UPDATE;
        /* Marcar como procesado */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 2: Bloquear el Siguiente ID --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Estatus_Capacitacion` WHERE `Id_CatEstCap` = v_Min FOR UPDATE;
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 3: Bloquear el ID Mayor --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Estatus_Capacitacion` WHERE `Id_CatEstCap` = v_Min FOR UPDATE;
    END IF;

    /* ========================================================================================
       BLOQUE 4: LÓGICA DE NEGOCIO (BAJO PROTECCIÓN DE LOCKS)
       Propósito: Aplicar validaciones definitivas con la certeza de que nadie más mueve los datos.
       ======================================================================================== */

    /* 4.1 RE-LECTURA AUTORIZADA
       Leemos el estado definitivo. (Pudo haber cambiado en los milisegundos previos al bloqueo). */
    SELECT `Codigo`, `Nombre`, `Descripcion`, `Es_Final`
    INTO v_Cod_Act, v_Nom_Act, v_Desc_Act, v_Final_Act
    FROM `Cat_Estatus_Capacitacion` 
    WHERE `Id_CatEstCap` = _Id_Estatus; 

    /* Check Anti-Zombie: Si al bloquear descubrimos que el registro fue borrado */
    IF v_Cod_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [410]: El registro desapareció durante la transacción.';
    END IF;

    /* 4.2 DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       Comparamos Snapshot vs Inputs. Usamos `<=>` (Null-Safe) para manejar NULLs en Descripción. */
    IF (v_Cod_Act <=> _Codigo) 
       AND (v_Nom_Act = _Nombre) 
       AND (v_Desc_Act <=> _Descripcion)
       AND (v_Final_Act = _Es_Final) THEN
        
        COMMIT; -- Liberamos locks inmediatamente
        
        /* Retorno anticipado para ahorrar I/O */
        SELECT 'AVISO: No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion, _Id_Estatus AS Id_Estatus;
        LEAVE THIS_PROC;
    END IF;

    /* 4.3 VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       Verificamos duplicados reales bajo lock. */
    
    /* Validación por CÓDIGO */
    SET v_Id_Error = NULL;
    SELECT `Id_CatEstCap` INTO v_Id_Error FROM `Cat_Estatus_Capacitacion` 
    WHERE `Codigo` = _Codigo AND `Id_CatEstCap` <> _Id_Estatus LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya pertenece a otro Estatus.';
    END IF;

    /* Validación por NOMBRE */
    SET v_Id_Error = NULL;
    SELECT `Id_CatEstCap` INTO v_Id_Error FROM `Cat_Estatus_Capacitacion` 
    WHERE `Nombre` = _Nombre AND `Id_CatEstCap` <> _Id_Estatus LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya pertenece a otro Estatus.';
    END IF;

    /* ========================================================================================
       BLOQUE 5: PERSISTENCIA (UPDATE)
       Propósito: Aplicar los cambios físicos.
       ======================================================================================== */
    
    SET v_Dup = 0; -- Resetear bandera de error

    UPDATE `Cat_Estatus_Capacitacion`
    SET `Codigo`      = _Codigo,
        `Nombre`      = _Nombre,
        `Descripcion` = _Descripcion,
        `Es_Final`    = _Es_Final,
        `updated_at`  = NOW() -- Actualizamos la auditoría temporal.
    WHERE `Id_CatEstCap` = _Id_Estatus;

    /* ========================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       Propósito: Gestionar el caso extremo de inserción fantasma justo antes del update.
       ======================================================================================== */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico Post-Mortem */
        SET v_Id_Conflicto = NULL;
        
        /* ¿Fue Código? */
        SELECT `Id_CatEstCap` INTO v_Id_Conflicto FROM `Cat_Estatus_Capacitacion` 
        WHERE `Codigo` = _Codigo AND `Id_CatEstCap` <> _Id_Estatus LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
             SET v_Campo_Error = 'CODIGO';
        ELSE
             /* Fue Nombre */
             SELECT `Id_CatEstCap` INTO v_Id_Conflicto FROM `Cat_Estatus_Capacitacion` 
             WHERE `Nombre` = _Nombre AND `Id_CatEstCap` <> _Id_Estatus LIMIT 1;
             SET v_Campo_Error = 'NOMBRE';
        END IF;

        SELECT 'Error de Concurrencia: Conflicto detectado al guardar.' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo,
               v_Id_Conflicto AS Id_Conflicto;
        LEAVE THIS_PROC;
    END IF;

    /* ========================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       Si llegamos aquí, todo salió bien. Hacemos permanentes los cambios.
       ======================================================================================== */
    COMMIT;
    
    SELECT 'ÉXITO: Estatus actualizado correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Estatus AS Id_Estatus;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_EditarModalidadCapacitacion
   ====================================================================================================

   ----------------------------------------------------------------------------------------------------
   I. CONTEXTO TÉCNICO Y DE NEGOCIO (BUSINESS CONTEXT)
   ----------------------------------------------------------------------------------------------------
   [QUÉ ES]:
   Es el motor transaccional de alta fidelidad encargado de modificar los atributos fundamentales de 
   una "Modalidad de Capacitación" (`Cat_Modalidad_Capacitacion`) existente en el catálogo corporativo.

   [OBJETIVO ESTRATÉGICO]:
   Permitir al administrador corregir o actualizar la identidad (`Código`, `Nombre`) y el contexto 
   operativo (`Descripción`) de una modalidad.
   
   [IMPORTANCIA CRÍTICA]:
   Las modalidades (Presencial, Virtual, Híbrido) son la base de la logística de cursos. Un error de 
   integridad aquí (ej: duplicar conceptos o perder descripciones) corrompería la inteligencia de 
   negocios de todos los reportes históricos y futuros.

   Este SP garantiza la consistencia ACID (Atomicidad, Consistencia, Aislamiento, Durabilidad) en un 
   entorno multi-usuario de alta concurrencia.

   ----------------------------------------------------------------------------------------------------
   II. REGLAS DE BLINDAJE (HARD CONSTRAINTS)
   ----------------------------------------------------------------------------------------------------
   [RN-01] OBLIGATORIEDAD DE DATOS (DATA INTEGRITY):
      - Principio: "Todo o Nada". No se permite persistir una modalidad sin `Código` o sin `Nombre`.
      - Justificación: Un registro anónimo o sin clave técnica rompe la integridad visual de los 
        selectores (dropdowns) y las referencias en el backend.

   [RN-02] EXCLUSIÓN PROPIA (GLOBAL UNIQUENESS):
      - Regla A: El nuevo `Código` no puede pertenecer a OTRA modalidad (`Id <> _Id_Modalidad`).
      - Regla B: El nuevo `Nombre` no puede pertenecer a OTRA modalidad.
      - Nota: Es perfectamente legal que el registro coincida consigo mismo (Idempotencia).
      - Implementación: Esta validación se realiza "Bajo Llave" (dentro de la transacción con bloqueo).

   [RN-03] IDEMPOTENCIA (OPTIMIZACIÓN DE I/O):
      - Antes de escribir en disco, el SP compara el estado actual (`Snapshot`) contra los inputs.
      - Si son matemáticamente idénticos, retorna éxito ('SIN_CAMBIOS') inmediatamente.
      - Beneficio: Evita escrituras innecesarias en el Transaction Log, reduce el crecimiento de la 
        BD y mantiene intacta la fecha de auditoría `updated_at`.

   ----------------------------------------------------------------------------------------------------
   III. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   ----------------------------------------------------------------------------------------------------
   [EL PROBLEMA DE LOS DEADLOCKS (ABRAZOS MORTALES)]:
   En un escenario de "Intercambio" (Swap Scenario), donde:
      - Usuario A quiere renombrar la Modalidad 1 como 'VIRTUAL'.
      - Usuario B quiere renombrar la Modalidad 2 como 'PRESENCIAL'.
   Si ambos registros ya existen y se cruzan las referencias, y si bloquean los recursos en orden inverso,
   el motor de base de datos detectará un ciclo y matará uno de los procesos.

   [LA SOLUCIÓN MATEMÁTICA - ALGORITMO DE ORDENAMIENTO]:
   Implementamos el patrón de "Bloqueo Determinístico Total":
   
   1. FASE DE RECONOCIMIENTO (Dirty Read):
      Identificamos todos los IDs potenciales involucrados:
        a) El ID que edito (Target).
        b) El ID que actualmente posee el Código que quiero usar (Conflicto A).
        c) El ID que actualmente posee el Nombre que quiero usar (Conflicto B).
   
   2. FASE DE ORDENAMIENTO:
      Ordenamos estos IDs numéricamente de MENOR a MAYOR.
   
   3. FASE DE EJECUCIÓN:
      Adquirimos los bloqueos (`FOR UPDATE`) siguiendo estrictamente ese orden "en fila india".
   
   Resultado: Todos los procesos compiten en la misma dirección. Cero Deadlocks garantizados.

   ----------------------------------------------------------------------------------------------------
   IV. CONTRATO DE SALIDA (OUTPUT SPECIFICATION)
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset de una sola fila con:
      - [Mensaje]: Feedback descriptivo y humano para la UI.
      - [Accion]: Código de estado ('ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO').
      - [Id_Modalidad]: Identificador del recurso manipulado.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarModalidadCapacitacion`$$

CREATE PROCEDURE `SP_EditarModalidadCapacitacion`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos los datos crudos desde el formulario web.
       Se asume que son cadenas de texto que requieren limpieza.
       ----------------------------------------------------------------- */
    IN _Id_Modalidad INT,           -- [OBLIGATORIO] PK del registro a editar (Target).
    IN _Codigo       VARCHAR(50),   -- [OBLIGATORIO] Nuevo Código (ej: 'VIRT-02').
    IN _Nombre       VARCHAR(255),  -- [OBLIGATORIO] Nuevo Nombre (ej: 'VIRTUAL ASINCRÓNICO').
    IN _Descripcion  VARCHAR(255)   -- [OPCIONAL] Nueva Descripción (Contexto).
)
THIS_PROC: BEGIN

    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Inicializar los contenedores en memoria para la lógica del procedimiento.
       ======================================================================================== */
    
    /* [Snapshots]: Almacenan la "foto" del registro ANTES de editarlo. 
       Son vitales para comparar si hubo cambios reales (Lógica de Idempotencia). */
    DECLARE v_Cod_Act  VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nom_Act  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Desc_Act VARCHAR(255) DEFAULT NULL;
    
    /* [IDs de Conflicto]: Identifican a "los otros" registros que podrían estorbar.
       Se llenan durante la Fase de Reconocimiento. */
    DECLARE v_Id_Conflicto_Cod INT DEFAULT NULL; -- ¿Quién tiene ya este Código?
    DECLARE v_Id_Conflicto_Nom INT DEFAULT NULL; -- ¿Quién tiene ya este Nombre?
    
	/* --- CORRECCIÓN: SE AGREGA LA VARIABLE FALTANTE PARA EL BLOQUE 6 --- */
    DECLARE v_Id_Conflicto     INT DEFAULT NULL; -- Variable genérica para reportar errores
    
    /* [Variables de Algoritmo de Bloqueo]: Auxiliares para ordenar y ejecutar los locks.
       Nos permiten estructurar la "Fila India" de bloqueos. */
    DECLARE v_L1 INT DEFAULT NULL;   -- Candidato 1 a bloquear
    DECLARE v_L2 INT DEFAULT NULL;   -- Candidato 2 a bloquear
    DECLARE v_L3 INT DEFAULT NULL;   -- Candidato 3 a bloquear
    DECLARE v_Min INT DEFAULT NULL;  -- El menor ID de la ronda actual
    DECLARE v_Existe INT DEFAULT NULL; -- Validación booleana de éxito del lock

    /* [Bandera de Control]: Semáforo para detectar errores de concurrencia (Error 1062).
       Permite manejar la excepción sin abortar el flujo inmediatamente. */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* [Variables de Diagnóstico]: Para el análisis Post-Mortem en caso de fallo.
       Permiten decirle al usuario EXACTAMENTE qué campo causó el error. */
    DECLARE v_Campo_Error VARCHAR(20) DEFAULT NULL;
    DECLARE v_Id_Error    INT DEFAULT NULL;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (SISTEMA DE DEFENSA)
       Propósito: Capturar excepciones técnicas y convertirlas en respuestas controladas.
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062 - Duplicate Entry)
       Objetivo: Si ocurre una "Race Condition" en el último milisegundo (alguien insertó el duplicado
       justo antes de nuestro UPDATE y después de nuestro SELECT), no abortamos.
       Acción: Encendemos la bandera v_Dup = 1 para activar la rutina de recuperación al final. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Ante fallos catastróficos (Disco lleno, Red caída, Error de Sintaxis).
       Acción: Abortamos todo (ROLLBACK) y propagamos el error original (RESIGNAL) para el log. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST STRATEGY)
       Propósito: Limpiar la entrada y rechazar basura antes de gastar recursos de transacción.
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios al inicio/final. Si la cadena queda vacía, la convertimos a NULL
       para facilitar la validación booleana estricta más adelante. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (REGLAS DE NEGOCIO)
       Validamos la integridad básica de la petición. */
    
    IF _Id_Modalidad IS NULL OR _Id_Modalidad <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: Identificador de Modalidad inválido.';
    END IF;

    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE es obligatorio.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: ESTRATEGIA DE BLOQUEO DETERMINÍSTICO (PREVENCIÓN DE DEADLOCKS)
       Propósito: Adquirir recursos en orden estricto (Menor a Mayor) para evitar ciclos de espera.
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RECONOCIMIENTO (LECTURA SUCIA / NO BLOQUEANTE)
       Primero "escaneamos" el entorno para identificar a los actores involucrados sin bloquear.
       Esto nos permite construir la lista de IDs que necesitamos asegurar.
       ---------------------------------------------------------------------------------------- */
    
    /* A) Identificar al Objetivo (Target) */
    SELECT `Codigo`, `Nombre` INTO v_Cod_Act, v_Nom_Act
    FROM `Cat_Modalidad_Capacitacion` WHERE `Id_CatModalCap` = _Id_Modalidad;

    /* Check de Existencia: Si no existe, abortamos. (Pudo ser borrado por otro admin hace un segundo) */
    IF v_Cod_Act IS NULL AND v_Nom_Act IS NULL THEN 
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: La Modalidad que intenta editar no existe.';
    END IF;

    /* B) Identificar Conflicto de CÓDIGO 
       ¿Alguien más tiene el código que quiero usar? (Solo buscamos si el código cambió) */
    IF _Codigo <> IFNULL(v_Cod_Act, '') THEN
        SELECT `Id_CatModalCap` INTO v_Id_Conflicto_Cod 
        FROM `Cat_Modalidad_Capacitacion` 
        WHERE `Codigo` = _Codigo AND `Id_CatModalCap` <> _Id_Modalidad LIMIT 1;
    END IF;

    /* C) Identificar Conflicto de NOMBRE 
       ¿Alguien más tiene el nombre que quiero usar? (Solo buscamos si el nombre cambió) */
    IF _Nombre <> v_Nom_Act THEN
        SELECT `Id_CatModalCap` INTO v_Id_Conflicto_Nom 
        FROM `Cat_Modalidad_Capacitacion` 
        WHERE `Nombre` = _Nombre AND `Id_CatModalCap` <> _Id_Modalidad LIMIT 1;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: EJECUCIÓN DE BLOQUEOS ORDENADOS (EL ALGORITMO)
       Ordenamos los IDs detectados y los bloqueamos secuencialmente.
       ---------------------------------------------------------------------------------------- */
    
    /* Llenamos el pool de candidatos a bloquear */
    SET v_L1 = _Id_Modalidad;
    SET v_L2 = v_Id_Conflicto_Cod;
    SET v_L3 = v_Id_Conflicto_Nom;

    /* Normalización: Eliminar duplicados en las variables 
       (Ej: Si el conflicto de código y nombre es el mismo registro, no intentamos bloquearlo dos veces) */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* --- RONDA 1: Bloquear el ID Menor --- */
    SET v_Min = NULL;
    /* Encontramos el mínimo valor no nulo entre L1, L2 y L3 */
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        /* Bloqueo Pesimista sobre el ID menor */
        SELECT 1 INTO v_Existe FROM `Cat_Modalidad_Capacitacion` WHERE `Id_CatModalCap` = v_Min FOR UPDATE;
        
        /* Marcar como procesado (borrar del pool) para la siguiente ronda */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 2: Bloquear el Siguiente ID (El del medio) --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Modalidad_Capacitacion` WHERE `Id_CatModalCap` = v_Min FOR UPDATE;
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 3: Bloquear el ID Mayor (Último) --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Modalidad_Capacitacion` WHERE `Id_CatModalCap` = v_Min FOR UPDATE;
    END IF;

    /* ========================================================================================
       BLOQUE 4: LÓGICA DE NEGOCIO (BAJO PROTECCIÓN DE LOCKS)
       Propósito: Aplicar validaciones definitivas con la certeza de que nadie más mueve los datos.
       ======================================================================================== */

    /* 4.1 RE-LECTURA AUTORIZADA
       Leemos el estado definitivo del registro.
       (Pudo haber cambiado en los milisegundos previos al bloqueo o durante la espera del lock). */
    SELECT `Codigo`, `Nombre`, `Descripcion`
    INTO v_Cod_Act, v_Nom_Act, v_Desc_Act
    FROM `Cat_Modalidad_Capacitacion` 
    WHERE `Id_CatModalCap` = _Id_Modalidad; 

    /* Check Anti-Zombie: Si al bloquear descubrimos que el registro fue borrado */
    IF v_Cod_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [410]: El registro desapareció durante la transacción.';
    END IF;

    /* 4.2 DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       Comparamos Snapshot vs Inputs. 
       Usamos `<=>` (Null-Safe Equality) para manejar correctamente los NULLs en la Descripción. 
       Si todo es igual, no tiene sentido hacer un UPDATE. */
    IF (v_Cod_Act <=> _Codigo) 
       AND (v_Nom_Act = _Nombre) 
       AND (v_Desc_Act <=> _Descripcion) THEN
        
        COMMIT; -- Liberamos locks inmediatamente
        
        /* Retorno anticipado para ahorrar I/O */
        SELECT 'AVISO: No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion, _Id_Modalidad AS Id_Modalidad;
        LEAVE THIS_PROC;
    END IF;

    /* 4.3 VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       Verificamos duplicados reales bajo lock. Esta validación es 100% fiable. */
    
    /* A) Validación por CÓDIGO */
    SET v_Id_Error = NULL;
    SELECT `Id_CatModalCap` INTO v_Id_Error FROM `Cat_Modalidad_Capacitacion` 
    WHERE `Codigo` = _Codigo AND `Id_CatModalCap` <> _Id_Modalidad LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya pertenece a otra Modalidad.';
    END IF;

    /* B) Validación por NOMBRE */
    SET v_Id_Error = NULL;
    SELECT `Id_CatModalCap` INTO v_Id_Error FROM `Cat_Modalidad_Capacitacion` 
    WHERE `Nombre` = _Nombre AND `Id_CatModalCap` <> _Id_Modalidad LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya pertenece a otra Modalidad.';
    END IF;

    /* ========================================================================================
       BLOQUE 5: PERSISTENCIA (UPDATE FÍSICO)
       Propósito: Aplicar los cambios físicos en el disco.
       ======================================================================================== */
    
    SET v_Dup = 0; -- Resetear bandera de error antes de intentar escribir

    UPDATE `Cat_Modalidad_Capacitacion`
    SET `Codigo`      = _Codigo,
        `Nombre`      = _Nombre,
        `Descripcion` = _Descripcion,
        `updated_at`  = NOW() -- Auditoría automática
    WHERE `Id_CatModalCap` = _Id_Modalidad;

    /* ========================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       Propósito: Gestionar el caso extremo de inserción fantasma justo antes del update.
       ======================================================================================== */
    
    /* Si v_Dup = 1, el UPDATE falló por una violación de UNIQUE KEY inesperada. */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico Post-Mortem: ¿Qué campo causó el error? */
        SET v_Id_Conflicto = NULL;
        
        /* Prueba 1: ¿Fue Código? */
        SELECT `Id_CatModalCap` INTO v_Id_Conflicto FROM `Cat_Modalidad_Capacitacion` 
        WHERE `Codigo` = _Codigo AND `Id_CatModalCap` <> _Id_Modalidad LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN
             SET v_Campo_Error = 'CODIGO';
        ELSE
             /* Prueba 2: Fue Nombre */
             SELECT `Id_CatModalCap` INTO v_Id_Conflicto FROM `Cat_Modalidad_Capacitacion` 
             WHERE `Nombre` = _Nombre AND `Id_CatModalCap` <> _Id_Modalidad LIMIT 1;
             SET v_Campo_Error = 'NOMBRE';
        END IF;

        /* Devolvemos el error estructurado al Frontend */
        SELECT 'Error de Concurrencia: Conflicto detectado al guardar.' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo,
               v_Id_Conflicto AS Id_Conflicto;
        LEAVE THIS_PROC;
    END IF;

    /* ========================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       Si llegamos aquí, todo salió bien. Hacemos permanentes los cambios.
       ======================================================================================== */
    COMMIT;
    
    SELECT 'ÉXITO: Modalidad actualizada correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Modalidad AS Id_Modalidad;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_EditarEstatusParticipante
   ====================================================================================================

   ----------------------------------------------------------------------------------------------------
   I. CONTEXTO TÉCNICO Y DE NEGOCIO (BUSINESS CONTEXT)
   ----------------------------------------------------------------------------------------------------
   [QUÉ ES]:
   Es el motor transaccional de alta fidelidad encargado de modificar los atributos fundamentales de 
   un "Estatus de Participante" (`Cat_Estatus_Participante`) existente en el catálogo.

   [OBJETIVO ESTRATÉGICO]:
   Permitir al administrador corregir o actualizar la identidad (`Código`, `Nombre`) y el contexto 
   operativo (`Descripción`) de un resultado de calificación (ej: cambiar 'REPROBADO' por 'NO APTO').
   
   [IMPORTANCIA CRÍTICA]:
   La modificación de estos estatus afecta la interpretación histórica de las capacitaciones. 
   Este SP garantiza la consistencia ACID (Atomicidad, Consistencia, Aislamiento, Durabilidad) en un 
   entorno multi-usuario de alta concurrencia, evitando duplicados y bloqueos mutuos.

   ----------------------------------------------------------------------------------------------------
   II. REGLAS DE BLINDAJE (HARD CONSTRAINTS)
   ----------------------------------------------------------------------------------------------------
   [RN-01] OBLIGATORIEDAD DE DATOS (DATA INTEGRITY):
      - Principio: "Todo o Nada". No se permite persistir un estatus sin `Código` o sin `Nombre`.
      - Justificación: Un registro anónimo rompe la integridad visual de los reportes.

   [RN-02] EXCLUSIÓN PROPIA (GLOBAL UNIQUENESS):
      - Regla A: El nuevo `Código` no puede pertenecer a OTRO estatus (`Id <> _Id_Estatus`).
      - Regla B: El nuevo `Nombre` no puede pertenecer a OTRO estatus.
      - Nota: Es perfectamente legal que el registro coincida consigo mismo (Idempotencia).
      - Implementación: Esta validación se realiza "Bajo Llave" (dentro de la transacción con bloqueo).

   [RN-03] IDEMPOTENCIA (OPTIMIZACIÓN DE I/O):
      - Antes de escribir en disco, el SP compara el estado actual (`Snapshot`) contra los inputs.
      - Si son matemáticamente idénticos, retorna éxito ('SIN_CAMBIOS') inmediatamente.
      - Beneficio: Evita escrituras innecesarias en el Transaction Log y mantiene intacta la fecha de auditoría `updated_at`.

   ----------------------------------------------------------------------------------------------------
   III. ARQUITECTURA DE CONCURRENCIA (DETERMINISTIC LOCKING PATTERN)
   ----------------------------------------------------------------------------------------------------
   [EL PROBLEMA DE LOS DEADLOCKS (ABRAZOS MORTALES)]:
   En un escenario de "Intercambio" (Swap Scenario), donde:
      - Usuario A quiere renombrar Estatus 1 como 'APROBADO'.
      - Usuario B quiere renombrar Estatus 2 como 'ASISTENCIA'.
   Si ambos registros ya existen y se cruzan las referencias, y si bloquean los recursos en orden inverso,
   el motor de base de datos detectará un ciclo y matará uno de los procesos.

   [LA SOLUCIÓN MATEMÁTICA - ALGORITMO DE ORDENAMIENTO]:
   Implementamos el patrón de "Bloqueo Determinístico Total":
   
   1. FASE DE RECONOCIMIENTO (Dirty Read):
      Identificamos todos los IDs potenciales involucrados:
        a) El ID que edito (Target).
        b) El ID que actualmente posee el Código que quiero usar (Conflicto A).
        c) El ID que actualmente posee el Nombre que quiero usar (Conflicto B).
   
   2. FASE DE ORDENAMIENTO:
      Ordenamos estos IDs numéricamente de MENOR a MAYOR.
   
   3. FASE DE EJECUCIÓN:
      Adquirimos los bloqueos (`FOR UPDATE`) siguiendo estrictamente ese orden "en fila india".
   
   Resultado: Todos los procesos compiten en la misma dirección. Cero Deadlocks garantizados.

   ----------------------------------------------------------------------------------------------------
   IV. CONTRATO DE SALIDA (OUTPUT SPECIFICATION)
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset de una sola fila con:
      - [Mensaje]: Feedback descriptivo y humano para la UI.
      - [Accion]: Código de estado ('ACTUALIZADA', 'SIN_CAMBIOS', 'CONFLICTO').
      - [Id_Estatus_Participante]: Identificador del recurso manipulado.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_EditarEstatusParticipante`$$

CREATE PROCEDURE `SP_EditarEstatusParticipante`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos los datos crudos desde el formulario web.
       Se asume que son cadenas de texto que requieren limpieza.
       ----------------------------------------------------------------- */
    IN _Id_Estatus   INT,           -- [OBLIGATORIO] PK del registro a editar (Target).
    IN _Codigo       VARCHAR(50),   -- [OBLIGATORIO] Nuevo Código (ej: 'APR').
    IN _Nombre       VARCHAR(255),  -- [OBLIGATORIO] Nuevo Nombre (ej: 'APROBADO').
    IN _Descripcion  VARCHAR(255)   -- [OPCIONAL] Nueva Descripción (Contexto).
)
THIS_PROC: BEGIN

    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO Y CONTEXTO
       Propósito: Inicializar los contenedores en memoria para la lógica del procedimiento.
       ======================================================================================== */
    
    /* [Snapshots]: Almacenan la "foto" del registro ANTES de editarlo. 
       Son vitales para comparar si hubo cambios reales (Lógica de Idempotencia). */
    DECLARE v_Cod_Act  VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nom_Act  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Desc_Act VARCHAR(255) DEFAULT NULL;
    
    /* [IDs de Conflicto]: Identifican a "los otros" registros que podrían estorbar.
       Se llenan durante la Fase de Reconocimiento. */
    DECLARE v_Id_Conflicto_Cod INT DEFAULT NULL; -- ¿Quién tiene ya este Código?
    DECLARE v_Id_Conflicto_Nom INT DEFAULT NULL; -- ¿Quién tiene ya este Nombre?
    
    /* Variable genérica para reportar errores en el bloque final */
    DECLARE v_Id_Conflicto     INT DEFAULT NULL; 
    
    /* [Variables de Algoritmo de Bloqueo]: Auxiliares para ordenar y ejecutar los locks.
       Nos permiten estructurar la "Fila India" de bloqueos. */
    DECLARE v_L1 INT DEFAULT NULL;   -- Candidato 1 a bloquear
    DECLARE v_L2 INT DEFAULT NULL;   -- Candidato 2 a bloquear
    DECLARE v_L3 INT DEFAULT NULL;   -- Candidato 3 a bloquear
    DECLARE v_Min INT DEFAULT NULL;  -- El menor ID de la ronda actual
    DECLARE v_Existe INT DEFAULT NULL; -- Validación booleana de éxito del lock

    /* [Bandera de Control]: Semáforo para detectar errores de concurrencia (Error 1062).
       Permite manejar la excepción sin abortar el flujo inmediatamente. */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* [Variables de Diagnóstico]: Para el análisis Post-Mortem en caso de fallo.
       Permiten decirle al usuario EXACTAMENTE qué campo causó el error. */
    DECLARE v_Campo_Error VARCHAR(20) DEFAULT NULL;
    DECLARE v_Id_Error    INT DEFAULT NULL;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (SISTEMA DE DEFENSA)
       Propósito: Capturar excepciones técnicas y convertirlas en respuestas controladas.
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062 - Duplicate Entry)
       Objetivo: Si ocurre una "Race Condition" en el último milisegundo (alguien insertó el duplicado
       justo antes de nuestro UPDATE y después de nuestro SELECT), no abortamos.
       Acción: Encendemos la bandera v_Dup = 1 para activar la rutina de recuperación al final. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Ante fallos catastróficos (Disco lleno, Red caída, Error de Sintaxis).
       Acción: Abortamos todo (ROLLBACK) y propagamos el error original (RESIGNAL) para el log. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST STRATEGY)
       Propósito: Limpiar la entrada y rechazar basura antes de gastar recursos de transacción.
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios al inicio/final. Si la cadena queda vacía, la convertimos a NULL
       para facilitar la validación booleana estricta más adelante. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (REGLAS DE NEGOCIO)
       Validamos la integridad básica de la petición. */
    
    IF _Id_Estatus IS NULL OR _Id_Estatus <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: Identificador de Estatus inválido.';
    END IF;

    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE es obligatorio.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: ESTRATEGIA DE BLOQUEO DETERMINÍSTICO (PREVENCIÓN DE DEADLOCKS)
       Propósito: Adquirir recursos en orden estricto (Menor a Mayor) para evitar ciclos de espera.
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RECONOCIMIENTO (LECTURA SUCIA / NO BLOQUEANTE)
       Primero "escaneamos" el entorno para identificar a los actores involucrados sin bloquear.
       Esto nos permite construir la lista de IDs que necesitamos asegurar.
       ---------------------------------------------------------------------------------------- */
    
    /* A) Identificar al Objetivo (Target) */
    SELECT `Codigo`, `Nombre` INTO v_Cod_Act, v_Nom_Act
    FROM `Cat_Estatus_Participante` WHERE `Id_CatEstPart` = _Id_Estatus;

    /* Check de Existencia: Si no existe, abortamos. (Pudo ser borrado por otro admin hace un segundo) */
    IF v_Cod_Act IS NULL AND v_Nom_Act IS NULL THEN 
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Estatus que intenta editar no existe.';
    END IF;

    /* B) Identificar Conflicto de CÓDIGO 
       ¿Alguien más tiene el código que quiero usar? (Solo buscamos si el código cambió) */
    IF _Codigo <> IFNULL(v_Cod_Act, '') THEN
        SELECT `Id_CatEstPart` INTO v_Id_Conflicto_Cod 
        FROM `Cat_Estatus_Participante` 
        WHERE `Codigo` = _Codigo AND `Id_CatEstPart` <> _Id_Estatus LIMIT 1;
    END IF;

    /* C) Identificar Conflicto de NOMBRE 
       ¿Alguien más tiene el nombre que quiero usar? (Solo buscamos si el nombre cambió) */
    IF _Nombre <> v_Nom_Act THEN
        SELECT `Id_CatEstPart` INTO v_Id_Conflicto_Nom 
        FROM `Cat_Estatus_Participante` 
        WHERE `Nombre` = _Nombre AND `Id_CatEstPart` <> _Id_Estatus LIMIT 1;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: EJECUCIÓN DE BLOQUEOS ORDENADOS (EL ALGORITMO)
       Ordenamos los IDs detectados y los bloqueamos secuencialmente.
       ---------------------------------------------------------------------------------------- */
    
    /* Llenamos el pool de candidatos a bloquear */
    SET v_L1 = _Id_Estatus;
    SET v_L2 = v_Id_Conflicto_Cod;
    SET v_L3 = v_Id_Conflicto_Nom;

    /* Normalización: Eliminar duplicados en las variables 
       (Ej: Si el conflicto de código y nombre es el mismo registro, no intentamos bloquearlo dos veces) */
    IF v_L2 = v_L1 THEN SET v_L2 = NULL; END IF;
    IF v_L3 = v_L1 THEN SET v_L3 = NULL; END IF;
    IF v_L3 = v_L2 THEN SET v_L3 = NULL; END IF;

    /* --- RONDA 1: Bloquear el ID Menor --- */
    SET v_Min = NULL;
    /* Encontramos el mínimo valor no nulo entre L1, L2 y L3 */
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        /* Bloqueo Pesimista sobre el ID menor */
        SELECT 1 INTO v_Existe FROM `Cat_Estatus_Participante` WHERE `Id_CatEstPart` = v_Min FOR UPDATE;
        
        /* Marcar como procesado (borrar del pool) para la siguiente ronda */
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 2: Bloquear el Siguiente ID (El del medio) --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Estatus_Participante` WHERE `Id_CatEstPart` = v_Min FOR UPDATE;
        IF v_L1 = v_Min THEN SET v_L1 = NULL; END IF;
        IF v_L2 = v_Min THEN SET v_L2 = NULL; END IF;
        IF v_L3 = v_Min THEN SET v_L3 = NULL; END IF;
    END IF;

    /* --- RONDA 3: Bloquear el ID Mayor (Último) --- */
    SET v_Min = NULL;
    IF v_L1 IS NOT NULL THEN SET v_Min = v_L1; END IF;
    IF v_L2 IS NOT NULL AND (v_Min IS NULL OR v_L2 < v_Min) THEN SET v_Min = v_L2; END IF;
    IF v_L3 IS NOT NULL AND (v_Min IS NULL OR v_L3 < v_Min) THEN SET v_Min = v_L3; END IF;

    IF v_Min IS NOT NULL THEN
        SELECT 1 INTO v_Existe FROM `Cat_Estatus_Participante` WHERE `Id_CatEstPart` = v_Min FOR UPDATE;
    END IF;

    /* ========================================================================================
       BLOQUE 4: LÓGICA DE NEGOCIO (BAJO PROTECCIÓN DE LOCKS)
       Propósito: Aplicar validaciones definitivas con la certeza de que nadie más mueve los datos.
       ======================================================================================== */

    /* 4.1 RE-LECTURA AUTORIZADA
       Leemos el estado definitivo del registro.
       (Pudo haber cambiado en los milisegundos previos al bloqueo o durante la espera del lock). */
    SELECT `Codigo`, `Nombre`, `Descripcion`
    INTO v_Cod_Act, v_Nom_Act, v_Desc_Act
    FROM `Cat_Estatus_Participante` 
    WHERE `Id_CatEstPart` = _Id_Estatus; 

    /* Check Anti-Zombie: Si al bloquear descubrimos que el registro fue borrado */
    IF v_Cod_Act IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [410]: El registro desapareció durante la transacción.';
    END IF;

    /* 4.2 DETECCIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       Comparamos Snapshot vs Inputs. 
       Usamos `<=>` (Null-Safe Equality) para manejar correctamente los NULLs en la Descripción. 
       Si todo es igual, no tiene sentido hacer un UPDATE. */
    IF (v_Cod_Act <=> _Codigo) 
       AND (v_Nom_Act = _Nombre) 
       AND (v_Desc_Act <=> _Descripcion) THEN
       
       COMMIT; -- Liberamos locks inmediatamente
       
       /* Retorno anticipado para ahorrar I/O */
       SELECT 'AVISO: No se detectaron cambios en la información.' AS Mensaje, 'SIN_CAMBIOS' AS Accion, _Id_Estatus AS Id_Estatus_Participante;
       LEAVE THIS_PROC;
    END IF;

    /* 4.3 VALIDACIÓN FINAL DE UNICIDAD (PRE-UPDATE CHECK)
       Verificamos duplicados reales bajo lock. Esta validación es 100% fiable. */
    
    /* A) Validación por CÓDIGO */
    SET v_Id_Error = NULL;
    SELECT `Id_CatEstPart` INTO v_Id_Error FROM `Cat_Estatus_Participante` 
    WHERE `Codigo` = _Codigo AND `Id_CatEstPart` <> _Id_Estatus LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya pertenece a otro Estatus.';
    END IF;

    /* B) Validación por NOMBRE */
    SET v_Id_Error = NULL;
    SELECT `Id_CatEstPart` INTO v_Id_Error FROM `Cat_Estatus_Participante` 
    WHERE `Nombre` = _Nombre AND `Id_CatEstPart` <> _Id_Estatus LIMIT 1;
    
    IF v_Id_Error IS NOT NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya pertenece a otro Estatus.';
    END IF;

    /* ========================================================================================
       BLOQUE 5: PERSISTENCIA (UPDATE FÍSICO)
       Propósito: Aplicar los cambios físicos en el disco.
       ======================================================================================== */
    
    SET v_Dup = 0; -- Resetear bandera de error antes de intentar escribir

    UPDATE `Cat_Estatus_Participante`
    SET `Codigo`      = _Codigo,
        `Nombre`      = _Nombre,
        `Descripcion` = _Descripcion,
        `updated_at`  = NOW() -- Auditoría automática
    WHERE `Id_CatEstPart` = _Id_Estatus;

    /* ========================================================================================
       BLOQUE 6: MANEJO DE COLISIÓN TARDÍA (RECUPERACIÓN DE ERROR 1062)
       Propósito: Gestionar el caso extremo de inserción fantasma justo antes del update.
       ======================================================================================== */
    
    /* Si v_Dup = 1, el UPDATE falló por una violación de UNIQUE KEY inesperada. */
    IF v_Dup = 1 THEN
        ROLLBACK;
        
        /* Diagnóstico Post-Mortem: ¿Qué campo causó el error? */
        SET v_Id_Conflicto = NULL;
        
        /* Prueba 1: ¿Fue Código? */
        SELECT `Id_CatEstPart` INTO v_Id_Conflicto FROM `Cat_Estatus_Participante` 
        WHERE `Codigo` = _Codigo AND `Id_CatEstPart` <> _Id_Estatus LIMIT 1;

        IF v_Id_Conflicto IS NOT NULL THEN 
             SET v_Campo_Error = 'CODIGO';
        ELSE 
             /* Prueba 2: Fue Nombre */
             SELECT `Id_CatEstPart` INTO v_Id_Conflicto FROM `Cat_Estatus_Participante` 
             WHERE `Nombre` = _Nombre AND `Id_CatEstPart` <> _Id_Estatus LIMIT 1;
             SET v_Campo_Error = 'NOMBRE';
        END IF;

        /* Devolvemos el error estructurado al Frontend */
        SELECT 'Error de Concurrencia: Conflicto detectado al guardar.' AS Mensaje, 
               'CONFLICTO' AS Accion, 
               v_Campo_Error AS Campo,
               v_Id_Conflicto AS Id_Conflicto;
        LEAVE THIS_PROC;
    END IF;

    /* ========================================================================================
       BLOQUE 7: CONFIRMACIÓN EXITOSA
       Si llegamos aquí, todo salió bien. Hacemos permanentes los cambios.
       ======================================================================================== */
    COMMIT;
    
    SELECT 'ÉXITO: Estatus actualizado correctamente.' AS Mensaje, 
           'ACTUALIZADA' AS Accion, 
           _Id_Estatus AS Id_Estatus_Participante;

END$$

DELIMITER ;
