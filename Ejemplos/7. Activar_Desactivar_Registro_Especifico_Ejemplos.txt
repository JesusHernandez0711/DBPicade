/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusPais
   ============================================================================================
   OBJETIVO
   --------
   Activar/Desactivar (borrado lógico) un País:
      Pais.Activo (1 = activo, 0 = inactivo)

   REGLA CRÍTICA (INTEGRIDAD JERÁRQUICA)
   ------------------------------------
   - NO se permite DESACTIVAR un País si tiene:
       * ESTADOS ACTIVOS, o
       * MUNICIPIOS ACTIVOS bajo ese país
   Esto evita inconsistencia:
      Pais.Activo=0
      Estado.Activo=1
      Municipio.Activo=1

   CONCURRENCIA
   ------------
   - SELECT ... FOR UPDATE sobre Pais para:
       * Validar existencia
       * Evitar cambios simultáneos contradictorios
============================================================================================ */
DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_CambiarEstatusPais$$
CREATE PROCEDURE SP_CambiarEstatusPais(
    IN _Id_Pais INT,
    IN _Nuevo_Estatus TINYINT -- 1 = Activo, 0 = Inactivo
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES
    ---------------------------------------------------------------------------------------- */
    DECLARE v_Existe INT DEFAULT NULL;
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;
    DECLARE v_Tmp INT DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       HANDLER GENERAL
       - Si cualquier SQL falla: ROLLBACK y relanza error real
    ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE PARÁMETROS
    ---------------------------------------------------------------------------------------- */
    IF _Id_Pais IS NULL OR _Id_Pais <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_Pais inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0,1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Estatus inválido (solo 0 o 1).';
    END IF;

    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       1) VALIDAR EXISTENCIA DEL PAÍS Y BLOQUEAR SU FILA
    ---------------------------------------------------------------------------------------- */
    SELECT 1, Activo
      INTO v_Existe, v_Activo_Actual
    FROM Pais
    WHERE Id_Pais = _Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El País no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       2) "SIN CAMBIOS" (IDEMPOTENCIA)
       - Si el país ya estaba en ese estatus, no hacemos nada y devolvemos mensaje claro.
    ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: El País ya estaba Activo.'
            ELSE 'Sin cambios: El País ya estaba Inactivo.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    ELSE
        /* ------------------------------------------------------------------------------------
           3) SI INTENTA DESACTIVAR (Nuevo_Estatus=0):
              BLOQUEAR SI HAY HIJOS ACTIVOS
        ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN

            /* 3A) Candado: Estados activos */
            SET v_Tmp = NULL;
            SELECT Id_Estado
              INTO v_Tmp
            FROM Estado
            WHERE Fk_Id_Pais = _Id_Pais
              AND Activo = 1 -- <--- CORRECCIÓN IMPORTANTE
            LIMIT 1;

            IF v_Tmp IS NOT NULL THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar el País porque tiene ESTADOS ACTIVOS. Desactiva primero los Estados.';
            END IF;

            /* 3B) Candado extra: Municipios activos bajo el país (por si hay datos sucios) */
            SET v_Tmp = NULL;
            SELECT Mun.Id_Municipio
              INTO v_Tmp
            FROM Municipio Mun
            JOIN Estado Est ON Est.Id_Estado = Mun.Fk_Id_Estado
            WHERE Est.Fk_Id_Pais = _Id_Pais
              AND Mun.Activo = 1
            LIMIT 1;

            IF v_Tmp IS NOT NULL THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar el País porque existen MUNICIPIOS ACTIVOS bajo él. Desactiva primero Municipios/Estados.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           4) APLICAR CAMBIO DE ESTATUS
        ------------------------------------------------------------------------------------ */
        UPDATE Pais
        SET Activo = _Nuevo_Estatus,
            updated_at = NOW()
        WHERE Id_Pais = _Id_Pais;

        COMMIT;

        /* ------------------------------------------------------------------------------------
           5) RESPUESTA PARA FRONTEND
        ------------------------------------------------------------------------------------ */
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'País Reactivado'
            ELSE 'País Desactivado (Oculto)'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    END IF;

END$$
DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusEstado
   ============================================================================================
   OBJETIVO
   --------
   Activar/Desactivar (borrado lógico) un Estado:
      Estado.Activo (1 = activo, 0 = inactivo)

   REGLAS CRÍTICAS (INTEGRIDAD JERÁRQUICA)
   --------------------------------------
   A) Al DESACTIVAR un Estado (Activo=0):
      - NO se permite si tiene MUNICIPIOS ACTIVOS.
        Evita: Estado=0 con Municipio=1.

   B) Al ACTIVAR un Estado (Activo=1)  <<<<<<<<<<<< CANDADO JERÁRQUICO (C)
      - NO se permite si su PAÍS PADRE está INACTIVO.
        Evita: País=0 con Estado=1 (inconsistencia lógica y UX).

   CONCURRENCIA / BLOQUEOS
   -----------------------
   - Bloqueamos en orden jerárquico: PAÍS -> ESTADO
   - Usamos STRAIGHT_JOIN + FOR UPDATE para:
       * asegurar el orden de lectura/bloqueo
       * evitar carreras donde el País cambie mientras activas el Estado
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_CambiarEstatusEstado$$
CREATE PROCEDURE SP_CambiarEstatusEstado(
    IN _Id_Estado INT,
    IN _Nuevo_Estatus TINYINT -- 1 = Activo, 0 = Inactivo
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES
    ---------------------------------------------------------------------------------------- */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Estatus actual del Estado */
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;

    /* Datos del padre (País) para el candado jerárquico al ACTIVAR */
    DECLARE v_Id_Pais INT DEFAULT NULL;
    DECLARE v_Pais_Activo TINYINT(1) DEFAULT NULL;

    /* Auxiliar para candados */
    DECLARE v_Tmp INT DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       HANDLER GENERAL
       - Si cualquier SQL falla: ROLLBACK y relanza el error real
    ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE PARÁMETROS
    ---------------------------------------------------------------------------------------- */
    IF _Id_Estado IS NULL OR _Id_Estado <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_Estado inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0,1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Estatus inválido (solo 0 o 1).';
    END IF;

    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       1) VALIDAR EXISTENCIA Y BLOQUEAR FILAS EN ORDEN JERÁRQUICO (PAÍS -> ESTADO)
       ----------------------------------------------------------------------------------------
       ¿POR QUÉ ASÍ?
       - Antes solo bloqueabas Estado.
       - Para el CANDADO (C) necesitamos consultar País.Activo.
       - Si solo lo "lees" sin bloquear, otro proceso podría apagar el País al mismo tiempo.
       - Con este SELECT ... FOR UPDATE, bloqueas BOTH: País y Estado (en orden).
    ---------------------------------------------------------------------------------------- */
    SELECT
        1 AS Existe,
        E.Activo AS Activo_Estado,
        E.Fk_Id_Pais AS Id_Pais,
        P.Activo AS Activo_Pais
    INTO
        v_Existe,
        v_Activo_Actual,
        v_Id_Pais,
        v_Pais_Activo
    FROM Pais P
    STRAIGHT_JOIN Estado E ON E.Fk_Id_Pais = P.Id_Pais
    WHERE E.Id_Estado = _Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El Estado no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       2) "SIN CAMBIOS" (IDEMPOTENCIA)
       - Si ya está en ese estado, no hacemos nada.
    ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: El Estado ya estaba Activo.'
            ELSE 'Sin cambios: El Estado ya estaba Inactivo.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    ELSE

        /* ------------------------------------------------------------------------------------
           3) CANDADO JERÁRQUICO AL ACTIVAR (C)  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
           ------------------------------------------------------------------------------------
           REGLA:
           - Si quieres ACTIVAR Estado (Nuevo_Estatus=1),
             su País padre DEBE estar ACTIVO.
           - Si el País está inactivo, bloquear con mensaje claro.
        ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 1 THEN
            IF v_Pais_Activo = 0 THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede ACTIVAR el Estado porque su PAÍS está INACTIVO. Activa primero el País.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           4) SI INTENTA DESACTIVAR: BLOQUEAR SI HAY MUNICIPIOS ACTIVOS (regla original)
        ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN
            SET v_Tmp = NULL;
            SELECT Id_Municipio
              INTO v_Tmp
            FROM Municipio
            WHERE Fk_Id_Estado = _Id_Estado
              AND Activo = 1
            LIMIT 1;

            IF v_Tmp IS NOT NULL THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar el Estado porque tiene MUNICIPIOS ACTIVOS. Desactiva primero los Municipios.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           5) APLICAR CAMBIO DE ESTATUS
        ------------------------------------------------------------------------------------ */
        UPDATE Estado
        SET Activo = _Nuevo_Estatus,
            updated_at = NOW()
        WHERE Id_Estado = _Id_Estado;

        COMMIT;

        /* ------------------------------------------------------------------------------------
           6) RESPUESTA PARA FRONTEND
        ------------------------------------------------------------------------------------ */
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Estado Reactivado'
            ELSE 'Estado Desactivado'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    END IF;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusMunicipio
   ============================================================================================
   OBJETIVO
   --------
   Activar/Desactivar (borrado lógico) un Municipio:
      Municipio.Activo (1 = activo, 0 = inactivo)

   REGLAS CRÍTICAS
   --------------
   A) Al DESACTIVAR un Municipio (Activo=0):
      - NO se permite si está REFERENCIADO por tablas hijas (tu regla actual).

   B) Al ACTIVAR un Municipio (Activo=1)  <<<<<<<<<<<< CANDADO JERÁRQUICO (C)
      - NO se permite si su ESTADO o su PAÍS están INACTIVOS.
        Evita:
          País=0  con Municipio=1
          Estado=0 con Municipio=1

   CONCURRENCIA / BLOQUEOS
   -----------------------
   - Bloqueamos en orden jerárquico: PAÍS -> ESTADO -> MUNICIPIO
   - Usamos STRAIGHT_JOIN + FOR UPDATE para:
       * asegurar orden de bloqueo
       * evitar carreras (que apaguen Estado/País mientras activas Municipio)
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_CambiarEstatusMunicipio$$
CREATE PROCEDURE SP_CambiarEstatusMunicipio(
    IN _Id_Municipio INT,
    IN _Nuevo_Estatus TINYINT /* 1 = Activo, 0 = Inactivo */
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES
    ---------------------------------------------------------------------------------------- */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Estatus actual del Municipio */
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;

    /* Datos jerárquicos para candado al ACTIVAR */
    DECLARE v_Id_Estado INT DEFAULT NULL;
    DECLARE v_Estado_Activo TINYINT(1) DEFAULT NULL;

    DECLARE v_Id_Pais INT DEFAULT NULL;
    DECLARE v_Pais_Activo TINYINT(1) DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       HANDLER GENERAL
    ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE PARÁMETROS
    ---------------------------------------------------------------------------------------- */
    IF _Id_Municipio IS NULL OR _Id_Municipio <= 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Id_Municipio inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0,1) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Estatus inválido (solo 0 o 1).';
    END IF;

    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       1) VALIDAR EXISTENCIA Y BLOQUEAR FILAS EN ORDEN JERÁRQUICO (PAÍS -> ESTADO -> MUNICIPIO)
       ----------------------------------------------------------------------------------------
       ¿POR QUÉ ASÍ?
       - Antes solo bloqueabas Municipio.
       - Para el candado (C) necesitamos leer Estado.Activo y Pais.Activo.
       - Si no bloqueas, te puede pasar:
           * activas municipio
           * en paralelo apagan estado/país
           * terminas con jerarquía inconsistente
       - Con FOR UPDATE aquí, quedan bloqueadas las 3 filas mientras decides.
    ---------------------------------------------------------------------------------------- */
    SELECT
        1 AS Existe,
        M.Activo AS Activo_Municipio,

        M.Fk_Id_Estado AS Id_Estado,
        E.Activo AS Activo_Estado,

        E.Fk_Id_Pais AS Id_Pais,
        P.Activo AS Activo_Pais
    INTO
        v_Existe,
        v_Activo_Actual,
        v_Id_Estado,
        v_Estado_Activo,
        v_Id_Pais,
        v_Pais_Activo
    FROM Pais P
    STRAIGHT_JOIN Estado E ON E.Fk_Id_Pais = P.Id_Pais
    STRAIGHT_JOIN Municipio M ON M.Fk_Id_Estado = E.Id_Estado
    WHERE M.Id_Municipio = _Id_Municipio
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El Municipio no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       2) "SIN CAMBIOS" (IDEMPOTENCIA)
       - Si ya está como lo pide el switch, no hacemos nada.
    ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: El Municipio ya estaba Activo.'
            ELSE 'Sin cambios: El Municipio ya estaba Inactivo.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    ELSE

        /* ------------------------------------------------------------------------------------
           3) CANDADO JERÁRQUICO AL ACTIVAR (C)  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
           ------------------------------------------------------------------------------------
           REGLA:
           - Si quieres ACTIVAR Municipio (Nuevo_Estatus=1),
             su Estado y su País deben estar ACTIVOS.
           - Si alguno está inactivo: bloquear con mensaje claro.
        ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 1 THEN
            IF v_Pais_Activo = 0 AND v_Estado_Activo = 0 THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede ACTIVAR el Municipio porque su PAÍS y su ESTADO están INACTIVOS. Activa primero País y Estado.';
            END IF;

            IF v_Pais_Activo = 0 THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede ACTIVAR el Municipio porque su PAÍS está INACTIVO. Activa primero el País.';
            END IF;

            IF v_Estado_Activo = 0 THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede ACTIVAR el Municipio porque su ESTADO está INACTIVO. Activa primero el Estado.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           4) SI INTENTA DESACTIVAR: BLOQUEAR SI HAY REFERENCIAS (regla original)
           - Cada tabla hija debe impedir el apagado.
           - Mensajes específicos ayudan a soporte y a UX.
        ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN

            /* 4A) Cat_Centros_Trabajo */
            IF EXISTS (
                SELECT 1
                FROM Cat_Centros_Trabajo
                WHERE Fk_Id_Municipio_CatCT = _Id_Municipio
				AND `Activo` = 1 -- <--- CORRECCIÓN IMPORTANTE
                LIMIT 1
            ) THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar el Municipio porque está referenciado por Cat_Centros_Trabajo (Centros de Trabajo).';
            END IF;

            /* 4B) Cat_Departamentos */
            IF EXISTS (
                SELECT 1
                FROM Cat_Departamentos
                WHERE Fk_Id_Municipio_CatDep = _Id_Municipio
				AND `Activo` = 1 -- <--- CORRECCIÓN IMPORTANTE
                LIMIT 1
            ) THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar el Municipio porque está referenciado por Cat_Departamentos.';
            END IF;

            /* 4C) Cat_Cases_Sedes */
            IF EXISTS (
                SELECT 1
                FROM Cat_Cases_Sedes
                WHERE Fk_Id_Municipio = _Id_Municipio
				AND `Activo` = 1 -- <--- CORRECCIÓN IMPORTANTE
                LIMIT 1
            ) THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar el Municipio porque está referenciado por Cat_Cases_Sedes.';
            END IF;

        END IF;

        /* ------------------------------------------------------------------------------------
           5) APLICAR CAMBIO DE ESTATUS
        ------------------------------------------------------------------------------------ */
        UPDATE Municipio
        SET Activo = _Nuevo_Estatus,
            updated_at = NOW()
        WHERE Id_Municipio = _Id_Municipio;

        COMMIT;

        /* ------------------------------------------------------------------------------------
           6) RESPUESTA PARA FRONTEND
        ------------------------------------------------------------------------------------ */
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Municipio Reactivado Exitosamente'
            ELSE 'Municipio Desactivado (Eliminado Lógico)'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;

    END IF;

END$$
DELIMITER ;

/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusDireccion
   ============================================================================================
   OBJETIVO
   --------
   Activar/Desactivar (borrado lógico) una Dirección:
      Cat_Direcciones.Activo (1 = activo, 0 = inactivo)

   REGLA CRÍTICA (INTEGRIDAD JERÁRQUICA)
   ------------------------------------
   - NO se permite DESACTIVAR una Dirección si tiene:
       * SUBDIRECCIONES ACTIVAS bajo esa dirección.
   
   Esto evita inconsistencia de datos:
      Direccion.Activo=0 (Padre muerto)
      Subdireccion.Activo=1 (Hijo vivo) -> ¡Huérfano lógico!

   CONCURRENCIA
   ------------
   - SELECT ... FOR UPDATE sobre Dirección para:
       * Validar existencia
       * Evitar cambios simultáneos contradictorios (ej: alguien más la borra mientras tú la desactivas)
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_CambiarEstatusDireccion$$
CREATE PROCEDURE SP_CambiarEstatusDireccion(
    IN _Id_CatDirecc INT,
    IN _Nuevo_Estatus TINYINT -- 1 = Activo, 0 = Inactivo
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Existe INT DEFAULT NULL;
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;
    DECLARE v_Tmp INT DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       HANDLER GENERAL
       - Si cualquier SQL falla: ROLLBACK y relanza error real
       ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE PARÁMETROS
       ---------------------------------------------------------------------------------------- */
    IF _Id_CatDirecc IS NULL OR _Id_CatDirecc <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_CatDirecc inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0,1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Estatus inválido (solo 0 o 1).';
    END IF;

    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       1) VALIDAR EXISTENCIA DE LA DIRECCIÓN Y BLOQUEAR SU FILA
       ---------------------------------------------------------------------------------------- */
    SELECT 1, Activo
      INTO v_Existe, v_Activo_Actual
    FROM Cat_Direcciones
    WHERE Id_CatDirecc = _Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: La Dirección no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       2) "SIN CAMBIOS" (IDEMPOTENCIA)
       - Si la dirección ya estaba en ese estatus, no hacemos nada y devolvemos mensaje claro.
       ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: La Dirección ya estaba Activa.'
            ELSE 'Sin cambios: La Dirección ya estaba Inactiva.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    ELSE
        /* ------------------------------------------------------------------------------------
           3) SI INTENTA DESACTIVAR (Nuevo_Estatus=0):
              BLOQUEAR SI HAY HIJOS ACTIVOS
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN

            /* 3A) Candado: Subdirecciones activas */
            SET v_Tmp = NULL;
            SELECT Id_CatSubDirec
              INTO v_Tmp
            FROM Cat_Subdirecciones
            WHERE Fk_Id_CatDirecc = _Id_CatDirecc
              AND Activo = 1
            LIMIT 1;

            IF v_Tmp IS NOT NULL THEN
                SIGNAL SQLSTATE '45000' 
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar la Dirección porque tiene SUBDIRECCIONES ACTIVAS. Desactiva primero las Subdirecciones.';
            END IF;

            /* 3B) Candado extra: Gerencias activas bajo la dirección (Validación de profundidad)
               Esto protege contra inconsistencias profundas (Dirección -> Gerencia) aunque la
               Subdirección intermedia estuviera en un estado raro. */
            SET v_Tmp = NULL;
            SELECT Geren.Id_CatGeren
              INTO v_Tmp
            FROM Cat_Gerencias_Activos Geren
            JOIN Cat_Subdirecciones Subd ON Subd.Id_CatSubDirec = Geren.Fk_Id_CatSubDirec
            WHERE Subd.Fk_Id_CatDirecc = _Id_CatDirecc
              AND Geren.Activo = 1
            LIMIT 1;

            IF v_Tmp IS NOT NULL THEN
                SIGNAL SQLSTATE '45000' 
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar la Dirección porque existen GERENCIAS ACTIVAS bajo ella. Desactiva primero Gerencias/Subdirecciones.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           4) APLICAR CAMBIO DE ESTATUS
           ------------------------------------------------------------------------------------ */
        UPDATE Cat_Direcciones
        SET Activo = _Nuevo_Estatus,
            updated_at = NOW()
        WHERE Id_CatDirecc = _Id_CatDirecc;

        COMMIT;

        /* ------------------------------------------------------------------------------------
           5) RESPUESTA PARA FRONTEND
           ------------------------------------------------------------------------------------ */
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Dirección Reactivada'
            ELSE 'Dirección Desactivada (Oculta)'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    END IF;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusSubdireccion
   ============================================================================================
   OBJETIVO
   --------
   Activar/Desactivar (borrado lógico) una Subdirección:
      Cat_Subdirecciones.Activo (1 = activo, 0 = inactivo)

   REGLAS CRÍTICAS (INTEGRIDAD JERÁRQUICA)
   --------------------------------------
   A) Al DESACTIVAR una Subdirección (Activo=0):
      - NO se permite si tiene GERENCIAS ACTIVAS.
        Evita: Subdirección=0 con Gerencia=1 (Hijo Huérfano).

   B) Al ACTIVAR una Subdirección (Activo=1)  <<<<<<<<<<<< CANDADO JERÁRQUICO
      - NO se permite si su DIRECCIÓN PADRE está INACTIVA.
        Evita: Dirección=0 con Subdirección=1 (inconsistencia lógica y visual en UI).

   CONCURRENCIA / BLOQUEOS
   -----------------------
   - Bloqueamos en orden jerárquico: DIRECCIÓN -> SUBDIRECCIÓN
   - Usamos STRAIGHT_JOIN + FOR UPDATE para:
        * asegurar el orden de lectura/bloqueo
        * evitar carreras donde la Dirección cambie de estatus mientras activas la Subdirección.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_CambiarEstatusSubdireccion$$
CREATE PROCEDURE SP_CambiarEstatusSubdireccion(
    IN _Id_CatSubDirec INT,
    IN _Nuevo_Estatus TINYINT -- 1 = Activo, 0 = Inactivo
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Estatus actual de la Subdirección */
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;

    /* Datos del padre (Dirección) para el candado jerárquico al ACTIVAR */
    DECLARE v_Id_Direccion INT DEFAULT NULL;
    DECLARE v_Direccion_Activo TINYINT(1) DEFAULT NULL;

    /* Auxiliar para candados */
    DECLARE v_Tmp INT DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       HANDLER GENERAL
       - Si cualquier SQL falla: ROLLBACK y relanza el error real
       ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE PARÁMETROS
       ---------------------------------------------------------------------------------------- */
    IF _Id_CatSubDirec IS NULL OR _Id_CatSubDirec <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Id_CatSubDirec inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0,1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Estatus inválido (solo 0 o 1).';
    END IF;

    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       1) VALIDAR EXISTENCIA Y BLOQUEAR FILAS EN ORDEN JERÁRQUICO (DIRECCIÓN -> SUBDIRECCIÓN)
       ----------------------------------------------------------------------------------------
       ¿POR QUÉ ASÍ?
       - Para el CANDADO (B) necesitamos consultar Dirección.Activo.
       - Si solo lo "lees" sin bloquear, otro proceso podría apagar la Dirección al mismo tiempo.
       - Con este SELECT ... FOR UPDATE, bloqueas AMBOS: Dirección y Subdirección (en orden).
       ---------------------------------------------------------------------------------------- */
    SELECT
        1 AS Existe,
        S.Activo AS Activo_Subdireccion,
        S.Fk_Id_CatDirecc AS Id_Direccion,
        D.Activo AS Activo_Direccion
    INTO
        v_Existe,
        v_Activo_Actual,
        v_Id_Direccion,
        v_Direccion_Activo
    FROM Cat_Direcciones D
    STRAIGHT_JOIN Cat_Subdirecciones S ON S.Fk_Id_CatDirecc = D.Id_CatDirecc
    WHERE S.Id_CatSubDirec = _Id_CatSubDirec
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: La Subdirección no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       2) "SIN CAMBIOS" (IDEMPOTENCIA)
       - Si ya está en ese estado, no hacemos nada.
       ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: La Subdirección ya estaba Activa.'
            ELSE 'Sin cambios: La Subdirección ya estaba Inactiva.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    ELSE

        /* ------------------------------------------------------------------------------------
           3) CANDADO JERÁRQUICO AL ACTIVAR (B)
           ------------------------------------------------------------------------------------
           REGLA:
           - Si quieres ACTIVAR Subdirección (Nuevo_Estatus=1),
             su Dirección padre DEBE estar ACTIVA.
           - Si la Dirección está inactiva, bloquear con mensaje claro.
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 1 THEN
            IF v_Direccion_Activo = 0 THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede ACTIVAR la Subdirección porque su DIRECCIÓN PADRE está INACTIVA. Activa primero la Dirección.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           4) SI INTENTA DESACTIVAR: BLOQUEAR SI HAY GERENCIAS ACTIVAS (regla original)
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN
            SET v_Tmp = NULL;
            
            SELECT Id_CatGeren
              INTO v_Tmp
            FROM Cat_Gerencias_Activos
            WHERE Fk_Id_CatSubDirec = _Id_CatSubDirec
              AND Activo = 1
            LIMIT 1;

            IF v_Tmp IS NOT NULL THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar la Subdirección porque tiene GERENCIAS ACTIVAS. Desactiva primero las Gerencias.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           5) APLICAR CAMBIO DE ESTATUS
           ------------------------------------------------------------------------------------ */
        UPDATE Cat_Subdirecciones
        SET Activo = _Nuevo_Estatus,
            updated_at = NOW()
        WHERE Id_CatSubDirec = _Id_CatSubDirec;

        COMMIT;

        /* ------------------------------------------------------------------------------------
           6) RESPUESTA PARA FRONTEND
           ------------------------------------------------------------------------------------ */
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Subdirección Reactivada'
            ELSE 'Subdirección Desactivada'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    END IF;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusGerencia
   ============================================================================================
   OBJETIVO
   --------
   Activar/Desactivar (borrado lógico) una Gerencia:
      Cat_Gerencias_Activos.Activo (1 = activo, 0 = inactivo)

   REGLAS CRÍTICAS (INTEGRIDAD DE NEGOCIO)
   ---------------------------------------
   A) Al DESACTIVAR una Gerencia (Activo=0):
      - NO se permite si tiene EMPLEADOS ACTIVOS (Info_Personal).
      - NO se permite si tiene CAPACITACIONES ACTIVAS (Capacitaciones).
      Esto evita inconsistencias como "Empleado activo en una Gerencia fantasma".

   B) Al ACTIVAR una Gerencia (Activo=1)  <<<<<<<<<<<< CANDADO JERÁRQUICO (C)
      - NO se permite si su SUBDIRECCIÓN (Padre) está INACTIVA.
      - NO se permite si su DIRECCIÓN (Abuelo) está INACTIVA.
      
      Evita la inconsistencia visual y lógica:
         Dirección=0 -> Subdirección=0 -> Gerencia=1 (Rama rota).

   CONCURRENCIA / BLOQUEOS
   -----------------------
   - Bloqueamos en orden jerárquico estricto: 
        1. DIRECCIÓN (Abuelo)
        2. SUBDIRECCIÓN (Padre)
        3. GERENCIA (Hijo)
   
   - Usamos STRAIGHT_JOIN + FOR UPDATE para:
        * Asegurar que el motor de BD bloquee en ese orden exacto (evitar Deadlocks).
        * Evitar "carreras": que alguien desactive la Dirección justo en el milisegundo
          antes de que tú actives la Gerencia.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_CambiarEstatusGerencia$$
CREATE PROCEDURE SP_CambiarEstatusGerencia(
    IN _Id_CatGeren INT,
    IN _Nuevo_Estatus TINYINT /* 1 = Activo, 0 = Inactivo */
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Estatus actual de la Gerencia */
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;

    /* Datos jerárquicos para candado al ACTIVAR */
    DECLARE v_Id_Subdireccion INT DEFAULT NULL;
    DECLARE v_Subdireccion_Activo TINYINT(1) DEFAULT NULL;

    DECLARE v_Id_Direccion INT DEFAULT NULL;
    DECLARE v_Direccion_Activo TINYINT(1) DEFAULT NULL;

    /* Auxiliar para búsqueda de dependencias */
    DECLARE v_Tmp INT DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       HANDLER GENERAL
       - Si cualquier SQL falla: ROLLBACK y relanza el error real.
       ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE PARÁMETROS
       ---------------------------------------------------------------------------------------- */
    IF _Id_CatGeren IS NULL OR _Id_CatGeren <= 0 THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'ERROR: Id_CatGeren inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0,1) THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'ERROR: Estatus inválido (solo 0 o 1).';
    END IF;

    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       1) VALIDAR EXISTENCIA Y BLOQUEAR FILAS EN ORDEN JERÁRQUICO 
          (DIRECCIÓN -> SUBDIRECCIÓN -> GERENCIA)
       ----------------------------------------------------------------------------------------
       ¿POR QUÉ ASÍ?
       - Para el candado (C) necesitamos leer el estatus del Padre y del Abuelo.
       - Si no bloqueamos toda la cadena, la integridad no está garantizada en sistemas
         de alta concurrencia.
       - FOR UPDATE congela las 3 filas involucradas en esta transacción.
       ---------------------------------------------------------------------------------------- */
    SELECT
        1 AS Existe,
        G.Activo AS Activo_Gerencia,

        G.Fk_Id_CatSubDirec AS Id_Subdireccion,
        S.Activo AS Activo_Subdireccion,

        S.Fk_Id_CatDirecc AS Id_Direccion,
        D.Activo AS Activo_Direccion
    INTO
        v_Existe,
        v_Activo_Actual,
        v_Id_Subdireccion,
        v_Subdireccion_Activo,
        v_Id_Direccion,
        v_Direccion_Activo
    FROM Cat_Direcciones D
    STRAIGHT_JOIN Cat_Subdirecciones S ON S.Fk_Id_CatDirecc = D.Id_CatDirecc
    STRAIGHT_JOIN Cat_Gerencias_Activos G ON G.Fk_Id_CatSubDirec = S.Id_CatSubDirec
    WHERE G.Id_CatGeren = _Id_CatGeren
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'ERROR: La Gerencia no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       2) "SIN CAMBIOS" (IDEMPOTENCIA)
       - Si ya está en el estatus solicitado, no tocamos la BD y retornamos rápido.
       ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: La Gerencia ya estaba Activa.'
            ELSE 'Sin cambios: La Gerencia ya estaba Inactiva.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    ELSE

        /* ------------------------------------------------------------------------------------
           3) CANDADO JERÁRQUICO AL ACTIVAR (C)
           ------------------------------------------------------------------------------------
           REGLA:
           - Si quieres ACTIVAR Gerencia (Nuevo=1), toda su línea de mando debe estar viva.
           - Si Dirección o Subdirección están muertas (0), bloqueamos.
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 1 THEN
            
            /* Chequeo de Abuelo (Dirección) */
            IF v_Direccion_Activo = 0 THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede ACTIVAR la Gerencia porque su DIRECCIÓN (Abuelo) está INACTIVA. Active primero la Dirección.';
            END IF;

            /* Chequeo de Padre (Subdirección) */
            IF v_Subdireccion_Activo = 0 THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede ACTIVAR la Gerencia porque su SUBDIRECCIÓN (Padre) está INACTIVA. Active primero la Subdirección.';
            END IF;

        END IF;

        /* ------------------------------------------------------------------------------------
           4) SI INTENTA DESACTIVAR: BLOQUEAR SI HAY REFERENCIAS EN USO (HIJOS)
           - Revisamos las tablas hijas definidas en el esquema (Info_Personal, Capacitaciones).
           - Solo bloqueamos si el hijo está ACTIVO (Activo=1).
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN

            /* 4A) Info_Personal (Empleados activos) */
            IF EXISTS (
                SELECT 1 
                FROM Info_Personal 
                WHERE Fk_Id_CatGeren = _Id_CatGeren 
                  AND Activo = 1
                LIMIT 1
            ) THEN
                SIGNAL SQLSTATE '45000' 
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar la Gerencia porque tiene PERSONAL ACTIVO asignado. Reasigne o desactive al personal primero.';
            END IF;

            /* 4B) Capacitaciones (Cursos programados activos) */
            IF EXISTS (
                SELECT 1 
                FROM Capacitaciones 
                WHERE Fk_Id_CatGeren = _Id_CatGeren 
                  AND Activo = 1
                LIMIT 1
            ) THEN
                SIGNAL SQLSTATE '45000' 
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar la Gerencia porque tiene CAPACITACIONES ACTIVAS programadas. Cancele o reasigne las capacitaciones.';
            END IF;

        END IF;

        /* ------------------------------------------------------------------------------------
           5) APLICAR CAMBIO DE ESTATUS
           ------------------------------------------------------------------------------------ */
        UPDATE Cat_Gerencias_Activos
        SET Activo = _Nuevo_Estatus,
            updated_at = NOW()
        WHERE Id_CatGeren = _Id_CatGeren;

        COMMIT;

        /* ------------------------------------------------------------------------------------
           6) RESPUESTA PARA FRONTEND
           ------------------------------------------------------------------------------------ */
        SELECT CASE
            WHEN _Nuevo_Estatus = 1 THEN 'Gerencia Reactivada Exitosamente'
            ELSE 'Gerencia Desactivada (Eliminado Lógico)'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;

    END IF;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusDepartamento
   ============================================================================================
   OBJETIVO DE NEGOCIO
   -------------------
   Gestionar el Ciclo de Vida (Lifecycle) de un Departamento mediante el mecanismo de
   "Baja Lógica" (Soft Delete).
   
   Esto permite "apagar" un departamento sin perder su historial, pero evitando que
   se utilice en nuevas operaciones.

   ARQUITECTURA DE INTEGRIDAD (EL MODELO DE "DOBLE CANDADO")
   ---------------------------------------------------------
   Este SP implementa una defensa bidireccional para mantener la coherencia de la base de datos:

   1. CANDADO ASCENDENTE (AL ACTIVAR):
      - Principio: "Un hijo no puede vivir si su padre está muerto".
      - Validación: Si intentas reactivar un Departamento, el sistema verifica que su
        MUNICIPIO (Padre) esté ACTIVO.
      - Escenario evitado: Que aparezca un departamento disponible en un municipio que la
        empresa ya cerró operativamente.

   2. CANDADO DESCENDENTE (AL DESACTIVAR):
      - Principio: "No puedes demoler un edificio con gente adentro".
      - Validación: Si intentas desactivar un Departamento, el sistema verifica que NO
        existan EMPLEADOS ACTIVOS (`Info_Personal`) asignados a él.
      - Escenario evitado: Empleados "huérfanos" cuyo departamento desaparece de los reportes,
        rompiendo la cadena de mando.

   ESTRATEGIA DE CONCURRENCIA (BLOQUEO PESIMISTA)
   ----------------------------------------------
   - Problema: ¿Qué pasa si un Admin A activa el Departamento justo en el mismo milisegundo
     en que un Admin B desactiva el Municipio?
   - Solución: `SELECT ... FOR UPDATE`.
   - Efecto: Bloqueamos la fila del Departamento Y la del Municipio en una sola operación atómica.
     Esto serializa las transacciones y garantiza que la decisión se tome con datos frescos.

   RETORNO
   -------
   - Mensaje: Texto claro para la UI (Feedback de éxito o bloqueo).
   - Datos de Estado: El valor anterior y el nuevo, útil para actualizar interruptores en la UI.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusDepartamento`$$
CREATE PROCEDURE `SP_CambiarEstatusDepartamento`(
    IN _Id_CatDep INT,
    IN _Nuevo_Estatus TINYINT -- 1 = Activo, 0 = Inactivo
)
BEGIN
    /* ========================================================================================
       VARIABLES DE ESTADO Y CONTROL
       ======================================================================================== */
    /* Bandera de existencia del registro */
    DECLARE v_Existe INT DEFAULT NULL;
    
    /* Estado actual del Departamento (para verificar idempotencia) */
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;
    
    /* Contexto del Padre (Municipio) para el Candado Ascendente */
    DECLARE v_Id_Municipio INT DEFAULT NULL;
    DECLARE v_Municipio_Activo TINYINT(1) DEFAULT NULL;

    /* Auxiliar para búsqueda de dependencias (Hijos) */
    DECLARE v_Tmp INT DEFAULT NULL;

    /* ========================================================================================
       HANDLERS (MANEJO DE ERRORES)
       ======================================================================================== */
    /* Si ocurre cualquier error técnico (SQL), deshacemos cambios y propagamos el error */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       VALIDACIONES BÁSICAS (DEFENSIVE PROGRAMMING)
       ======================================================================================== */
    IF _Id_CatDep IS NULL OR _Id_CatDep <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: ID de Departamento inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: Estatus inválido (solo se permite 0 o 1).';
    END IF;

    /* ========================================================================================
       INICIO DE TRANSACCIÓN
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1: LECTURA Y BLOQUEO DE CONTEXTO (SNAPSHOT)
       ----------------------------------------------------------------------------------------
       Aquí ocurre la magia de la concurrencia:
       1. Buscamos el Departamento.
       2. Hacemos LEFT JOIN al Municipio (LEFT porque podría ser NULL en datos legados).
       3. FOR UPDATE: Congela ambas filas. Nadie puede modificar el Municipio ni el Departamento
          hasta que nosotros terminemos. */
    
    SELECT 
        1,
        `Dep`.`Activo`, 
        `Dep`.`Fk_Id_Municipio_CatDep`, 
        `Mun`.`Activo`
    INTO 
        v_Existe,
        v_Activo_Actual, 
        v_Id_Municipio, 
        v_Municipio_Activo
    FROM `Cat_Departamentos` `Dep`
    LEFT JOIN `Municipio` `Mun` ON `Dep`.`Fk_Id_Municipio_CatDep` = `Mun`.`Id_Municipio`
    WHERE `Dep`.`Id_CatDep` = _Id_CatDep 
    LIMIT 1
    FOR UPDATE;

    /* Validación de existencia */
    IF v_Existe IS NULL THEN 
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO: El Departamento no existe.'; 
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2: IDEMPOTENCIA (DETECCIÓN DE "SIN CAMBIOS")
       ----------------------------------------------------------------------------------------
       Si el usuario pide "Activar" algo que ya está "Activo", no tiene sentido gastar
       recursos de base de datos (I/O, Logs). Retornamos éxito inmediato. */
    
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT; -- Liberamos locks inmediatamente
        
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: El Departamento ya se encontraba Activo.'
            ELSE 'Sin cambios: El Departamento ya se encontraba Inactivo.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
        
    ELSE
        /* ====================================================================================
           SI EL ESTADO VA A CAMBIAR, EJECUTAMOS LAS REGLAS DE NEGOCIO
           ==================================================================================== */

        /* ------------------------------------------------------------------------------------
           PASO 3: REGLA DE ACTIVACIÓN (CANDADO ASCENDENTE)
           "Para revivir al hijo, el padre debe estar vivo".
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 1 THEN
            /* Solo validamos si tiene un municipio asignado (Id no nulo) */
            IF v_Id_Municipio IS NOT NULL THEN
                /* Si el municipio existe pero está marcado como inactivo (0) */
                IF v_Municipio_Activo = 0 THEN
                    SIGNAL SQLSTATE '45000' 
                        SET MESSAGE_TEXT = 'BLOQUEO JERÁRQUICO: No se puede ACTIVAR el Departamento porque su MUNICIPIO está INACTIVO. Debe activar primero el Municipio.';
                END IF;
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           PASO 4: REGLA DE DESACTIVACIÓN (CANDADO DESCENDENTE)
           "No puedes cerrar la oficina si hay gente trabajando dentro".
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN
            SET v_Tmp = NULL;
            
            /* Buscamos dependencias en Info_Personal.
               IMPORTANTE: Solo nos importan los empleados con `Activo = 1`.
               Si hay empleados históricos (inactivos), no bloqueamos la baja del departamento. */
            SELECT 1 INTO v_Tmp
            FROM `Info_Personal` 
            WHERE `Fk_Id_CatDep` = _Id_CatDep 
              AND `Activo` = 1 
            LIMIT 1;

            IF v_Tmp IS NOT NULL THEN
                 SIGNAL SQLSTATE '45000' 
                    SET MESSAGE_TEXT = 'BLOQUEO DE INTEGRIDAD: El Departamento tiene PERSONAL ACTIVO asignado. Por favor, reasigne o desactive al personal antes de dar de baja este departamento.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           PASO 5: EJECUCIÓN DEL CAMBIO (PERSISTENCIA)
           ------------------------------------------------------------------------------------ */
        UPDATE `Cat_Departamentos` 
        SET `Activo` = _Nuevo_Estatus, 
            `updated_at` = NOW() 
        WHERE `Id_CatDep` = _Id_CatDep;
        
        COMMIT; 
        
        /* ------------------------------------------------------------------------------------
           PASO 6: RESPUESTA FINAL AL CLIENTE
           ------------------------------------------------------------------------------------ */
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Departamento Reactivado Exitosamente.'
            ELSE 'Departamento Desactivado (Baja Lógica) Correctamente.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
        
    END IF;
END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusCentroTrabajo
   ============================================================================================

   OBJETIVO
   --------
   Activar/Desactivar (borrado lógico) un Centro de Trabajo (CT):
      Cat_Centros_Trabajo.Activo (1 = activo, 0 = inactivo)

   REGLAS CRÍTICAS (INTEGRIDAD DE NEGOCIO)
   ---------------------------------------
   A) Al DESACTIVAR un Centro de Trabajo (Activo=0):
      - NO se permite si tiene EMPLEADOS ACTIVOS (`Info_Personal`).
      - Esto evita la inconsistencia de tener personal asignado a un lugar que "ya no existe"
        operativamente.

   B) Al ACTIVAR un Centro de Trabajo (Activo=1) << CANDADO JERÁRQUICO
      - NO se permite si su MUNICIPIO (Padre) está INACTIVO.
      - Si el CT tiene asignado un municipio, y ese municipio fue dado de baja,
        el CT no puede operar.
      - Nota: Si el CT no tiene municipio asignado (NULL, datos sucios), se permite activar
        (asumiendo que se corregirá la ubicación después).

   CONCURRENCIA / BLOQUEOS
   -----------------------
   - Bloqueamos en orden: CENTRO DE TRABAJO -> MUNICIPIO
   - Usamos `LEFT JOIN` + `FOR UPDATE` para:
        * Asegurar el bloqueo de la fila del CT.
        * Si tiene municipio, bloquear también la fila del Municipio para evitar que
          alguien lo desactive mientras nosotros activamos el CT.
   - El uso de `LEFT JOIN` es vital aquí porque tus datos históricos pueden tener
     municipios nulos, y no queremos que el SP falle o no encuentre el registro en esos casos.

   RESULTADO
   ---------
   Retorna:
     - Mensaje: Feedback claro para el usuario.
     - Activo_Anterior / Activo_Nuevo: Para auditoría o actualización de UI.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusCentroTrabajo`$$
CREATE PROCEDURE `SP_CambiarEstatusCentroTrabajo`(
    IN _Id_CatCT INT,
    IN _Nuevo_Estatus TINYINT -- 1 = Activo, 0 = Inactivo
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Existe INT DEFAULT NULL;

    /* Estatus actual del Centro de Trabajo */
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;

    /* Datos del padre (Municipio) para el candado jerárquico al ACTIVAR */
    DECLARE v_Id_Municipio INT DEFAULT NULL;
    DECLARE v_Municipio_Activo TINYINT(1) DEFAULT NULL;

    /* Auxiliar para búsqueda de dependencias (Hijos) */
    DECLARE v_Tmp INT DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       HANDLER GENERAL
       - Si cualquier SQL falla: ROLLBACK y relanza el error real.
       ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE PARÁMETROS
       ---------------------------------------------------------------------------------------- */
    IF _Id_CatCT IS NULL OR _Id_CatCT <= 0 THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'ERROR: Id_CatCT inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0,1) THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'ERROR: Estatus inválido (solo 0 o 1).';
    END IF;

    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       1) VALIDAR EXISTENCIA Y BLOQUEAR FILAS (CT -> MUNICIPIO)
       ----------------------------------------------------------------------------------------
       - Usamos LEFT JOIN porque el CT podría no tener municipio (datos legacy).
       - FOR UPDATE bloquea el CT y, si existe el municipio, también lo bloquea.
       ---------------------------------------------------------------------------------------- */
    SELECT 
        1 AS Existe,
        CT.Activo AS Activo_CT,
        CT.Fk_Id_Municipio_CatCT AS Id_Municipio,
        M.Activo AS Activo_Municipio
    INTO 
        v_Existe,
        v_Activo_Actual,
        v_Id_Municipio,
        v_Municipio_Activo
    FROM `Cat_Centros_Trabajo` CT
    LEFT JOIN `Municipio` M ON CT.Fk_Id_Municipio_CatCT = M.Id_Municipio
    WHERE CT.Id_CatCT = _Id_CatCT
    LIMIT 1
    FOR UPDATE;

    IF v_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El Centro de Trabajo no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       2) "SIN CAMBIOS" (IDEMPOTENCIA)
       - Si ya está en el estatus solicitado, no tocamos la BD y retornamos rápido.
       ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: El Centro de Trabajo ya estaba Activo.'
            ELSE 'Sin cambios: El Centro de Trabajo ya estaba Inactivo.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
    ELSE

        /* ------------------------------------------------------------------------------------
           3) CANDADO JERÁRQUICO AL ACTIVAR (B)
           ------------------------------------------------------------------------------------
           REGLA:
           - Si quieres ACTIVAR el CT (Nuevo_Estatus=1), su Municipio padre DEBE estar ACTIVO.
           - Excepción: Si v_Id_Municipio es NULL (no tiene padre), permitimos activar 
             (porque no hay padre que valide).
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 1 THEN
            -- Solo validamos si tiene un municipio asignado
            IF v_Id_Municipio IS NOT NULL THEN
                -- Si el municipio existe pero está inactivo (0)
                IF v_Municipio_Activo = 0 THEN
                    SIGNAL SQLSTATE '45000' 
                        SET MESSAGE_TEXT = 'BLOQUEADO: No se puede ACTIVAR el Centro de Trabajo porque su MUNICIPIO está INACTIVO. Active primero el Municipio.';
                END IF;
                -- Nota: Si v_Municipio_Activo es NULL pero v_Id_Municipio NO era NULL, 
                -- significa integridad rota (FK apunta a nada), pero el LEFT JOIN maneja eso.
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           4) SI INTENTA DESACTIVAR: BLOQUEAR SI HAY EMPLEADOS ACTIVOS (A)
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN
            
            /* 4A) Verificar Info_Personal (Empleados) */
            SET v_Tmp = NULL;
            
            SELECT 1
              INTO v_Tmp
            FROM `Info_Personal`
            WHERE `Fk_Id_CatCT` = _Id_CatCT
              AND `Activo` = 1 -- Solo nos importan los empleados ACTIVOS
            LIMIT 1;

            IF v_Tmp IS NOT NULL THEN
                SIGNAL SQLSTATE '45000' 
                    SET MESSAGE_TEXT = 'BLOQUEADO: No se puede desactivar el Centro de Trabajo porque tiene EMPLEADOS ACTIVOS asignados. Reasigne o desactive al personal primero.';
            END IF;

        END IF;

        /* ------------------------------------------------------------------------------------
           5) APLICAR CAMBIO DE ESTATUS
           ------------------------------------------------------------------------------------ */
        UPDATE `Cat_Centros_Trabajo`
        SET `Activo` = _Nuevo_Estatus,
            `updated_at` = NOW() -- Forzamos actualización de timestamp
        WHERE `Id_CatCT` = _Id_CatCT;

        COMMIT;

        /* ------------------------------------------------------------------------------------
           6) RESPUESTA PARA FRONTEND
           ------------------------------------------------------------------------------------ */
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Centro de Trabajo Reactivado Exitosamente'
            ELSE 'Centro de Trabajo Desactivado (Eliminado Lógico)'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;

    END IF;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusSede
   ============================================================================================
   OBJETIVO DE NEGOCIO
   -------------------
   Gestionar el Ciclo de Vida (Lifecycle) de una Sede (CASES) mediante el mecanismo de
   "Baja Lógica" (Soft Delete).
   
   Esto permite "apagar" una Sede sin eliminar su historial de cursos, pero evitando que
   se utilice en nuevas programaciones operativas.

   ARQUITECTURA DE INTEGRIDAD (EL MODELO DE "DOBLE CANDADO")
   ---------------------------------------------------------
   Este procedimiento implementa una defensa bidireccional para garantizar la coherencia
   de la base de datos ante cambios de estado:

   1. CANDADO ASCENDENTE (AL ACTIVAR - "UPSTREAM CHECK"):
      - Principio: "Una sucursal no puede operar si la ciudad está clausurada".
      - Regla de Negocio: Si intentas REACTIVAR una Sede (Activo=1), el sistema verifica 
        estrictamente que su MUNICIPIO Padre esté también ACTIVO.
      - Escenario evitado: Que aparezca disponible una Sede en un Municipio que la empresa
        ya cerró operativamente.

   2. CANDADO DESCENDENTE (AL DESACTIVAR - "DOWNSTREAM CHECK"):
      - Principio: "No puedes demoler la escuela con los alumnos adentro".
      - Regla de Negocio: Si intentas DESACTIVAR una Sede (Activo=0), el sistema debe verificar
        que NO existan cursos o capacitaciones programadas y activas en esa ubicación.
      - Escenario evitado: Cursos "huérfanos" cuya sede desaparece de los reportes, rompiendo
        la trazabilidad operativa.

   ESTRATEGIA DE CONCURRENCIA (BLOQUEO PESIMISTA / PESSIMISTIC LOCKING)
   --------------------------------------------------------------------
   - Problema: ¿Qué sucede si el Administrador A activa la Sede justo en el mismo milisegundo
     en que el Administrador B desactiva el Municipio? Se crearía una inconsistencia.
   - Solución: Utilizamos `SELECT ... FOR UPDATE` al inicio de la transacción.
   - Efecto: Esto "congela" (bloquea para escritura) tanto la fila de la Sede como la fila 
     del Municipio en una operación atómica. Esto serializa las transacciones y garantiza 
     que la decisión se tome siempre con datos frescos y estables.

   RETORNO
   -------
   Devuelve una tabla con:
     - Mensaje: Texto claro para la UI (Feedback de éxito o razón del bloqueo).
     - Activo_Anterior / Activo_Nuevo: Datos útiles para auditar el cambio o actualizar switches en UI.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusSede`$$
CREATE PROCEDURE `SP_CambiarEstatusSede`(
    IN _Id_Sede       INT,     -- ID de la Sede a modificar
    IN _Nuevo_Estatus TINYINT  -- 1 = Activo (Visible), 0 = Inactivo (Oculto/Borrado Lógico)
)
BEGIN
    /* ========================================================================================
       PARTE 0: VARIABLES DE ESTADO Y CONTROL
       ======================================================================================== */
    /* Bandera para validar si el registro existe antes de proceder */
    DECLARE v_Existe INT DEFAULT NULL;
    
    /* Estado actual de la Sede (vital para verificar idempotencia: "Si ya está así, no hagas nada") */
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;
    
    /* Contexto del Padre (Municipio) para aplicar el Candado Ascendente */
    DECLARE v_Id_Municipio INT DEFAULT NULL;
    DECLARE v_Municipio_Activo TINYINT(1) DEFAULT NULL;

    /* Auxiliar para búsqueda de dependencias (Hijos/Cursos) */
    DECLARE v_Tmp INT DEFAULT NULL;

    /* ========================================================================================
       PARTE 1: HANDLERS (MANEJO DE ERRORES TÉCNICOS)
       ======================================================================================== */
    /* Handler Genérico: Si ocurre cualquier error SQL (conexión, deadlock, sintaxis), 
       deshacemos cualquier cambio pendiente (ROLLBACK) y propagamos el error original (RESIGNAL) 
       para que el Backend sepa qué pasó. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       PARTE 2: VALIDACIONES BÁSICAS (DEFENSIVE PROGRAMMING)
       ======================================================================================== */
    /* Evitamos abrir transacciones costosas si los parámetros de entrada son basura */
    IF _Id_Sede IS NULL OR _Id_Sede <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: El ID de la Sede es inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: Estatus inválido (solo se permite 0 o 1).';
    END IF;

    /* ========================================================================================
       PARTE 3: INICIO DE TRANSACCIÓN Y BLOQUEO
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1: LECTURA Y BLOQUEO DE CONTEXTO (SNAPSHOT)
       ----------------------------------------------------------------------------------------
       Aquí ocurre la magia de la concurrencia y la seguridad.
       1. Buscamos la Sede por su ID.
       2. Hacemos LEFT JOIN al Municipio (LEFT es más robusto por si la integridad referencial 
          estuviera rota en datos legacy).
       3. CLAUSULA `FOR UPDATE`: Esto es crítico. Bloquea las filas encontradas.
          - Nadie puede eliminar la Sede mientras decidimos.
          - Nadie puede desactivar el Municipio mientras decidimos. */
    
    SELECT 
        1,
        `S`.`Activo`, 
        `S`.`Fk_Id_Municipio`, 
        `Mun`.`Activo`
    INTO 
        v_Existe,
        v_Activo_Actual, 
        v_Id_Municipio, 
        v_Municipio_Activo
    FROM `Cat_Cases_Sedes` `S`
    LEFT JOIN `Municipio` `Mun` ON `S`.`Fk_Id_Municipio` = `Mun`.`Id_Municipio`
    WHERE `S`.`Id_CatCases_Sedes` = _Id_Sede 
    LIMIT 1
    FOR UPDATE;

    /* Verificación de existencia */
    IF v_Existe IS NULL THEN 
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO: La Sede solicitada no existe.'; 
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2: IDEMPOTENCIA (OPTIMIZACIÓN "SIN CAMBIOS")
       ----------------------------------------------------------------------------------------
       Si el usuario pide "Activar" algo que ya está "Activo", no tiene sentido gastar
       recursos de base de datos (I/O, Logs de transacción). Retornamos éxito inmediato. */
    
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT; -- Liberamos los locks inmediatamente
        
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: La Sede ya se encontraba Activa.'
            ELSE 'Sin cambios: La Sede ya se encontraba Inactiva.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
        
    ELSE
        /* ====================================================================================
           SI EL ESTADO VA A CAMBIAR, EJECUTAMOS LAS REGLAS DE NEGOCIO (LOS CANDADOS)
           ==================================================================================== */

        /* ------------------------------------------------------------------------------------
           PASO 3: REGLA DE ACTIVACIÓN (CANDADO ASCENDENTE)
           "El hijo no puede vivir si el padre está muerto."
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 1 THEN
            /* Verificamos el estado del Municipio Padre */
            IF v_Id_Municipio IS NOT NULL THEN
                /* Si el municipio existe pero está marcado como inactivo (0) -> BLOQUEO */
                IF v_Municipio_Activo = 0 THEN
                    SIGNAL SQLSTATE '45000' 
                        SET MESSAGE_TEXT = 'BLOQUEO JERÁRQUICO: No se puede ACTIVAR la Sede porque su MUNICIPIO está INACTIVO. Debe activar primero el Municipio correspondiente.';
                END IF;
            ELSE
                /* Caso borde: La Sede no tiene municipio (Integridad de datos rota).
                   Aunque la tabla tiene FK NOT NULL, si llegara a pasar (por manipulación directa),
                   impedimos la activación hasta que se arregle. */
                 SIGNAL SQLSTATE '45000' 
                        SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD: La Sede no tiene un Municipio válido asignado. Edite la Sede para corregir su ubicación antes de activarla.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           PASO 4: REGLA DE DESACTIVACIÓN (CANDADO DESCENDENTE)
           "No puedes cerrar la instalación si hay operaciones en curso."
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN
            SET v_Tmp = NULL;
            
            /* [NOTA DE ARQUITECTURA]: 
               Aquí se debe validar contra la tabla de `Capacitaciones` o `Cursos`.
               Como esa tabla se definirá en el siguiente sprint, dejamos la estructura lógica preparada.
               
               Lógica Futura:
               SELECT 1 INTO v_Tmp FROM `Cursos` WHERE `Fk_Id_Sede` = _Id_Sede AND `Estatus` = 'EN_CURSO' LIMIT 1;
               IF v_Tmp IS NOT NULL THEN SIGNAL ERROR... END IF;
            */
            
            /* Por el momento, si no hay hijos definidos, permitimos la desactivación */
        END IF;

        /* ------------------------------------------------------------------------------------
           PASO 5: EJECUCIÓN DEL CAMBIO (PERSISTENCIA)
           ------------------------------------------------------------------------------------
           Si pasamos todos los candados, procedemos a actualizar el registro. */
           
        UPDATE `Cat_Cases_Sedes` 
        SET `Activo` = _Nuevo_Estatus, 
            `updated_at` = NOW() -- Actualizamos la auditoría temporal
        WHERE `Id_CatCases_Sedes` = _Id_Sede;
        
        COMMIT; -- Confirmamos la transacción y liberamos locks
        
        /* ------------------------------------------------------------------------------------
           PASO 6: RESPUESTA FINAL AL CLIENTE
           ------------------------------------------------------------------------------------ */
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Sede Reactivada Exitosamente.'
            ELSE 'Sede Desactivada (Baja Lógica) Correctamente.'
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
        
    END IF;
END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusRegimen
   ============================================================================================
   1. OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------
   Gestionar el Ciclo de Vida (Lifecycle) de un "Régimen de Contratación" mediante el mecanismo
   de "Baja Lógica" (Soft Delete).

   Este procedimiento permite al Administrador:
     A) DESACTIVAR (Ocultar): Marcar un régimen como obsoleto para que no aparezca en los
        selectores de "Nuevo Empleado", evitando asignaciones futuras de contratos extintos.
     B) REACTIVAR (Mostrar): Recuperar un régimen histórico para volver a utilizarlo.

   2. ARQUITECTURA DE INTEGRIDAD (EL CANDADO DESCENDENTE)
   ------------------------------------------------------
   El mayor riesgo de desactivar un catálogo maestro es la "Orfandad Operativa".
   
   Regla Crítica: "No puedes derogar una ley si hay ciudadanos amparados por ella".
   
   - Validación: Si se solicita DESACTIVAR (`_Nuevo_Estatus = 0`), el sistema consulta
     proactivamente la tabla de Personal (`Info_Personal`).
   - Condición de Bloqueo: Si existe AL MENOS UN empleado con estatus `Activo = 1` asignado
     a este Régimen, la operación se bloquea inmediatamente.
   - Justificación: Permitir esta acción rompería los reportes de Nómina y RRHH, generando
     empleados "activos" bajo un régimen "inexistente".

   3. ESTRATEGIA DE CONCURRENCIA (BLOQUEO PESIMISTA / ACID)
   --------------------------------------------------------
   - Problema: ¿Qué pasa si un Admin A desactiva el régimen justo en el milisegundo en que
     un Admin B está dando de alta a un empleado con ese régimen?
   - Solución: Se aplica `SELECT ... FOR UPDATE` al inicio de la transacción.
   - Efecto: Esto "congela" la fila del Régimen. Cualquier otra transacción que intente
     usar este registro deberá esperar a que terminemos de decidir su destino.

   4. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   ------------------------------------------
   - Antes de escribir en disco, verificamos si el registro ya tiene el estatus solicitado.
   - Si `Activo_Actual == Nuevo_Estatus`, el SP retorna éxito sin realizar el UPDATE.
   - Beneficio: Ahorro de I/O, reducción de crecimiento del Log de Transacciones y preservación
     del timestamp `updated_at` (no se modifica si no hubo un cambio real).

   RESULTADO (OUTPUT CONTRACT)
   ---------------------------
   Retorna un dataset informativo:
     - Mensaje: Feedback de éxito o explicación del bloqueo.
     - Activo_Anterior / Activo_Nuevo: Para que el Frontend actualice el estado visual del "Switch".
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusRegimen`$$
CREATE PROCEDURE `SP_CambiarEstatusRegimen`(
    IN _Id_Regimen    INT,     -- ID del Régimen a modificar
    IN _Nuevo_Estatus TINYINT  -- 1 = Activar (Visible), 0 = Desactivar (Oculto)
)
BEGIN
    /* ========================================================================================
       BLOQUE 0: VARIABLES DE ESTADO Y CONTROL
       ======================================================================================== */
    
    /* Variables para capturar la "foto" del registro antes de modificarlo */
    DECLARE v_Existe        INT DEFAULT NULL;
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;
    
    /* Variable auxiliar para verificar dependencias en tablas hijas (Empleados) */
    DECLARE v_Dependencias  INT DEFAULT NULL;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (MANEJO DE ERRORES TÉCNICOS)
       ======================================================================================== */
    
    /* Handler Genérico: Ante cualquier fallo SQL (Deadlock, Conexión, Sintaxis), 
       garantizamos que la transacción se revierta (ROLLBACK) para no dejar datos sucios. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: VALIDACIONES PREVIAS (DEFENSIVE PROGRAMMING)
       ======================================================================================== */
    
    /* Validación de Integridad de Entrada: Evitamos procesar basura. */
    IF _Id_Regimen IS NULL OR _Id_Regimen <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: El ID del Régimen es inválido.';
    END IF;

    /* Validación de Dominio: El estatus solo puede ser binario. */
    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: El Estatus proporcionado es inválido (solo se permite 0 o 1).';
    END IF;

    /* ========================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y LECTURA BLOQUEANTE
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: OBTENCIÓN DE SNAPSHOT CON BLOQUEO (FOR UPDATE)
       - Buscamos el registro.
       - Adquirimos un candado de escritura (Write Lock) sobre la fila.
       - Esto asegura la serialización: Nadie más puede tocar este régimen hasta que terminemos.
       ---------------------------------------------------------------------------------------- */
    SELECT 1, `Activo` 
    INTO v_Existe, v_Activo_Actual
    FROM `Cat_Regimenes_Trabajo` 
    WHERE `Id_CatRegimen` = _Id_Regimen 
    LIMIT 1 
    FOR UPDATE;

    /* Si el puntero es NULL, el registro no existe */
    IF v_Existe IS NULL THEN 
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO: El Régimen solicitado no existe en el catálogo.'; 
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: VERIFICACIÓN DE IDEMPOTENCIA (SIN CAMBIOS)
       Si el usuario pide "Activar" y ya está activo, salimos inmediatamente.
       ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        
        COMMIT; -- Liberamos el bloqueo inmediatamente
        
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Sin cambios: El Régimen ya se encontraba Activo.' 
            ELSE 'Sin cambios: El Régimen ya se encontraba Inactivo.' 
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
        
    ELSE
        /* ====================================================================================
           BLOQUE 4: APLICACIÓN DE REGLAS DE NEGOCIO (SI HAY CAMBIO DE ESTADO)
           ==================================================================================== */

        /* ------------------------------------------------------------------------------------
           PASO 4.1: REGLA DE DESACTIVACIÓN (CANDADO DE INTEGRIDAD REFERENCIAL)
           Solo ejecutamos esto si _Nuevo_Estatus es 0 (Apagar).
           ------------------------------------------------------------------------------------ */
        IF _Nuevo_Estatus = 0 THEN
            
            SET v_Dependencias = NULL;
            
            /* BÚSQUEDA DE DEPENDENCIAS ACTIVAS:
               Consultamos la tabla `Info_Personal`.
               CRITERIO ESTRICTO: Solo nos preocupan los empleados con `Activo = 1`.
               (Los empleados dados de baja en el pasado no impiden desactivar el régimen hoy). */
            
            SELECT 1 INTO v_Dependencias
            FROM `Info_Personal`
            WHERE `Fk_Id_CatRegimen` = _Id_Regimen
              AND `Activo` = 1 -- Solo empleados vigentes
            LIMIT 1;

            /* SI SE ENCUENTRA AL MENOS UN EMPLEADO... BLOQUEO TOTAL. */
            IF v_Dependencias IS NOT NULL THEN
                SIGNAL SQLSTATE '45000' 
                    SET MESSAGE_TEXT = 'BLOQUEO DE INTEGRIDAD: No es posible desactivar este Régimen porque existen EMPLEADOS ACTIVOS asignados a él. Debe reasignar o dar de baja al personal antes de continuar.';
            END IF;
        END IF;

        /* ------------------------------------------------------------------------------------
           PASO 4.2: EJECUCIÓN DEL UPDATE (PERSISTENCIA)
           Si pasamos los candados, aplicamos el cambio.
           ------------------------------------------------------------------------------------ */
        UPDATE `Cat_Regimenes_Trabajo` 
        SET `Activo` = _Nuevo_Estatus, 
            `updated_at` = NOW() -- Auditoría: Registramos cuándo ocurrió el cambio
        WHERE `Id_CatRegimen` = _Id_Regimen;
        
        /* ------------------------------------------------------------------------------------
           PASO 4.3: CONFIRMACIÓN
           ------------------------------------------------------------------------------------ */
        COMMIT; -- Se hacen efectivos los cambios y se libera la fila
        
        /* ------------------------------------------------------------------------------------
           PASO 4.4: RESPUESTA AL FRONTEND
           Devolvemos el estado final para que la UI se actualice correctamente.
           ------------------------------------------------------------------------------------ */
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'Régimen Reactivado Exitosamente.' 
            ELSE 'Régimen Desactivado (Baja Lógica) Correctamente.' 
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
        
    END IF;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusRegion
   ============================================================================================
   
   1. DEFINICIÓN DEL OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento implementa la lógica de "Gestión de Ciclo de Vida" para la entidad [Regiones].
   Su función principal es administrar el mecanismo de BAJA LÓGICA (Soft Delete), permitiendo:
     A) SUSPENSIÓN OPERATIVA (Desactivar): Ocultar una región de los selectores operativos sin
        eliminar su historial transaccional.
     B) RESTAURACIÓN (Activar): Recuperar una región histórica para su uso activo.

   2. ARQUITECTURA DE INTEGRIDAD REFERENCIAL (CRITICAL PATH)
   ----------------------------------------------------------------------------------------------------
   Se aplica una política estricta de "No Huérfanos" (Orphan Prevention Strategy).
   - REGLA DE BLOQUEO: No se permite desactivar una Región si existen recursos humanos (Personal)
     actualmente asignados y activos en ella.
   - JUSTIFICACIÓN: Evita inconsistencias sistémicas donde un empleado activo pertenece a una
     ubicación administrativa inexistente.

   3. ESTRATEGIA DE CONCURRENCIA Y AISLAMIENTO (ACID COMPLIANCE)
   ----------------------------------------------------------------------------------------------------
   - NIVEL DE AISLAMIENTO: Utiliza 'SELECT ... FOR UPDATE' (Pessimistic Locking).
   - OBJETIVO: Serializar el acceso al registro específico de la región durante la transacción.
   - ESCENARIO EVITADO (RACE CONDITION): Previene que un Administrador A desactive la región
     mientras un Administrador B asigna simultáneamente un nuevo empleado a dicha región.

   4. OPTIMIZACIÓN DE RECURSOS (IDEMPOTENCY)
   ----------------------------------------------------------------------------------------------------
   - El procedimiento es IDEMPOTENTE. Antes de iniciar escrituras en disco (I/O costoso), verifica
     si el estado deseado ya es el estado actual. Si son iguales, aborta la escritura y retorna
     éxito, preservando los timestamps de auditoría y reduciendo la carga del Transaction Log.

   5. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset (Single Row) con:
     - Mensaje (VARCHAR): Feedback legible para el usuario final.
     - Activo_Anterior (TINYINT): Estado previo para rollback visual en Frontend.
     - Activo_Nuevo (TINYINT): Estado final confirmado.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusRegion`$$

CREATE PROCEDURE `SP_CambiarEstatusRegion`(
    IN _Id_Region    INT,     -- Identificador Único (PK) de la Región objetivo en `Cat_Regiones_Trabajo`.
    IN _Nuevo_Estatus TINYINT -- Flag de Estado Solicitado: 1 = Activo (Visible), 0 = Inactivo (Soft Delete).
)
THIS_PROC: BEGIN
    /* ================================================================================================
       SECCIÓN 1: DEFINICIÓN DE CONTEXTO Y VARIABLES DE ESTADO
       Propósito: Inicializar los contenedores de datos que mantendrán la "foto" (Snapshot) del
       registro antes de cualquier modificación.
       ================================================================================================ */
    
    -- [Flag de Existencia]: Determina si el ID proporcionado apunta a un registro válido en la BDD.
    DECLARE v_Existe        INT DEFAULT NULL;
    
    -- [Snapshot de Estado]: Almacena el valor actual de la columna `Activo` antes de la modificación.
    -- Vital para la verificación de idempotencia.
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;
    
    -- [Semáforo de Dependencias]: Variable auxiliar utilizada durante la validación de integridad.
    -- Si cambia a NOT NULL, indica que existe un bloqueo de negocio (ej. Empleados activos).
    DECLARE v_Dependencias  INT DEFAULT NULL;

    /* ================================================================================================
       SECCIÓN 2: GESTIÓN DE EXCEPCIONES Y ATOMICIDAD (ERROR HANDLING)
       Propósito: Garantizar que la base de datos nunca quede en un estado inconsistente ante fallos.
       ================================================================================================ */
    
    -- [Safety Net]: Captura cualquier error SQL (SQLEXCEPTION) no controlado explícitamente.
    -- ACCIÓN: Ejecuta un ROLLBACK total para deshacer cambios pendientes y propaga el error (RESIGNAL)
    -- para que la capa de aplicación (Backend/API) sea notificada del fallo técnico.
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       SECCIÓN 3: PROTOCOLO DE VALIDACIÓN DE ENTRADA (DEFENSIVE PROGRAMMING)
       Propósito: Rechazar peticiones malformadas ("Fail Fast") antes de consumir recursos de transacción.
       ================================================================================================ */
    
    -- [Validación de Identidad]: El ID debe ser un entero positivo.
    IF _Id_Region IS NULL OR _Id_Region <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El ID de la Región es inválido o nulo.';
    END IF;

    -- [Validación de Dominio]: El estatus debe ser binario estrictamente (0 o 1).
    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El valor de Estatus está fuera de rango (Permitido: 0, 1).';
    END IF;

    /* ================================================================================================
       SECCIÓN 4: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       Propósito: Aislar el registro objetivo para asegurar consistencia durante la lectura y escritura.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 4.1: ADQUISICIÓN DE SNAPSHOT CON BLOQUEO DE ESCRITURA (FOR UPDATE)
       
       Mecánica Técnica:
       Se realiza una lectura del registro usando la cláusula `FOR UPDATE`.
       
       Efecto en el Motor de Base de Datos:
       1. Verifica si el registro existe.
       2. Coloca un "Row-Level Lock" (X-Lock) sobre la fila específica del ID.
       3. Cualquier otra transacción que intente leer o escribir en ESTA fila deberá esperar
          hasta que esta transacción termine (COMMIT o ROLLBACK).
       ------------------------------------------------------------------------------------------------ */
    SELECT 1, `Activo` 
    INTO v_Existe, v_Activo_Actual
    FROM `Cat_Regiones_Trabajo` 
    WHERE `Id_CatRegion` = _Id_Region 
    LIMIT 1 
    FOR UPDATE;

    -- [Verificación de Existencia]: Si el SELECT no encontró nada, v_Existe sigue siendo NULL.
    IF v_Existe IS NULL THEN 
        -- Nota: No se requiere ROLLBACK explícito aquí porque no se ha modificado nada aún,
        -- pero el SIGNAL abortará la transacción implícitamente.
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: La Región solicitada no existe en el catálogo maestro.'; 
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 4.2: VERIFICACIÓN DE IDEMPOTENCIA (OPTIMIZACIÓN)
       
       Lógica de Negocio:
       "Si me pides encender la luz, pero la luz ya está encendida, no toco el interruptor".
       
       Beneficio Técnico:
       - Evita un UPDATE innecesario (ahorra ciclos de CPU y escrituras en disco).
       - Evita alterar la columna `updated_at` innecesariamente (preserva la auditoría real).
       ------------------------------------------------------------------------------------------------ */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        
        COMMIT; -- Liberamos el bloqueo (Lock) inmediatamente.
        
        -- Retorno informativo indicando que no hubo cambios.
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'OPERACIÓN OMITIDA: La Región ya se encuentra en estado ACTIVO.' 
            ELSE 'OPERACIÓN OMITIDA: La Región ya se encuentra en estado INACTIVO.' 
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
        
        -- Salimos del bloque principal para terminar el SP.
        LEAVE THIS_PROC; 
    END IF;

    /* ================================================================================================
       SECCIÓN 5: EVALUACIÓN DE REGLAS DE NEGOCIO COMPLEJAS (INTEGRIDAD REFERENCIAL)
       Propósito: Validar que el cambio de estado no rompa la coherencia de los datos relacionados.
       ================================================================================================ */

    /* ------------------------------------------------------------------------------------------------
       PASO 5.1: REGLA DE "BAJA SEGURA" (SAFE DELETE GUARD)
       Condición: Esta validación SOLO se ejecuta si intentamos DESACTIVAR (_Nuevo_Estatus = 0).
       Objetivo: Proteger a las tablas hijas (`Info_Personal`) de quedar huérfanas lógica y funcionalmente.
       ------------------------------------------------------------------------------------------------ */
    IF _Nuevo_Estatus = 0 THEN
        
        -- Reiniciamos el semáforo
        SET v_Dependencias = NULL;
        
        -- [Sondeo de Dependencias]:
        -- Buscamos si existe AL MENOS UN registro en la tabla de Personal que cumpla dos condiciones:
        -- 1. Esté asignado a esta región (`Fk_Id_CatRegion`).
        -- 2. El empleado esté ACTIVO (`Activo` = 1). (Los empleados históricos/baja no bloquean).
        SELECT 1 INTO v_Dependencias
        FROM `Info_Personal`
        WHERE `Fk_Id_CatRegion` = _Id_Region
          AND `Activo` = 1 
        LIMIT 1;

        -- [Disparador de Bloqueo]: Si encontramos dependencias, abortamos la operación.
        IF v_Dependencias IS NOT NULL THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'CONFLICTO DE INTEGRIDAD [409]: No es posible dar de baja la Región. Existen EMPLEADOS ACTIVOS asignados a esta ubicación. Realice la reasignación o baja del personal primero.';
        END IF;
    END IF;

    /* ================================================================================================
       SECCIÓN 6: PERSISTENCIA Y FINALIZACIÓN (COMMIT)
       Propósito: Aplicar los cambios validados y confirmar la transacción.
       ================================================================================================ */

    /* ------------------------------------------------------------------------------------------------
       PASO 6.1: EJECUCIÓN DE LA ACTUALIZACIÓN (UPDATE)
       En este punto, hemos superado todas las validaciones (Input, Existencia, Idempotencia, Integridad).
       Es seguro escribir en la base de datos.
       ------------------------------------------------------------------------------------------------ */
    UPDATE `Cat_Regiones_Trabajo` 
    SET `Activo` = _Nuevo_Estatus, 
        `updated_at` = NOW() -- [Traza de Auditoría]: Actualizamos la marca de tiempo del sistema.
    WHERE `Id_CatRegion` = _Id_Region;
    
    /* ------------------------------------------------------------------------------------------------
       PASO 6.2: CONFIRMACIÓN DE TRANSACCIÓN (COMMIT)
       Hacemos permanentes los cambios y liberamos los bloqueos (Locks) adquiridos en el PASO 4.1.
       ------------------------------------------------------------------------------------------------ */
    COMMIT; 
    
    /* ------------------------------------------------------------------------------------------------
       PASO 6.3: GENERACIÓN DE RESPUESTA AL CLIENTE (RESPONSE MAPPING)
       Retornamos el estado final para que la interfaz de usuario pueda sincronizarse con el Backend.
       ------------------------------------------------------------------------------------------------ */
    SELECT CASE 
        WHEN _Nuevo_Estatus = 1 THEN 'ÉXITO: La Región ha sido REACTIVADA y está visible para operaciones.' 
        ELSE 'ÉXITO: La Región ha sido DESACTIVADA (Baja Lógica). No se mostrará en nuevos registros.' 
    END AS Mensaje,
    v_Activo_Actual AS Activo_Anterior,
    _Nuevo_Estatus AS Activo_Nuevo;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusPuesto
   ====================================================================================================
   1. DEFINICIÓN DEL OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Gestionar el cambio de estado (Activación/Desactivación) de un "Puesto de Trabajo" (`Cat_Puestos_Trabajo`)
   mediante el mecanismo de BAJA LÓGICA (Soft Delete).

   Este procedimiento permite al Administrador:
     A) DESACTIVAR (Ocultar): Marcar un puesto como obsoleto (ej: "Mecanógrafo") para que no aparezca
        en los selectores de nuevas contrataciones.
     B) REACTIVAR (Mostrar): Recuperar un puesto histórico para volver a utilizarlo.

   2. ARQUITECTURA DE INTEGRIDAD REFERENCIAL (CRITICAL PATH)
   ----------------------------------------------------------------------------------------------------
   Se aplica una política estricta de "No Huérfanos Operativos" (Operational Orphan Prevention).
   
   - REGLA DE BLOQUEO (Downstream Dependency Check):
     Si se solicita DESACTIVAR un puesto, el sistema consulta proactivamente la tabla de Personal (`Info_Personal`).
   
   - CONDICIÓN DE RECHAZO:
     Si existe AL MENOS UN empleado con estatus `Activo = 1` que ocupa este puesto, la operación se
     bloquea inmediatamente con un error de negocio.
   
   - JUSTIFICACIÓN:
     Evita la inconsistencia de tener empleados activos asignados a un cargo que "ya no existe" 
     administrativamente. Primero se debe reasignar o dar de baja al personal.

   3. ESTRATEGIA DE CONCURRENCIA (BLOQUEO PESIMISTA / ACID)
   ----------------------------------------------------------------------------------------------------
   - NIVEL DE AISLAMIENTO: Utiliza `SELECT ... FOR UPDATE` al inicio de la transacción.
   - OBJETIVO: Serializar el acceso al registro del Puesto.
   - ESCENARIO EVITADO (RACE CONDITION): Previene que el Admin A desactive el puesto justo en el
     milisegundo en que el Admin B está asignando ese mismo puesto a un nuevo empleado.

   4. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   ----------------------------------------------------------------------------------------------------
   - Antes de escribir en disco, verificamos si el registro ya tiene el estatus solicitado.
   - Si `Activo_Actual == Nuevo_Estatus`, el SP retorna éxito sin realizar el UPDATE.
   - Beneficio: Ahorro de I/O y preservación del timestamp `updated_at`.

   5. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset (Single Row) con:
     - Mensaje (VARCHAR): Feedback legible para el usuario final.
     - Activo_Anterior (TINYINT): Estado previo para rollback visual en Frontend.
     - Activo_Nuevo (TINYINT): Estado final confirmado.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusPuesto`$$

CREATE PROCEDURE `SP_CambiarEstatusPuesto`(
    IN _Id_Puesto    INT,     -- Identificador Único (PK) del Puesto a modificar
    IN _Nuevo_Estatus TINYINT -- Flag de Estado Solicitado: 1 = Activo (Visible), 0 = Inactivo (Soft Delete)
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: VARIABLES DE ESTADO Y CONTROL
       Propósito: Inicializar los contenedores de datos que mantendrán la "foto" (Snapshot) del
       registro antes de cualquier modificación.
       ================================================================================================ */
    
    -- [Flag de Existencia]: Determina si el ID proporcionado apunta a un registro válido en la BDD.
    DECLARE v_Existe        INT DEFAULT NULL;
    
    -- [Snapshot de Estado]: Almacena el valor actual de la columna `Activo` antes de la modificación.
    -- Vital para la verificación de idempotencia.
    DECLARE v_Activo_Actual TINYINT(1) DEFAULT NULL;
    
    -- [Semáforo de Dependencias]: Variable auxiliar utilizada durante la validación de integridad.
    -- Si cambia a NOT NULL, indica que existe un bloqueo de negocio (Empleados activos ocupando el puesto).
    DECLARE v_Dependencias  INT DEFAULT NULL;

    /* ================================================================================================
       BLOQUE 1: GESTIÓN DE EXCEPCIONES Y ATOMICIDAD (ERROR HANDLING)
       Propósito: Garantizar que la base de datos nunca quede en un estado inconsistente ante fallos.
       ================================================================================================ */
    
    -- [Safety Net]: Captura cualquier error SQL (SQLEXCEPTION) no controlado explícitamente.
    -- ACCIÓN: Ejecuta un ROLLBACK total y propaga el error (RESIGNAL).
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: PROTOCOLO DE VALIDACIÓN DE ENTRADA (DEFENSIVE PROGRAMMING)
       Propósito: Rechazar peticiones malformadas ("Fail Fast") antes de consumir recursos.
       ================================================================================================ */
    
    -- [Validación de Identidad]: El ID debe ser un entero positivo.
    IF _Id_Puesto IS NULL OR _Id_Puesto <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El ID del Puesto es inválido o nulo.';
    END IF;

    -- [Validación de Dominio]: El estatus debe ser binario estrictamente (0 o 1).
    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El valor de Estatus está fuera de rango (Permitido: 0, 1).';
    END IF;

    /* ================================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       Propósito: Aislar el registro objetivo para asegurar consistencia durante la lectura y escritura.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: ADQUISICIÓN DE SNAPSHOT CON BLOQUEO DE ESCRITURA (FOR UPDATE)
       
       Mecánica Técnica:
       Se realiza una lectura del registro usando la cláusula `FOR UPDATE`.
       
       Efecto en el Motor de Base de Datos:
       1. Verifica si el registro existe.
       2. Coloca un "Row-Level Lock" (X-Lock) sobre la fila específica del ID.
       3. Cualquier otra transacción concurrente deberá esperar.
       ------------------------------------------------------------------------------------------------ */
    SELECT 1, `Activo` 
    INTO v_Existe, v_Activo_Actual
    FROM `Cat_Puestos_Trabajo` 
    WHERE `Id_CatPuesto` = _Id_Puesto 
    LIMIT 1 
    FOR UPDATE;

    -- [Verificación de Existencia]: Si el SELECT no encontró nada, v_Existe sigue siendo NULL.
    IF v_Existe IS NULL THEN 
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Puesto de Trabajo solicitado no existe en el catálogo.'; 
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: VERIFICACIÓN DE IDEMPOTENCIA (OPTIMIZACIÓN)
       
       Lógica de Negocio:
       "Si ya está encendido, no intentes encenderlo de nuevo".
       
       Beneficio Técnico:
       - Evita un UPDATE innecesario (ahorra ciclos de CPU y escrituras en disco).
       - Evita alterar la columna `updated_at` innecesariamente (preserva la auditoría real).
       ------------------------------------------------------------------------------------------------ */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        
        COMMIT; -- Liberamos el bloqueo (Lock) inmediatamente.
        
        -- Retorno informativo indicando que no hubo cambios.
        SELECT CASE 
            WHEN _Nuevo_Estatus = 1 THEN 'OPERACIÓN OMITIDA: El Puesto ya se encuentra en estado ACTIVO.' 
            ELSE 'OPERACIÓN OMITIDA: El Puesto ya se encuentra en estado INACTIVO.' 
        END AS Mensaje,
        v_Activo_Actual AS Activo_Anterior,
        _Nuevo_Estatus AS Activo_Nuevo;
        
        -- Salimos del bloque principal para terminar el SP.
        LEAVE THIS_PROC; 
    END IF;

    /* ================================================================================================
       BLOQUE 4: EVALUACIÓN DE REGLAS DE NEGOCIO COMPLEJAS (INTEGRIDAD REFERENCIAL)
       Propósito: Validar que el cambio de estado no rompa la coherencia de los datos relacionados.
       ================================================================================================ */

    /* ------------------------------------------------------------------------------------------------
       PASO 4.1: REGLA DE "BAJA SEGURA" (SAFE DELETE GUARD)
       Condición: Esta validación SOLO se ejecuta si intentamos DESACTIVAR (_Nuevo_Estatus = 0).
       Objetivo: Proteger a la tabla de Personal (`Info_Personal`) de tener asignados puestos "muertos".
       ------------------------------------------------------------------------------------------------ */
    IF _Nuevo_Estatus = 0 THEN
        
        -- Reiniciamos el semáforo
        SET v_Dependencias = NULL;
        
        -- [Sondeo de Dependencias]:
        -- Buscamos si existe AL MENOS UN registro en la tabla de Personal que cumpla dos condiciones:
        -- 1. Esté asignado a este Puesto (`Fk_Id_CatPuesto`).
        -- 2. El empleado esté ACTIVO (`Activo` = 1). (Los empleados históricos/baja no bloquean).
        SELECT 1 INTO v_Dependencias
        FROM `Info_Personal`
        WHERE `Fk_Id_CatPuesto` = _Id_Puesto
          AND `Activo` = 1 
        LIMIT 1;

        -- [Disparador de Bloqueo]: Si encontramos dependencias, abortamos la operación.
        IF v_Dependencias IS NOT NULL THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'CONFLICTO DE INTEGRIDAD [409]: No es posible dar de baja este Puesto. Existen EMPLEADOS ACTIVOS ocupando este cargo. Realice el cambio de puesto o baja del personal primero.';
        END IF;
    END IF;

    /* ================================================================================================
       BLOQUE 5: PERSISTENCIA Y FINALIZACIÓN (COMMIT)
       Propósito: Aplicar los cambios validados y confirmar la transacción.
       ================================================================================================ */

    /* ------------------------------------------------------------------------------------------------
       PASO 5.1: EJECUCIÓN DE LA ACTUALIZACIÓN (UPDATE)
       En este punto, hemos superado todas las validaciones (Input, Existencia, Idempotencia, Integridad).
       Es seguro escribir en la base de datos.
       ------------------------------------------------------------------------------------------------ */
    UPDATE `Cat_Puestos_Trabajo` 
    SET `Activo` = _Nuevo_Estatus, 
        `updated_at` = NOW() -- [Traza de Auditoría]: Actualizamos la marca de tiempo del sistema.
    WHERE `Id_CatPuesto` = _Id_Puesto;
    
    /* ------------------------------------------------------------------------------------------------
       PASO 5.2: CONFIRMACIÓN DE TRANSACCIÓN (COMMIT)
       Hacemos permanentes los cambios y liberamos los bloqueos (Locks).
       ------------------------------------------------------------------------------------------------ */
    COMMIT; 
    
    /* ------------------------------------------------------------------------------------------------
       PASO 5.3: GENERACIÓN DE RESPUESTA AL CLIENTE (RESPONSE MAPPING)
       Retornamos el estado final para que la interfaz de usuario pueda sincronizarse con el Backend.
       ------------------------------------------------------------------------------------------------ */
    SELECT CASE 
        WHEN _Nuevo_Estatus = 1 THEN 'ÉXITO: El Puesto ha sido REACTIVADO y está disponible para asignación.' 
        ELSE 'ÉXITO: El Puesto ha sido DESACTIVADO (Baja Lógica). No se mostrará en nuevos registros.' 
    END AS Mensaje,
    v_Activo_Actual AS Activo_Anterior,
    _Nuevo_Estatus AS Activo_Nuevo;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO ALMACENADO: SP_CambiarEstatusRol
   ====================================================================================================
   
   1. DEFINICIÓN DEL OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Gestionar el Ciclo de Vida (Lifecycle) de un "Rol de Sistema" (`Cat_Roles`) mediante el mecanismo
   de "Baja Lógica" (Soft Delete).
   
   Este procedimiento actúa como un "Interruptor Maestro" (Master Toggle) de seguridad que permite:
     A) REVOCAR (Desactivar): Impedir que el rol sea asignado a nuevos usuarios en el futuro.
        Esto es crítico para retirar permisos obsoletos sin romper el historial de auditoría.
     B) RESTAURAR (Reactivar): Volver a habilitar un rol histórico para su uso operativo.

   2. ARQUITECTURA DE INTEGRIDAD REFERENCIAL (SEGURIDAD PRIMERO)
   ----------------------------------------------------------------------------------------------------
   A) NO DESTRUCCIÓN DE DATOS (DATA PRESERVATION):
      - Regla Absoluta: Jamás se ejecuta un `DELETE` físico sobre un Rol.
      - Justificación: Eliminar un rol rompería la integridad de la tabla de relación `Usuarios_Roles`
        (o donde se asignen los permisos), dejando usuarios "huérfanos" de acceso o causando errores 
        fatales en el Middleware de autorización del Backend (Laravel/Node).

   B) VALIDACIÓN DE EXISTENCIA (FAIL FAST):
      - Antes de intentar cualquier cambio, verificamos que el ID del rol exista.
      - Esto evita "Updates Fantasma" que reportan éxito falsamente cuando el registro no existe.

   3. ESTRATEGIA DE CONCURRENCIA (BLOQUEO PESIMISTA / ACID)
   ----------------------------------------------------------------------------------------------------
   - NIVEL DE AISLAMIENTO: Se utiliza `SELECT ... FOR UPDATE` al inicio de la transacción.
   - OBJETIVO: Serializar el acceso al registro del Rol.
   - ESCENARIO EVITADO (RACE CONDITION): Previene situaciones donde un Administrador intenta 
     desactivar el rol mientras otro intenta editar su nombre o descripción simultáneamente.
     El bloqueo asegura que las operaciones ocurran una después de la otra.

   4. IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
   ----------------------------------------------------------------------------------------------------
   - Lógica de "Sin Cambios": Si se solicita activar un rol que YA está activo, el SP detecta la 
     redundancia y retorna éxito inmediato sin tocar el disco duro.
   - Beneficio: Ahorra I/O, reduce el crecimiento del Log de Transacciones y mantiene intacta 
     la fecha de auditoría `updated_at` (solo cambia cuando realmente hubo una modificación).

   5. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset (Single Row) diseñado para refrescar la UI (Switch/Botón):
      - Mensaje (VARCHAR): Feedback descriptivo para el usuario.
      - Activo_Anterior (TINYINT): Estado previo (útil para rollback visual en frontend).
      - Activo_Nuevo (TINYINT): El nuevo estado confirmado en base de datos.
      - Accion (VARCHAR): 'CAMBIO_ESTATUS' o 'SIN_CAMBIOS'.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusRol`$$

CREATE PROCEDURE `SP_CambiarEstatusRol`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA
       ----------------------------------------------------------------- */
    IN _Id_Rol        INT,      -- OBLIGATORIO: El ID del rol a modificar (PK)
    IN _NuevoEstatus  TINYINT   -- OBLIGATORIO: 1 = Activar, 0 = Desactivar
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: VARIABLES DE ESTADO Y CONTROL
       Propósito: Inicializar los contenedores para el snapshot de datos.
       ================================================================================================ */
    
    /* Variable para almacenar el estado actual en base de datos antes del cambio */
    DECLARE v_EstatusActual TINYINT DEFAULT NULL;
    
    /* Bandera de existencia */
    DECLARE v_Existe INT DEFAULT NULL;

    /* ================================================================================================
       BLOQUE 1: GESTIÓN DE EXCEPCIONES Y ATOMICIDAD (ERROR HANDLING)
       Propósito: Garantizar una salida limpia ante errores técnicos.
       ================================================================================================ */
    
    /* Handler Genérico: Ante cualquier fallo SQL (Deadlock, Conexión), hacemos Rollback. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: PROTOCOLO DE VALIDACIÓN DE ENTRADA (DEFENSIVE PROGRAMMING)
       Propósito: Rechazar peticiones malformadas antes de consumir recursos.
       ================================================================================================ */
    
    /* 2.1 Validación de Integridad de Identificador */
    IF _Id_Rol IS NULL OR _Id_Rol <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: ID de Rol inválido o nulo.';
    END IF;

    /* 2.2 Validación de Integridad Booleana (Dominio Estricto) */
    IF _NuevoEstatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El estatus solo puede ser 1 (Activo) o 0 (Inactivo).';
    END IF;

    /* ================================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       Propósito: Aislar el registro para asegurar consistencia.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: ADQUISICIÓN DE SNAPSHOT CON BLOQUEO (FOR UPDATE)
       
       Mecánica Técnica:
       - Buscamos el rol por su ID.
       - Adquirimos un candado de escritura (X-Lock) sobre la fila.
       - Efecto: Cualquier otra transacción que quiera leer o escribir este Rol deberá esperar.
       ------------------------------------------------------------------------------------------------ */
    SELECT 1, `Activo` 
    INTO v_Existe, v_EstatusActual
    FROM `Cat_Roles`
    WHERE `Id_Rol` = _Id_Rol
    LIMIT 1
    FOR UPDATE;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: MANEJO DE ERROR (NO ENCONTRADO)
       Si v_Existe sigue en NULL, el registro no existe o fue eliminado por otro usuario.
       ------------------------------------------------------------------------------------------------ */
    IF v_Existe IS NULL THEN
        ROLLBACK; -- Liberamos recursos aunque no haya locks efectivos
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Rol solicitado no existe en el catálogo.';
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.3: VALIDACIÓN DE REDUNDANCIA (BUSINESS LOGIC OPTIMIZATION)
       Objetivo: Si el estatus en BD ya es igual al que queremos poner, no hacemos nada.
       Beneficio: No "ensuciamos" el campo `updated_at` sin razón real.
       ------------------------------------------------------------------------------------------------ */
    IF v_EstatusActual = _NuevoEstatus THEN
        
        COMMIT; -- Liberamos el bloqueo inmediatamente
        
        /* Respuesta informativa (Idempotente) */
        SELECT 
            CASE 
                WHEN _NuevoEstatus = 1 THEN 'AVISO: El Rol ya se encuentra ACTIVO.' 
                ELSE 'AVISO: El Rol ya se encuentra INACTIVO.' 
            END AS Mensaje,
            _Id_Rol AS Id_Rol,
            _NuevoEstatus AS Nuevo_Estatus,
            'SIN_CAMBIOS' AS Accion;
            
        LEAVE THIS_PROC; -- Salimos del SP
    END IF;

    /* ================================================================================================
       BLOQUE 4: PERSISTENCIA Y FINALIZACIÓN (COMMIT)
       Propósito: Aplicar el cambio de estado validado.
       ================================================================================================ */

    /* ------------------------------------------------------------------------------------------------
       PASO 4.1: EJECUCIÓN DEL CAMBIO DE ESTADO (SOFT DELETE / RESTORE)
       Si llegamos aquí, el cambio es necesario y seguro.
       ------------------------------------------------------------------------------------------------ */
    UPDATE `Cat_Roles`
    SET 
        `Activo` = _NuevoEstatus,
        `updated_at` = NOW() -- Auditoría: Registramos el momento exacto del cambio
    WHERE `Id_Rol` = _Id_Rol;

    /* ------------------------------------------------------------------------------------------------
       PASO 4.2: CONFIRMACIÓN DE TRANSACCIÓN
       Hacemos permanentes los cambios y liberamos el bloqueo de fila.
       ------------------------------------------------------------------------------------------------ */
    COMMIT;

    /* ------------------------------------------------------------------------------------------------
       PASO 4.3: GENERACIÓN DE RESPUESTA AL CLIENTE
       ------------------------------------------------------------------------------------------------ */
    SELECT 
        CASE 
            WHEN _NuevoEstatus = 1 THEN 'ÉXITO: Rol reactivado correctamente.' 
            ELSE 'ÉXITO: Rol desactivado correctamente.' 
        END AS Mensaje,
        _Id_Rol AS Id_Rol,
        _NuevoEstatus AS Nuevo_Estatus,
        'CAMBIO_ESTATUS' AS Accion;

END$$

DELIMITER ;

/* ====================================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusUsuario
   ====================================================================================================
   
   ----------------------------------------------------------------------------------------------------
   I. VISIÓN GENERAL Y OBJETIVO ESTRATÉGICO (EXECUTIVE SUMMARY)
   ----------------------------------------------------------------------------------------------------
   [DEFINICIÓN DEL COMPONENTE]:
   Este Stored Procedure actúa como el **Motor de Gobierno de Identidades** (Identity Governance Engine) 
   del sistema. No es un simple "switch" de apagado/encendido; es un orquestador de ciclo de vida que 
   garantiza la continuidad operativa de la empresa.

   [EL PROBLEMA DE NEGOCIO QUE RESUELVE]:
   En una organización de capacitación de alto rendimiento (como PEMEX), el capital humano es el activo 
   más crítico. La desactivación de un usuario no es un evento aislado, es un riesgo sistémico.
   
   * Escenario de Riesgo 1 (El Instructor Fantasma): Si un administrador desactiva por error a un 
     instructor que tiene un curso programado para mañana a las 8:00 AM, el sistema impide el acceso, 
     el instructor no llega, y se genera una pérdida financiera y de reputación ("Evento Acéfalo").
   
   * Escenario de Riesgo 2 (El Alumno Zombie): Si se da de baja a un alumno a mitad de un curso, 
     se corrompen las métricas de asistencia, las actas de calificación y los historiales de 
     cumplimiento normativo (SSPA).

   [SOLUCIÓN ARQUITECTÓNICA]:
   Se implementa un mecanismo de **"Baja Lógica Condicional"** (Conditional Soft Delete).
   Antes de permitir la desactivación, el sistema ejecuta un análisis forense en tiempo real de las 
   dependencias del usuario. Si el usuario es un "Nodo Activo" en la red de capacitación (Instructor 
   o Participante), la operación se bloquea automáticamente.

   ----------------------------------------------------------------------------------------------------
   II. MATRIZ DE REGLAS DE BLINDAJE (SECURITY & INTEGRITY RULES)
   ----------------------------------------------------------------------------------------------------
   
   [RN-01] PROTOCOLO ANTI-LOCKOUT (SEGURIDAD DE ACCESO):
      - Principio: "Seguridad contra el error humano propio".
      - Regla: Un usuario con privilegios de Administrador tiene estrictamente PROHIBIDO desactivar 
        su propia cuenta. Esto evita el escenario de "cerrar la puerta con las llaves adentro".

   [RN-02] INTEGRIDAD REFERENCIAL SINCRONIZADA (ATOMIC DATA CONSISTENCY):
      - Principio: "Una identidad, un estado".
      - Regla: El sistema PICADE maneja la identidad en dos capas:
           1. Capa de Acceso (`Usuarios`): Login y Credenciales.
           2. Capa Operativa (`Info_Personal`): Recursos Humanos y Catálogos.
      - Mecanismo: El SP garantiza atomicidad. Si se desactiva el Usuario, se fuerza la desactivación 
        inmediata de la ficha de Personal asociada. Esto limpia los selectores de "Instructores Disponibles" 
        en el frontend instantáneamente.

   [RN-03] CANDADO OPERATIVO DINÁMICO (THE DYNAMIC KILLSWITCH):
      - Principio: "Prioridad a la Operación Viva".
      - Definición: La baja de un usuario está subordinada a que no tenga compromisos activos.
      
      A) VECTOR DE INSTRUCTOR/FACILITADOR (`DatosCapacitaciones`):
         - Alcance: Aplica a cualquier usuario (Admin, Coordinador, Instructor) asignado como responsable 
           de un grupo.
         - Lógica de Bloqueo (Data-Driven):
             * Se consulta el estatus de la capacitación (`Cat_Estatus_Capacitacion`).
             * Se lee la bandera de control `Es_Final`.
             * Si `Es_Final = 0` (Falso): El curso está VIVO (Programado, En Curso, Por Iniciar, En Evaluación).
               -> ACCIÓN: BLOQUEO TOTAL (Error 409).
             * Si `Es_Final = 1` (Verdadero): El curso está MUERTO (Finalizado, Cancelado, Archivado).
               -> ACCIÓN: PERMITIR BAJA.

      B) VECTOR DE PARTICIPANTE (`Capacitaciones_Participantes`):
         - Alcance: Usuarios inscritos como alumnos.
         - Lógica de Bloqueo:
             * Se verifica si el usuario tiene estatus de inscripción 'Activo' (1) o 'Cursando' (2).
             * Y ADEMÁS, se verifica que el curso en sí mismo siga vivo (`Es_Final = 0`).
             * Si el curso fue cancelado, el alumno se libera automáticamente.

   ----------------------------------------------------------------------------------------------------
   III. ESPECIFICACIÓN TÉCNICA Y RENDIMIENTO (PERFORMANCE SPECS)
   ----------------------------------------------------------------------------------------------------
   - ESTRATEGIA DE CONCURRENCIA: Implementación de **Bloqueo Pesimista** (`SELECT ... FOR UPDATE`).
     Esto "congela" la fila del usuario objetivo durante la transacción, asegurando que nadie más 
     pueda editar sus datos o cambiar su estatus en el milisegundo exacto en que validamos.
   - IDEMPOTENCIA: El sistema es inteligente. Si se solicita desactivar a un usuario que YA está 
     desactivado, el SP detecta la redundancia y retorna un mensaje de éxito ("SIN CAMBIOS") sin 
     realizar escrituras innecesarias en el disco duro, optimizando I/O.
   - TRAZABILIDAD: Se inyecta el ID del Administrador Ejecutor (`_Id_Admin_Ejecutor`) en los campos 
     de auditoría (`Updated_By`) para mantener un rastro forense de quién autorizó la baja.

   ----------------------------------------------------------------------------------------------------
   IV. MAPA DE RETORNO (OUTPUT CONTRACT)
   ----------------------------------------------------------------------------------------------------
   Retorna un Resultset de una sola fila con la siguiente estructura:
      - [Mensaje] (VARCHAR): Descripción humana del resultado (ej: "ÉXITO: Usuario REACTIVADO").
      - [Id_Usuario] (INT): La llave primaria del usuario afectado.
      - [Accion] (VARCHAR): Token técnico para el frontend ('ACTIVADO', 'DESACTIVADO', 'SIN_CAMBIOS').
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusUsuario`$$

CREATE PROCEDURE `SP_CambiarEstatusUsuario`(
    /* ------------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS DE ENTRADA
       ------------------------------------------------------------------------------------------------ */
    IN _Id_Admin_Ejecutor    INT,        -- [AUDITOR] ID del usuario que ejecuta la orden (Required).
    IN _Id_Usuario_Objetivo  INT,        -- [TARGET] ID del usuario que sufrirá el cambio (Required).
    IN _Nuevo_Estatus        TINYINT     -- [FLAG] Estado deseado: 1 = Activar (Alta), 0 = Desactivar (Baja).
)
THIS_PROC: BEGIN
    
    /* ============================================================================================
       BLOQUE 0: INICIALIZACIÓN DE VARIABLES DE ENTORNO
       Definición de contenedores para almacenar el estado de la base de datos y diagnósticos.
       ============================================================================================ */
    
    /* Punteros de Relación (Foreign Keys y Datos Maestros) */
    DECLARE v_Id_InfoPersonal INT DEFAULT NULL; -- Para localizar la ficha de RH asociada.
    DECLARE v_Ficha_Objetivo  VARCHAR(50);      -- Para mostrar en el mensaje de éxito/error.
    
    /* Snapshot de Estado (Lectura actual de la BD) */
    DECLARE v_Estatus_Actual  TINYINT(1);       -- Estado actual en disco (0 o 1).
    DECLARE v_Existe          INT;              -- Bandera de existencia del registro.
    
    /* Variables de Diagnóstico para el Candado Operativo (Error Reporting) */
    DECLARE v_Curso_Conflictivo VARCHAR(50) DEFAULT NULL;  -- Número de capacitación que causa el bloqueo.
    DECLARE v_Estatus_Conflicto VARCHAR(255) DEFAULT NULL; -- Nombre del estatus del curso (ej: "EN CURSO").
    DECLARE v_Rol_Conflicto     VARCHAR(50) DEFAULT NULL;  -- Rol que juega el usuario en el conflicto.

    /* ============================================================================================
       BLOQUE 1: GESTIÓN DE EXCEPCIONES Y SEGURIDAD (DEFENSIVE CODING)
       ============================================================================================ */
    
    /* Handler Genérico de SQL:
       Ante cualquier error inesperado (caída de red, corrupción de datos, deadlock), 
       este bloque asegura que la transacción se revierta (ROLLBACK) para no dejar datos corruptos. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; -- Propaga el error original al backend para el log de errores.
    END;

    /* ============================================================================================
       BLOQUE 2: VALIDACIONES PREVIAS (FAIL FAST STRATEGY)
       Verificaciones ligeras en memoria para rechazar peticiones inválidas antes de leer disco.
       ============================================================================================ */
    
    /* 2.1 Validación de Integridad de Parámetros */
    IF _Id_Admin_Ejecutor IS NULL OR _Id_Usuario_Objetivo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: Los IDs de ejecutor y objetivo son obligatorios.';
    END IF;

    /* 2.2 Validación de Dominio (Valores permitidos) */
    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE DATOS [400]: El estatus solo puede ser 1 (Activo) o 0 (Inactivo).';
    END IF;

    /* 2.3 Regla de Seguridad Anti-Lockout
       Impide que un administrador se suicide digitalmente. */
    IF _Id_Admin_Ejecutor = _Id_Usuario_Objetivo THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ACCIÓN DENEGADA [403]: Protocolo de Seguridad activado. No puedes desactivar tu propia cuenta de usuario.';
    END IF;

    /* ============================================================================================
       BLOQUE 3: CANDADO OPERATIVO (INTEGRACIÓN DINÁMICA CON MÓDULO DE CAPACITACIÓN)
       Propósito: Validar que el usuario no sea una pieza clave en operaciones que están ocurriendo AHORA.
       Condición Crítica: Este bloque SOLO se ejecuta si la intención es APAGAR (0) al usuario.
       ============================================================================================ */
    IF _Nuevo_Estatus = 0 THEN
        
        /* ----------------------------------------------------------------------------------------
           3.1 VERIFICACIÓN DE ROL: FACILITADOR / INSTRUCTOR
           Objetivo: Detectar si el usuario es el responsable de impartir un curso activo.
           
           [LÓGICA DINÁMICA]:
           En lugar de listar IDs fijos (1,2,3...), consultamos la inteligencia del catálogo 
           `Cat_Estatus_Capacitacion` a través de la columna `Es_Final`.
           ---------------------------------------------------------------------------------------- */
        SELECT 
            C.Numero_Capacitacion, -- Para decirle al usuario EXACTAMENTE qué curso estorba
            EC.Nombre,             -- Para decirle en qué estado está ese curso
            'FACILITADOR/INSTRUCTOR' -- Etiqueta para el log de error
        INTO 
            v_Curso_Conflictivo,
            v_Estatus_Conflicto,
            v_Rol_Conflicto
        FROM `DatosCapacitaciones` DC
        /* JOIN 1: Llegar a la cabecera de la capacitación */
        INNER JOIN `Capacitaciones` C ON DC.Fk_Id_Capacitacion = C.Id_Capacitacion
        /* JOIN 2: Llegar a la configuración del estatus */
        INNER JOIN `Cat_Estatus_Capacitacion` EC ON DC.Fk_Id_CatEstCap = EC.Id_CatEstCap
        WHERE 
            /* Filtro 1: El usuario objetivo es el instructor asignado */
            DC.Fk_Id_Instructor = _Id_Usuario_Objetivo
            /* Filtro 2: El registro de detalle es el vigente (historial activo) */
            AND DC.Activo = 1 
            /* Filtro 3: La capacitación cabecera no ha sido borrada */
            AND C.Activo = 1
            
            /* [KILLSWITCH MAESTRO - DINÁMICO] 
               Si Es_Final = 0, el curso está VIVO (Programado, En Curso, Reprogramado, etc).
               Esto significa que NO podemos dejar el curso sin instructor. Bloqueo activado. */
            AND EC.Es_Final = 0 
        LIMIT 1; -- Con encontrar UNO solo basta para detener todo.

        /* Si se encontró un conflicto, abortamos la operación inmediatamente */
        IF v_Curso_Conflictivo IS NOT NULL THEN
            SET @MensajeError = CONCAT('CONFLICTO OPERATIVO [409]: No se puede desactivar al usuario. Actualmente funge como FACILITADOR en el curso ACTIVO con Folio "', v_Curso_Conflictivo, '" (Estatus Actual: ', v_Estatus_Conflicto, '). Este estatus se considera operativo (No Final). Para proceder, debe reasignar el curso a otro instructor o finalizar la capacitación.');
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @MensajeError;
        END IF;

        /* ----------------------------------------------------------------------------------------
           3.2 VERIFICACIÓN DE ROL: PARTICIPANTE
           Objetivo: Detectar si el usuario es un alumno inscrito en un curso activo.
           
           [REGLA DE NEGOCIO]: Se mantiene la lógica para alumnos. No podemos borrar a alguien 
           que debe aparecer en la lista de asistencia de mañana.
           ---------------------------------------------------------------------------------------- */
        SELECT 
            C.Numero_Capacitacion,
            EP.Nombre,
            'PARTICIPANTE' -- Etiqueta informativa
        INTO 
            v_Curso_Conflictivo,
            v_Estatus_Conflicto,
            v_Rol_Conflicto
        FROM `Capacitaciones_Participantes` CP
        /* Cadena de Joins para llegar al Estatus del Curso */
        INNER JOIN `DatosCapacitaciones` DC ON CP.Fk_Id_DatosCap = DC.Id_DatosCap
        INNER JOIN `Capacitaciones` C ON DC.Fk_Id_Capacitacion = C.Id_Capacitacion
        INNER JOIN `Cat_Estatus_Participante` EP ON CP.Fk_Id_CatEstPart = EP.Id_CatEstPart
        INNER JOIN `Cat_Estatus_Capacitacion` EC_Curso ON DC.Fk_Id_CatEstCap = EC_Curso.Id_CatEstCap
        WHERE 
            /* Filtro 1: El usuario es el participante */
            CP.Fk_Id_Usuario = _Id_Usuario_Objetivo
            /* Filtro 2: Su estatus de alumno es Inscrito (1) o Cursando (2) */
            AND CP.Fk_Id_CatEstPart IN (1, 2) 
            /* Filtro 3: El curso sigue existiendo */
            AND DC.Activo = 1
            /* [KILLSWITCH DINÁMICO] Validamos que el CURSO también esté vivo. 
               Si el curso ya terminó (Es_Final=1), el alumno ya es historia y se puede borrar. */
            AND EC_Curso.Es_Final = 0
        LIMIT 1;

        /* Si se encontró conflicto como alumno, abortamos */
        IF v_Curso_Conflictivo IS NOT NULL THEN
            SET @MensajeError = CONCAT('CONFLICTO OPERATIVO [409]: No se puede desactivar al usuario. Actualmente es PARTICIPANTE activo en el curso con Folio "', v_Curso_Conflictivo, '" (Estatus Alumno: ', v_Estatus_Conflicto, '). Debe darlo de baja del curso o esperar a que el curso finalice.');
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @MensajeError;
        END IF;

    END IF;

    /* ============================================================================================
       BLOQUE 4: FASE TRANSACCIONAL - AISLAMIENTO Y ESCRITURA
       Si llegamos aquí, el usuario superó todas las validaciones de negocio. Es seguro proceder.
       ============================================================================================ */
    START TRANSACTION;

    /* 4.1 ADQUISICIÓN DE SNAPSHOT Y BLOQUEO DE FILA (PESSIMISTIC LOCK)
       Seleccionamos los datos actuales del usuario y aplicamos `FOR UPDATE`.
       Esto impide que otra transacción modifique a este usuario mientras terminamos el proceso. */
    SELECT 1, `Fk_Id_InfoPersonal`, `Ficha`, `Activo`
    INTO v_Existe, v_Id_InfoPersonal, v_Ficha_Objetivo, v_Estatus_Actual
    FROM `Usuarios` 
    WHERE `Id_Usuario` = _Id_Usuario_Objetivo
    FOR UPDATE;

    /* 4.2 Validación de Existencia (Integridad Referencial) */
    IF v_Existe IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El usuario solicitado no existe en la base de datos.';
    END IF;

    /* 4.3 Verificación de Idempotencia (Optimización)
       Si el usuario ya tiene el estatus que queremos ponerle, no hacemos nada.
       Esto ahorra escritura en logs de transacción y triggers. */
    IF v_Estatus_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CONCAT('SIN CAMBIOS: El usuario ya se encontraba en estado ', IF(_Nuevo_Estatus=1, 'ACTIVO', 'INACTIVO'), '.') AS Mensaje,
               _Id_Usuario_Objetivo AS Id_Usuario, 'SIN_CAMBIOS' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* ============================================================================================
       BLOQUE 5: PERSISTENCIA SINCRONIZADA (CASCADE UPDATE LOGIC)
       Propósito: Aplicar el cambio de estado en todas las capas de identidad.
       ============================================================================================ */
    
    /* 5.1 Desactivar/Activar Acceso (Tabla Usuarios)
       Esto controla el Login y el acceso al sistema. */
    UPDATE `Usuarios`
    SET `Activo` = _Nuevo_Estatus,
        `Fk_Usuario_Updated_By` = _Id_Admin_Ejecutor, -- Auditoría: Quién lo hizo
        `updated_at` = NOW()                          -- Auditoría: Cuándo lo hizo
    WHERE `Id_Usuario` = _Id_Usuario_Objetivo;

    /* 5.2 Desactivar/Activar Operatividad (Tabla Info_Personal)
       Esto controla la aparición en catálogos de RH y listas de selección.
       Se ejecuta solo si existe una ficha de personal vinculada (Integridad de Datos). */
    IF v_Id_InfoPersonal IS NOT NULL THEN
        UPDATE `Info_Personal`
        SET `Activo` = _Nuevo_Estatus,
            `Fk_Id_Usuario_Updated_By` = _Id_Admin_Ejecutor,
            `updated_at` = NOW()
        WHERE `Id_InfoPersonal` = v_Id_InfoPersonal;
    END IF;

    /* ============================================================================================
       BLOQUE 6: CONFIRMACIÓN Y RESPUESTA (COMMIT & FEEDBACK)
       ============================================================================================ */
    COMMIT; -- Confirmar los cambios de forma permanente.

    /* Retorno de información al Frontend para notificaciones UI (Toasts) */
    SELECT 
        CONCAT('ÉXITO: El Usuario con Ficha "', v_Ficha_Objetivo, '" ha sido ', IF(_Nuevo_Estatus=1, 'REACTIVADO', 'DESACTIVADO'), ' correctamente.') AS Mensaje,
        _Id_Usuario_Objetivo AS Id_Usuario,
        IF(_Nuevo_Estatus=1, 'ACTIVADO', 'DESACTIVADO') AS Accion;

END$$

DELIMITER ;

/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusTipoInstruccion
   ============================================================================================
   
   1. OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------
   Gestionar el Ciclo de Vida (Lifecycle) de un "Tipo de Instrucción" (ej: Teórico, Práctico)
   mediante el mecanismo de "Baja Lógica" (Soft Delete).
   
   Permite al administrador:
   A) DESACTIVAR (0): Ocultar el tipo de los selectores de "Nuevo Curso", volviéndolo obsoleto.
   B) REACTIVAR (1): Recuperar un tipo histórico para su reutilización.

   2. REGLA DE INTEGRIDAD CRÍTICA (EL CANDADO DESCENDENTE)
   -------------------------------------------------------
   "No puedes eliminar la categoría si existen productos clasificados en ella".
   
   - Validación: Si se intenta DESACTIVAR (`_Nuevo_Estatus = 0`), el sistema consulta la tabla
     `Cat_Temas_Capacitacion` (Cursos).
   - Condición de Bloqueo: Si existe AL MENOS UN curso activo (`Activo = 1`) que use este tipo,
     la operación se bloquea inmediatamente.
   - Justificación: Si permitiéramos esto, tendríamos cursos "huérfanos" en el sistema que no
     se podrían editar o clasificar correctamente, rompiendo los reportes por tipo.

   3. ESTRATEGIA DE CONCURRENCIA (BLOQUEO PESIMISTA)
   -------------------------------------------------
   - Problema: ¿Qué pasa si un Admin A desactiva el tipo "Teórico" justo en el milisegundo en que
     un Admin B está creando el curso "Seguridad Básica (Teórico)"?
   - Solución: `SELECT ... FOR UPDATE`.
   - Efecto: Congelamos el registro del Tipo. Cualquier otra transacción deberá esperar.

   4. IDEMPOTENCIA (OPTIMIZACIÓN)
   ------------------------------
   - Si el registro ya tiene el estatus solicitado, retornamos éxito inmediato sin tocar el disco.
   - Esto evita actualizaciones fantasmas en la columna `updated_at`.

   5. CONTRATO DE SALIDA
   ---------------------
   Retorna:
      - Mensaje: Feedback claro.
      - Accion: 'ESTATUS_CAMBIADO', 'SIN_CAMBIOS'.
      - Nuevo_Estatus: El valor final en BD.
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusTipoInstruccion`$$

CREATE PROCEDURE `SP_CambiarEstatusTipoInstruccion`(
    IN _Id_Tipo        INT,       -- ID del registro a modificar (PK)
    IN _Nuevo_Estatus  TINYINT    -- 1 = Activar, 0 = Desactivar
)
THIS_PROC: BEGIN
    /* ========================================================================================
       BLOQUE 0: VARIABLES DE ESTADO
       ======================================================================================== */
    DECLARE v_Estatus_Actual TINYINT DEFAULT NULL;
    DECLARE v_Nombre_Actual  VARCHAR(255) DEFAULT NULL;
    
    /* Variable para contar hijos activos (Dependencias) */
    DECLARE v_Dependencias   INT DEFAULT 0;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (SEGURIDAD TÉCNICA)
       ======================================================================================== */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: VALIDACIONES BÁSICAS (FAIL FAST)
       ======================================================================================== */
    IF _Id_Tipo IS NULL OR _Id_Tipo <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: ID inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El estatus solo puede ser 0 o 1.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y BLOQUEO
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: LEER Y BLOQUEAR EL REGISTRO
       ----------------------------------------------------------------------------------------
       Adquirimos un "Write Lock" sobre la fila. Esto asegura serialización. */
    
    SELECT `Activo`, `Nombre` 
    INTO v_Estatus_Actual, v_Nombre_Actual
    FROM `Cat_Tipos_Instruccion_Cap`
    WHERE `Id_CatTipoInstCap` = _Id_Tipo
    FOR UPDATE;

    /* Si no se encuentra, abortamos */
    IF v_Estatus_Actual IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Tipo de Instrucción no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: IDEMPOTENCIA (SIN CAMBIOS)
       ---------------------------------------------------------------------------------------- */
    IF v_Estatus_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CONCAT('AVISO: El Tipo "', v_Nombre_Actual, '" ya se encuentra en el estado solicitado.') AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Nuevo_Estatus AS Nuevo_Estatus;
        
        /* CORRECCIÓN APLICADA: Se usa LEAVE con la etiqueta del bloque principal */
        LEAVE THIS_PROC; 
    END IF;

    /* ========================================================================================
       BLOQUE 4: REGLAS DE NEGOCIO (CANDADOS DE INTEGRIDAD)
       ======================================================================================== */

    /* ----------------------------------------------------------------------------------------
       PASO 4.1: VALIDACIÓN DE DEPENDENCIAS (SOLO AL DESACTIVAR)
       ---------------------------------------------------------------------------------------- */
    IF _Nuevo_Estatus = 0 THEN
        
        /* Buscamos si existen Temas (Cursos) activos que dependan de este Tipo.
           Solo nos importan los cursos con `Activo = 1`. 
           Si hay cursos históricos (borrados), no bloqueamos la operación. */
        
        SELECT COUNT(*) INTO v_Dependencias
        FROM `Cat_Temas_Capacitacion`
        WHERE `Fk_Id_CatTipoInstCap` = _Id_Tipo
          AND `Activo` = 1; 

        /* Si encontramos al menos uno, BLOQUEAMOS */
        IF v_Dependencias > 0 THEN
            ROLLBACK;
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'BLOQUEO DE INTEGRIDAD [409]: No se puede desactivar este Tipo de Instrucción porque existen CURSOS ACTIVOS asociados a él. Primero reasigne o desactive esos cursos.';
        END IF;

    END IF;

    /* ========================================================================================
       BLOQUE 5: PERSISTENCIA (UPDATE)
       ======================================================================================== */
    
    UPDATE `Cat_Tipos_Instruccion_Cap`
    SET 
        `Activo` = _Nuevo_Estatus,
        `updated_at` = NOW() -- Auditoría temporal
    WHERE `Id_CatTipoInstCap` = _Id_Tipo;

    /* ========================================================================================
       BLOQUE 6: CONFIRMACIÓN Y RESPUESTA
       ======================================================================================== */
    COMMIT;

    SELECT 
        CASE 
            WHEN _Nuevo_Estatus = 1 THEN CONCAT('ÉXITO: El Tipo "', v_Nombre_Actual, '" ha sido REACTIVADO.')
            ELSE CONCAT('ÉXITO: El Tipo "', v_Nombre_Actual, '" ha sido DESACTIVADO.')
        END AS Mensaje,
        'ESTATUS_CAMBIADO' AS Accion,
        _Nuevo_Estatus AS Nuevo_Estatus;

END$$ -- Fin del bloque etiquetado

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusTemaCapacitacion
   ============================================================================================

   --------------------------------------------------------------------------------------------
   I. CONTEXTO Y PROPÓSITO DEL NEGOCIO (THE "WHAT" & "WHY")
   --------------------------------------------------------------------------------------------
   [QUÉ ES]:
   Es el mecanismo de control de ciclo de vida para los "Temas de Capacitación" (Cursos).
   Permite alternar entre dos estados operativos:
     - ACTIVO (1): El curso es visible y seleccionable para nuevas programaciones.
     - INACTIVO (0): El curso se oculta (Baja Lógica) pero se preserva para auditoría histórica.

   [EL PROBLEMA DE LA INTEGRIDAD OPERATIVA]:
   No podemos retirar del catálogo un curso que se va a impartir mañana (Programado) o que se
   está impartiendo hoy (En Curso). Hacerlo dejaría a la operación sin referencia válida.
   
   Sin embargo, SÍ debemos permitir retirar cursos obsoletos que ya fueron impartidos en el 
   pasado (Finalizados), para limpiar el catálogo sin perder el historial.

   --------------------------------------------------------------------------------------------
   II. REGLAS DE BLINDAJE (KILL SWITCHES INTELIGENTES)
   --------------------------------------------------------------------------------------------
   
   [RN-01] CANDADO DE DEPENDENCIA OPERATIVA (AL DESACTIVAR):
      - Definición: "Solo se puede archivar lo que no está en uso activo".
      - Mecanismo Técnico: El sistema consulta la bandera `Es_Final` del estatus actual.
        Si `Es_Final = 0` (Operativo), se bloquea la desactivación.
      
      - Lógica de Negocio (Referencia de Configuración):
        Si se intenta DESACTIVAR (0), el sistema escanea `DatosCapacitaciones`.
        Los estatus se clasifican conceptualmente de la siguiente manera:

      - Estatus Bloqueantes (Conflictos - Es_Final = 0):
          * 1 (PROGRAMADO): Compromiso futuro.
          * 2 (POR INICIAR): Inminencia operativa.
          * 3 (EN CURSO): Ejecución en tiempo real.
          * 5 (EN EVALUACIÓN): Proceso administrativo pendiente.
          * 9 (REPROGRAMADO): Compromiso reagendado.
      
      - Estatus NO Bloqueantes (Permitidos - Es_Final = 1):
          * 4 (FINALIZADO), 6 (CANCELADO), 7 (SUSPENDIDO), 8 (DESERTO).
      
      - Acción: Si se detecta un curso en estatus bloqueante, se ABORTA con error 409.

   [RN-02] CANDADO JERÁRQUICO (AL REACTIVAR):
      - Regla: "Un hijo no puede vivir si el padre está muerto".
      - Acción: Si se intenta REACTIVAR (1), verificamos que el `Tipo de Instrucción` (Padre)
        esté ACTIVO. Si no, se bloquea.

   --------------------------------------------------------------------------------------------
   III. ESPECIFICACIÓN TÉCNICA
   --------------------------------------------------------------------------------------------
   - TIPO: Transacción ACID con Aislamiento Serializable.
   - ESTRATEGIA: Bloqueo Pesimista (`FOR UPDATE`) para evitar condiciones de carrera.
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusTemaCapacitacion`$$

CREATE PROCEDURE `SP_CambiarEstatusTemaCapacitacion`(
    IN _Id_Tema        INT,        -- [OBLIGATORIO] El Curso a modificar (PK)
    IN _Nuevo_Estatus  TINYINT     -- [OBLIGATORIO] 1 = Activar, 0 = Desactivar
)
THIS_PROC: BEGIN
    
    /* ========================================================================================
       BLOQUE 0: VARIABLES DE ENTORNO
       ======================================================================================== */
    /* Snapshot del estado actual */
    DECLARE v_Activo_Actual      TINYINT DEFAULT NULL;
    DECLARE v_Nombre_Tema        VARCHAR(255) DEFAULT NULL;
    DECLARE v_Id_TipoInst        INT DEFAULT NULL;
    
    /* Variables para validaciones */
    DECLARE v_Tipo_Activo        TINYINT DEFAULT NULL;
    
    /* Variables de Diagnóstico Operativo */
    DECLARE v_Curso_Conflictivo  VARCHAR(50) DEFAULT NULL;
    DECLARE v_Estatus_Conflicto  VARCHAR(255) DEFAULT NULL;
    
    /* ========================================================================================
       BLOQUE 1: HANDLERS (SEGURIDAD TÉCNICA)
       ======================================================================================== */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;
    
    /* ========================================================================================
       BLOQUE 2: VALIDACIONES BÁSICAS (FAIL FAST)
       ======================================================================================== */
    IF _Id_Tema IS NULL OR _Id_Tema <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: ID de Tema inválido.';
    END IF;

    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El estatus solo puede ser 0 o 1.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: CANDADO OPERATIVO (INTEGRACIÓN CON CAPACITACIONES)
       Propósito: Validar que el tema no sea esencial para operaciones VIVAS.
       Condición: Solo se ejecuta si la intención es APAGAR (0) el tema.
       ======================================================================================== */
    IF _Nuevo_Estatus = 0 THEN
        
        /* Buscamos si existe alguna capacitación VIGENTE que use este tema y esté en una fase activa.
           Usamos JOINs para obtener nombres legibles para el error. */
        
        SELECT 
            C.Numero_Capacitacion,
            EC.Nombre -- Nombre del Estatus (ej: "EN CURSO")
        INTO 
            v_Curso_Conflictivo,
            v_Estatus_Conflicto
        FROM `Capacitaciones` C
        /* Unimos con DatosCapacitaciones para ver el historial activo */
        INNER JOIN `DatosCapacitaciones` DC ON C.Id_Capacitacion = DC.Fk_Id_Capacitacion
        /* Unimos con el Catálogo para leer la regla de negocio (Es_Final) */
        INNER JOIN `Cat_Estatus_Capacitacion` EC ON DC.Fk_Id_CatEstCap = EC.Id_CatEstCap
        WHERE 
            C.Fk_Id_Cat_TemasCap = _Id_Tema
            AND C.Activo = 1  -- La capacitación general está activa
            AND DC.Activo = 1 -- El registro de detalle es el vigente
			/* LISTA NEGRA DE ESTATUS (NO SE PUEDE BORRAR SI ESTÁ AQUÍ):
               1 = Programado
               2 = Por Iniciar
               3 = En Curso
               5 = En Evaluación
               9 = Reprogramado */
            -- AND DC.Fk_Id_CatEstCap IN (1, 2, 3, 5, 9)
            /* --- KILLSWITCH DINÁMICO (Soportado por la documentación de IDs arriba) --- */
            AND EC.Es_Final = 0 
        LIMIT 1;

        /* Si encontramos un conflicto, abortamos con un mensaje claro */
        IF v_Curso_Conflictivo IS NOT NULL THEN
            SET @MensajeError = CONCAT('CONFLICTO OPERATIVO [409]: No se puede desactivar el Tema. Está asignado a la capacitación activa "', v_Curso_Conflictivo, '" que se encuentra "', v_Estatus_Conflicto, '". Este estatus se considera operativo (No Final). Debe finalizar o cancelar esa capacitación primero.');
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @MensajeError;
        END IF;

    END IF;

    /* ========================================================================================
       BLOQUE 4: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 4.1: LEER Y BLOQUEAR EL REGISTRO
       ----------------------------------------------------------------------------------------
       Adquirimos un "Write Lock" sobre la fila. Esto asegura serialización. */
    
    SELECT `Activo`, `Nombre`, `Fk_Id_CatTipoInstCap`
    INTO v_Activo_Actual, v_Nombre_Tema, v_Id_TipoInst
    FROM `Cat_Temas_Capacitacion`
    WHERE `Id_Cat_TemasCap` = _Id_Tema
    FOR UPDATE;

    /* Si no se encuentra, abortamos */
    IF v_Activo_Actual IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Tema solicitado no existe.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4.2: IDEMPOTENCIA (SIN CAMBIOS)
       ---------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        COMMIT;
        SELECT CONCAT('AVISO: El Tema "', v_Nombre_Tema, '" ya se encuentra en el estado solicitado.') AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Id_Tema AS Id_Tema,
               _Nuevo_Estatus AS Nuevo_Estatus;
        
        LEAVE THIS_PROC; 
    END IF;

    /* ========================================================================================
       BLOQUE 5: VALIDACIÓN JERÁRQUICA (SOLO AL REACTIVAR)
       ======================================================================================== */
    IF _Nuevo_Estatus = 1 THEN
        
        /* Solo validamos si tiene un Tipo asignado (no es huérfano) */
        IF v_Id_TipoInst IS NOT NULL THEN
            
            SELECT `Activo` INTO v_Tipo_Activo
            FROM `Cat_Tipos_Instruccion_Cap`
            WHERE `Id_CatTipoInstCap` = v_Id_TipoInst;

            /* Si el padre está inactivo, prohibimos la reactivación del hijo */
            IF v_Tipo_Activo = 0 THEN
                ROLLBACK;
                SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD [409]: No se puede reactivar este Tema porque su Categoría Padre (Tipo de Instrucción) está INACTIVA. Reactive la categoría primero.';
            END IF;
        END IF;
    END IF;
    
    
/* CODIGO LEGADO DE VALIDACION (Referencia)
    IF _Nuevo_Estatus = 1 THEN
        
        IF v_Id_TipoInst IS NOT NULL THEN
            
            SELECT `Activo` INTO v_Tipo_Activo
            FROM `Cat_Tipos_Instruccion_Cap`
            WHERE `Id_CatTipoInstCap` = v_Id_TipoInst;

             Si el padre está inactivo (0), se LANZA ERROR para detener el flujo 
            IF v_Tipo_Activo = 0 THEN
                ROLLBACK;
                SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD [409]: No se puede reactivar este Tema porque su Categoría Padre (Tipo de Instrucción) está INACTIVA. Reactive la categoría primero.';
            END IF;
        END IF;
    END IF;*/

    /* ========================================================================================
       BLOQUE 6: PERSISTENCIA (UPDATE)
       ======================================================================================== */
    UPDATE `Cat_Temas_Capacitacion`
    SET 
        `Activo`     = _Nuevo_Estatus,
        `updated_at` = NOW()
    WHERE 
        `Id_Cat_TemasCap` = _Id_Tema;

    /* ========================================================================================
       BLOQUE 7: CONFIRMACIÓN Y RESPUESTA
       ======================================================================================== */
    COMMIT;

    SELECT 
        CASE 
            WHEN _Nuevo_Estatus = 1 THEN CONCAT('ÉXITO: El Tema "', v_Nombre_Tema, '" ha sido REACTIVADO.')
            ELSE CONCAT('ÉXITO: El Tema "', v_Nombre_Tema, '" ha sido DESACTIVADO (Archivado).')
        END AS Mensaje,
        
        'ESTATUS_MODIFICADO' AS Accion,
        _Id_Tema AS Id_Tema,
        _Nuevo_Estatus AS Nuevo_Estatus;

END$$

DELIMITER ;


/* ====================================================================================================
	PROCEDIMEINTOS: SP_CambiarEstatusEstatusCapacitacion
   ====================================================================================================

   ----------------------------------------------------------------------------------------------------
   I. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (EXECUTIVE SUMMARY)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento administra el mecanismo de "Baja Lógica" (Soft Delete) para el catálogo maestro
   de Estatus de Capacitación.
   
   Permite al Administrador:
     A) DESACTIVAR (Ocultar): Retirar un estatus de los selectores para que no se use en nuevas
        capacitaciones (ej: un estatus obsoleto como "PENDIENTE DE FIRMA").
     B) REACTIVAR (Mostrar): Recuperar un estatus histórico para volver a utilizarlo.

   ----------------------------------------------------------------------------------------------------
   II. MATRIZ DE RIESGOS Y REGLAS DE BLINDAJE (INTEGRITY RULES)
   ----------------------------------------------------------------------------------------------------
   [RN-01] CANDADO DESCENDENTE (DEPENDENCY CHECK):
      - Problema: Si desactivamos el estatus "EN CURSO" mientras hay 50 cursos impartiéndose en ese
        momento, rompemos la integridad visual del sistema. Los cursos aparecerían con un estatus
        "nulo" o inválido en los reportes.
      - Solución: Antes de desactivar (`_Nuevo_Estatus = 0`), el sistema escanea la tabla operativa
        `DatosCapacitaciones`.
      - Condición de Bloqueo: Si existe AL MENOS UNA capacitación activa (`Activo = 1`) que tenga
        asignado este estatus, la operación se ABORTA con un error 409 (Conflicto).

   [RN-02] PROTECCIÓN DE HISTORIAL:
      - Nota Técnica: La validación solo busca capacitaciones ACTIVAS. Si el estatus fue usado en
        capacitaciones de hace 5 años que ya están borradas o archivadas, NO bloqueamos la baja.
        Esto permite limpiar el catálogo sin quedar "secuestrados" por el pasado.

   ----------------------------------------------------------------------------------------------------
   III. ARQUITECTURA TÉCNICA (CONCURRENCY & PERFORMANCE)
   ----------------------------------------------------------------------------------------------------
   1. BLOQUEO PESIMISTA (PESSIMISTIC LOCKING):
      - Se utiliza `SELECT ... FOR UPDATE` al inicio.
      - Esto "congela" la fila del estatus. Garantiza que nadie más edite el nombre o la lógica
        del estatus mientras nosotros estamos decidiendo si lo apagamos o no.

   2. IDEMPOTENCIA (OPTIMIZACIÓN DE I/O):
      - Antes de escribir en disco, verificamos: ¿El estatus ya está como lo pide el usuario?
      - Si `Activo_Actual == Nuevo_Estatus`, retornamos éxito inmediato sin realizar el UPDATE.
      - Beneficio: Ahorra ciclos de escritura en disco y evita "ensuciar" el log de transacciones.

   ----------------------------------------------------------------------------------------------------
   IV. CONTRATO DE SALIDA (OUTPUT)
   ----------------------------------------------------------------------------------------------------
   Retorna una fila con:
      - Mensaje: Feedback claro para la UI.
      - Accion: 'ESTATUS_CAMBIADO', 'SIN_CAMBIOS'.
      - Id_Estatus: El recurso manipulado.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusEstatusCapacitacion`$$

CREATE PROCEDURE `SP_CambiarEstatusEstatusCapacitacion`(
    /* ------------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS DE ENTRADA
       ------------------------------------------------------------------------------------------------ */
    IN _Id_Estatus     INT,     -- [OBLIGATORIO] Identificador del Estatus a modificar.
    IN _Nuevo_Estatus  TINYINT  -- [OBLIGATORIO] 1 = Activar (Visible), 0 = Desactivar (Oculto).
)
THIS_PROC: BEGIN

    /* ============================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO
       Contenedores para almacenar la "foto" del registro y auxiliares de validación.
       ============================================================================================ */
    
    /* Variable para validar existencia y bloquear la fila */
    DECLARE v_Existe INT DEFAULT NULL;
    
    /* Variables para el Snapshot (Estado Actual) */
    DECLARE v_Activo_Actual  TINYINT(1) DEFAULT NULL;
    DECLARE v_Nombre_Estatus VARCHAR(255) DEFAULT NULL;
    
    /* Semáforo para contar dependencias activas (Hijos en DatosCapacitaciones) */
    DECLARE v_Dependencias   INT DEFAULT NULL;

    /* ============================================================================================
       BLOQUE 1: HANDLERS (SISTEMA DE DEFENSA)
       Manejo robusto de errores técnicos.
       ============================================================================================ */
    
    /* Handler Genérico: Ante cualquier error SQL (Deadlock, Conexión perdida, etc.),
       revertimos la transacción para mantener la consistencia de la BD. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; -- Propagar el error original al backend.
    END;

    /* ============================================================================================
       BLOQUE 2: VALIDACIONES PREVIAS (FAIL FAST)
       Rechazar peticiones basura antes de abrir transacciones costosas.
       ============================================================================================ */
    
    /* 2.1 Validación de Identidad */
    IF _Id_Estatus IS NULL OR _Id_Estatus <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El ID del Estatus es inválido.';
    END IF;

    /* 2.2 Validación de Dominio (Solo 0 o 1) */
    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El estatus solo puede ser 0 (Inactivo) o 1 (Activo).';
    END IF;

    /* ============================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       El núcleo de la seguridad transaccional.
       ============================================================================================ */
    START TRANSACTION;

    /* --------------------------------------------------------------------------------------------
       PASO 3.1: LECTURA Y BLOQUEO DEL REGISTRO (SNAPSHOT)
       - Buscamos el registro en `Cat_Estatus_Capacitacion`.
       - `FOR UPDATE`: Adquiere un candado de escritura (X-Lock) sobre la fila.
       - Efecto: Serializa la operación. Nadie más puede tocar este estatus hasta el COMMIT.
       -------------------------------------------------------------------------------------------- */
    SELECT 1, `Activo`, `Nombre` 
    INTO v_Existe, v_Activo_Actual, v_Nombre_Estatus
    FROM `Cat_Estatus_Capacitacion`
    WHERE `Id_CatEstCap` = _Id_Estatus
    LIMIT 1
    FOR UPDATE;

    /* --------------------------------------------------------------------------------------------
       PASO 3.2: VALIDACIÓN DE EXISTENCIA
       Si el SELECT anterior no encontró nada, v_Existe seguirá siendo NULL.
       -------------------------------------------------------------------------------------------- */
    IF v_Existe IS NULL THEN
        ROLLBACK; -- Liberar recursos aunque no haya locks efectivos.
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Estatus solicitado no existe en el catálogo.';
    END IF;

    /* --------------------------------------------------------------------------------------------
       PASO 3.3: VERIFICACIÓN DE IDEMPOTENCIA (OPTIMIZACIÓN "SIN CAMBIOS")
       - Lógica: "Si ya está encendido, no intentes encenderlo de nuevo".
       - Beneficio: Evita escrituras en disco y preserva el timestamp `updated_at`.
       -------------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        
        COMMIT; -- Liberamos el bloqueo inmediatamente.
        
        /* Retornamos mensaje de éxito informativo */
        SELECT CONCAT('AVISO: El Estatus "', v_Nombre_Estatus, '" ya se encuentra en el estado solicitado.') AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               _Id_Estatus AS Id_Estatus,
               _Nuevo_Estatus AS Nuevo_Estatus;
        
        LEAVE THIS_PROC; -- Salimos del procedimiento.
    END IF;

    /* ============================================================================================
       BLOQUE 4: REGLAS DE BLINDAJE (CANDADOS DE INTEGRIDAD)
       Solo ejecutamos esto si realmente vamos a cambiar el estado.
       ============================================================================================ */

    /* --------------------------------------------------------------------------------------------
       PASO 4.1: REGLA DE DESACTIVACIÓN (CANDADO DESCENDENTE)
       - Condición: Solo si `_Nuevo_Estatus = 0` (Intentamos apagar).
       - Objetivo: Evitar dejar capacitaciones "huérfanas" de estatus.
       -------------------------------------------------------------------------------------------- */
    IF _Nuevo_Estatus = 0 THEN
        
        /* Reiniciamos el semáforo */
        SET v_Dependencias = NULL;

        /* [SONDEO DE DEPENDENCIAS]:
           Consultamos la tabla operativa `DatosCapacitaciones`.
           Buscamos si existe AL MENOS UNA fila que cumpla:
             1. Use este estatus (`Fk_Id_CatEstCap`).
             2. Esté VIVA (`Activo = 1`). No nos importan los registros históricos borrados.
        */
        SELECT 1 INTO v_Dependencias
        FROM `DatosCapacitaciones`
        WHERE `Fk_Id_CatEstCap` = _Id_Estatus
          AND `Activo` = 1
        LIMIT 1; 

        /* [DISPARADOR DE BLOQUEO]:
           Si `v_Dependencias` no es NULL, significa que encontramos un conflicto. */
        IF v_Dependencias IS NOT NULL THEN
            ROLLBACK; -- Cancelamos la operación.
            
            /* Retornamos un error 409 (Conflicto) claro para el usuario */
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'BLOQUEO DE INTEGRIDAD [409]: No se puede desactivar este Estatus porque existen CAPACITACIONES ACTIVAS asignadas a él. Primero debe cambiar el estatus de esas capacitaciones a otro valor.';
        END IF;

    END IF;

    /* ============================================================================================
       BLOQUE 5: PERSISTENCIA (EJECUCIÓN DEL CAMBIO)
       Si llegamos aquí, hemos pasado todas las validaciones. Es seguro escribir.
       ============================================================================================ */
    
    /* Ejecutamos el UPDATE físico en la tabla */
    UPDATE `Cat_Estatus_Capacitacion`
    SET 
        `Activo` = _Nuevo_Estatus,
        `updated_at` = NOW() -- Auditoría: Registramos el momento exacto del cambio.
    WHERE `Id_CatEstCap` = _Id_Estatus;

    /* ============================================================================================
       BLOQUE 6: CONFIRMACIÓN Y RESPUESTA FINAL
       ============================================================================================ */
    
    /* Confirmamos la transacción (Hacemos permanentes los cambios y liberamos locks) */
    COMMIT;

    /* Generamos la respuesta para el Frontend */
    SELECT 
        CASE 
            WHEN _Nuevo_Estatus = 1 THEN CONCAT('ÉXITO: El Estatus "', v_Nombre_Estatus, '" ha sido REACTIVADO y está disponible para su uso.')
            ELSE CONCAT('ÉXITO: El Estatus "', v_Nombre_Estatus, '" ha sido DESACTIVADO (Baja Lógica).')
        END AS Mensaje,
        'ESTATUS_CAMBIADO' AS Accion,
        _Id_Estatus AS Id_Estatus,
        _Nuevo_Estatus AS Nuevo_Estatus;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusModalidadCapacitacion
   ====================================================================================================
   
   ----------------------------------------------------------------------------------------------------
   I. RESUMEN EJECUTIVO Y CONTEXTO DE NEGOCIO (EXECUTIVE SUMMARY)
   ----------------------------------------------------------------------------------------------------
   [DEFINICIÓN DEL COMPONENTE]:
   Este procedimiento actúa como el "Interruptor Maestro de Disponibilidad" (Availability Toggle) para 
   el catálogo de Modalidades de Capacitación. Su función no es simplemente actualizar una columna 
   booleana; es un orquestador de integridad que decide si es seguro retirar un recurso del ecosistema.

   [EL RIESGO OPERATIVO (THE BUSINESS RISK)]:
   En un sistema de gestión de capacitación (LMS), la "Modalidad" no es un dato decorativo; es un 
   eje estructural. Define la logística, los recursos necesarios (salas vs licencias Zoom) y las 
   reglas de asistencia.
   
   Escenario Catastrófico:
   1. Un Administrador desactiva la modalidad "VIRTUAL" un lunes a las 09:00 AM.
   2. Existen 50 cursos programados para iniciar esa semana bajo esa modalidad.
   3. Resultado: Los instructores no pueden registrar asistencia, los reportes de cumplimiento fallan 
      por "Modalidad Nula/Inválida", y la operación se detiene.

   [LA SOLUCIÓN ARQUITECTÓNICA (THE SOLUTION)]:
   Implementamos un patrón de diseño llamado "Safe Soft Delete" (Baja Lógica Segura).
   El sistema realiza un análisis de impacto en tiempo real antes de permitir la desactivación.
   Si detecta dependencias vivas, bloquea la acción y protege la continuidad del negocio.

   ----------------------------------------------------------------------------------------------------
   II. MATRIZ DE REGLAS DE BLINDAJE (SECURITY & INTEGRITY RULES)
   ----------------------------------------------------------------------------------------------------
   [RN-01] INTEGRIDAD REFERENCIAL DESCENDENTE (DOWNSTREAM INTEGRITY):
      - Principio: "Un padre no puede morir si sus hijos dependen de él para vivir".
      - Regla Técnica: No se permite establecer `Activo = 0` si existen registros en la tabla 
        `DatosCapacitaciones` que cumplan dos condiciones simultáneas:
          a) Estén vinculados a esta Modalidad (`Fk_Id_CatModalCap`).
          b) Tengan un estatus operativo VIGENTE (`Activo = 1`).
      - Excepción: Si los cursos históricos ya están "muertos" (Cancelados/Finalizados/Borrados), 
        el bloqueo no aplica. Esto permite la depuración del catálogo a largo plazo.

   [RN-02] IDEMPOTENCIA DE ESTADO (STATE IDEMPOTENCY):
      - Principio: "No arregles lo que no está roto".
      - Regla Técnica: Si el sistema recibe una solicitud para cambiar el estatus al valor que YA tiene 
        actualmente (ej: Activar una modalidad Activa), el procedimiento aborta la escritura y retorna 
        un mensaje de éxito informativo.
      - Beneficio: 
          1. Reducción de I/O en disco (no hay UPDATE).
          2. Preservación de la auditoría (no se altera `updated_at` artificialmente).
          3. Menor bloqueo de filas (mayor concurrencia).

   [RN-03] ATOMICIDAD TRANSACCIONAL (ACID COMPLIANCE):
      - Principio: "Todo o Nada".
      - Mecanismo: La lectura de verificación y la escritura del cambio ocurren dentro de una 
        transacción aislada con nivel SERIALIZABLE (vía `FOR UPDATE`).
      - Justificación: Evita la "Condición de Carrera del Milisegundo" (Race Condition), donde un 
        usuario crea un curso nuevo justo en el instante entre la validación y la desactivación.

   ----------------------------------------------------------------------------------------------------
   III. ESPECIFICACIÓN TÉCNICA DE ALTO NIVEL (TECHNICAL SPECS)
   ----------------------------------------------------------------------------------------------------
   - TIPO: Stored Procedure Transaccional (InnoDB).
   - AISLAMIENTO: Pessimistic Locking (Bloqueo Pesimista).
   - INPUT: 
       * _Id_Modalidad (INT): Identificador único.
       * _Nuevo_Estatus (TINYINT): Flag binario (0/1).
   - OUTPUT: Resultset JSON-Friendly { Mensaje, Accion, Estado_Nuevo, Estado_Anterior }.
   - ERRORES CONTROLADOS: 
       * 400 (Bad Request): Datos de entrada inválidos.
       * 404 (Not Found): Recurso inexistente.
       * 409 (Conflict): Bloqueo por reglas de negocio.
       * 500 (Internal Server Error): Fallos de SQL.

   ----------------------------------------------------------------------------------------------------
   IV. MAPA DE MEMORIA Y VARIABLES (MEMORY ALLOCATION)
   ----------------------------------------------------------------------------------------------------
   El procedimiento reserva espacio para:
      - Snapshots del registro actual (para comparar antes/después).
      - Contadores de dependencias (para la lógica de bloqueo).
      - Banderas de control de flujo.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusModalidadCapacitacion`$$

CREATE PROCEDURE `SP_CambiarEstatusModalidadCapacitacion`(
    /* ------------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos los datos crudos desde el controlador del Backend.
       ------------------------------------------------------------------------------------------------ */
    IN _Id_Modalidad INT,        -- [OBLIGATORIO] Identificador del recurso a modificar.
    IN _Nuevo_Estatus TINYINT    -- [OBLIGATORIO] 1 = Activar, 0 = Desactivar.
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: INICIALIZACIÓN DE VARIABLES DE ESTADO
       Propósito: Definir los contenedores en memoria para la lógica del procedimiento.
       ================================================================================================ */
    
    /* [Snapshot del Estado Actual]:
       Almacenamos cómo está el registro en la BD antes de tocarlo. 
       Vital para la verificación de idempotencia y para el mensaje de respuesta. */
    DECLARE v_Estatus_Actual TINYINT(1) DEFAULT NULL;
    DECLARE v_Nombre_Modalidad VARCHAR(255) DEFAULT NULL;
    
    /* [Semáforo de Dependencias]:
       Contador utilizado para escanear la tabla `DatosCapacitaciones`.
       Si este valor es > 0, significa que hay hijos vivos y debemos activar el bloqueo. */
    DECLARE v_Dependencias_Activas INT DEFAULT 0;

    /* [Bandera de Existencia]:
       Variable auxiliar para confirmar si el ID proporcionado es válido. */
    DECLARE v_Existe INT DEFAULT NULL;

    /* ================================================================================================
       BLOQUE 1: GESTIÓN DE EXCEPCIONES Y SEGURIDAD (ERROR HANDLING)
       Propósito: Garantizar que la base de datos nunca quede en un estado inconsistente.
       ================================================================================================ */
    
    /* Handler Genérico (Catch-All):
       Ante cualquier error SQL inesperado (Deadlock, Conexión perdida, Corrupción de índice),
       este bloque se activa automáticamente para:
         1. Revertir cualquier cambio pendiente (ROLLBACK).
         2. Propagar el error original al cliente (RESIGNAL). */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: PROTOCOLO DE VALIDACIÓN PREVIA (FAIL FAST STRATEGY)
       Propósito: Rechazar peticiones malformadas ("Basura") antes de consumir recursos.
       ================================================================================================ */
    
    /* 2.1 Validación de Dominio (Type Safety):
       El estatus es un valor booleano lógico. Solo aceptamos 0 o 1.
       Cualquier otro valor (ej: 2, 99, -1) indica un error en la capa de aplicación. 
    IF _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR DE LÓGICA [400]: El parámetro _Nuevo_Estatus solo acepta valores binarios: 0 (Inactivo) o 1 (Activo).';
    END IF;*/
    
    /* 2.1 Validación de Dominio (Type Safety):
       El estatus es un valor booleano lógico. Solo aceptamos 0 o 1.
       Agregamos 'IS NULL' para capturar el error de lógica de tres estados de SQL. */
    IF _Nuevo_Estatus IS NULL OR _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR DE LÓGICA [400]: El estatus es obligatorio y solo acepta valores binarios: 0 (Inactivo) o 1 (Activo).';
    END IF;

    /* 2.2 Validación de Identidad (Integrity Check):
       El ID debe ser un entero positivo. */
    IF _Id_Modalidad IS NULL OR _Id_Modalidad <= 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El ID de la Modalidad es inválido o nulo.';
    END IF;

    /* ================================================================================================
       BLOQUE 3: INICIO DE TRANSACCIÓN Y BLOQUEO PESIMISTA
       El núcleo de la seguridad transaccional. Aquí aislamos el proceso del resto del mundo.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: LECTURA Y BLOQUEO DEL RECURSO (SNAPSHOT ACQUISITION)
       
       Mecánica Técnica:
       Ejecutamos un SELECT con la cláusula `FOR UPDATE`.
       
       Efecto en el Motor de Base de Datos (InnoDB):
       1. Localiza la fila específica en el índice primario (`Id_CatModalCap`).
       2. Coloca un "Exclusive Lock (X-Lock)" sobre esa fila.
       3. Cualquier otra transacción que intente leer o escribir en ESTA fila entrará en 
          estado de espera (WAIT) hasta que nosotros hagamos COMMIT o ROLLBACK.
       
       Justificación de Negocio:
       Evita que otro administrador edite el nombre de la modalidad o la borre físicamente
       mientras nosotros estamos evaluando si es seguro desactivarla.
       ------------------------------------------------------------------------------------------------ */
    SELECT `Activo`, `Nombre` 
    INTO v_Estatus_Actual, v_Nombre_Modalidad
    FROM `Cat_Modalidad_Capacitacion` 
    WHERE `Id_CatModalCap` = _Id_Modalidad 
    LIMIT 1
    FOR UPDATE;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: VALIDACIÓN DE EXISTENCIA (NOT FOUND HANDLER)
       Si la variable v_Estatus_Actual sigue siendo NULL, significa que el SELECT no encontró nada.
       El registro no existe (Error 404).
       ------------------------------------------------------------------------------------------------ */
    IF v_Estatus_Actual IS NULL THEN
        ROLLBACK; -- Liberamos recursos aunque no haya locks efectivos.
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: La Modalidad solicitada no existe en el catálogo maestro.';
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.3: VERIFICACIÓN DE IDEMPOTENCIA (OPTIMIZACIÓN DE RECURSOS)
       
       Concepto:
       Una operación es idempotente si realizarla múltiples veces tiene el mismo efecto que una sola vez.
       
       Lógica Aplicada:
       Si el usuario pide "ACTIVAR" una modalidad que ya está "ACTIVA", no hay cambio de estado.
       Por lo tanto, no hay necesidad de ejecutar un UPDATE.
       
       Beneficios:
       1. Ahorro de I/O de disco (escritura).
       2. Ahorro de espacio en logs de transacción.
       3. Integridad de Auditoría: No se modifica la fecha `updated_at` falsamente.
       ------------------------------------------------------------------------------------------------ */
    IF v_Estatus_Actual = _Nuevo_Estatus THEN
        
        COMMIT; -- Liberamos el bloqueo inmediatamente.
        
        /* Retornamos un mensaje de éxito informativo pero aclaratorio */
        SELECT CONCAT('AVISO: La Modalidad "', v_Nombre_Modalidad, '" ya se encuentra en el estado solicitado (', IF(_Nuevo_Estatus=1,'ACTIVO','INACTIVO'), ').') AS Mensaje, 
               'SIN_CAMBIOS' AS Accion,
               v_Estatus_Actual AS Estado_Anterior,
               _Nuevo_Estatus AS Estado_Nuevo;
        
        LEAVE THIS_PROC; -- Salimos del procedimiento limpiamente.
    END IF;

    /* ================================================================================================
       BLOQUE 4: EVALUACIÓN DE REGLAS DE BLINDAJE (CANDADOS DE INTEGRIDAD)
       Solo ejecutamos este análisis profundo si realmente vamos a cambiar el estado.
       ================================================================================================ */

    /* ------------------------------------------------------------------------------------------------
       PASO 4.1: CANDADO OPERATIVO DESCENDENTE (SOLO AL DESACTIVAR)
       
       Contexto:
       Desactivar (`_Nuevo_Estatus = 0`) es una operación destructiva lógica. Puede dejar huérfanos.
       Activar (`_Nuevo_Estatus = 1`) es una operación segura (generalmente).
       
       Por tanto, este bloque solo se ejecuta si la intención es APAGAR el recurso.
       ------------------------------------------------------------------------------------------------ */
    IF _Nuevo_Estatus = 0 THEN
        
        /* [ANÁLISIS DE DEPENDENCIAS]:
           Consultamos la tabla operativa `DatosCapacitaciones`.
           Esta tabla contiene el historial de todos los cursos impartidos.
           
           Criterios de Búsqueda:
           1. `Fk_Id_CatModalCap` = ID de la modalidad actual.
           2. `Activo` = 1.
           
           ¿Por qué `Activo = 1`?
           Porque solo nos preocupan los cursos VIVOS. Si un curso fue cancelado o eliminado
           lógicamente en el pasado, no representa un conflicto para desactivar la modalidad hoy.
           Pero si el curso está programado, en curso o finalizado (sin borrar), es una dependencia dura. */
        
        SELECT COUNT(*) INTO v_Dependencias_Activas
        FROM `DatosCapacitaciones`
        WHERE `Fk_Id_CatModalCap` = _Id_Modalidad
          AND `Activo` = 1; -- Solo nos importan los cursos vigentes.

        /* [DISPARADOR DE BLOQUEO DE INTEGRIDAD]:
           Si el contador es mayor a 0, significa que hay al menos un curso que depende de esta modalidad.
           La operación es ILEGAL bajo las reglas de negocio. */
        IF v_Dependencias_Activas > 0 THEN
            
            ROLLBACK; -- Cancelamos la operación. Se liberan los locks. Ningún dato fue tocado.
            
            /* Retornamos un error 409 (Conflicto) claro y explicativo para el usuario */
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'BLOQUEO DE INTEGRIDAD [409]: Operación Denegada. No se puede desactivar esta Modalidad porque existen CAPACITACIONES ACTIVAS que dependen de ella. Para proceder, primero debe finalizar, cancelar o reasignar los cursos asociados.';
        END IF;
    END IF;

    /* ================================================================================================
       BLOQUE 5: PERSISTENCIA (EJECUCIÓN DEL CAMBIO)
       Si el flujo llega a este punto, significa que:
         1. El registro existe.
         2. El cambio es necesario (no es idempotente).
         3. No viola ninguna regla de integridad referencial.
       Es seguro escribir en el disco.
       ================================================================================================ */
    
    UPDATE `Cat_Modalidad_Capacitacion` 
    SET `Activo` = _Nuevo_Estatus, 
        `updated_at` = NOW() -- Auditoría: Registramos el momento exacto del cambio.
    WHERE `Id_CatModalCap` = _Id_Modalidad;

    /* ================================================================================================
       BLOQUE 6: CONFIRMACIÓN Y RESPUESTA FINAL
       Propósito: Cerrar la transacción y comunicar el resultado al cliente.
       ================================================================================================ */
    
    /* Confirmamos la transacción (COMMIT).
       Esto hace permanentes los cambios en el disco y libera el bloqueo de la fila,
       permitiendo que otros usuarios vuelvan a leer/escribir este registro. */
    COMMIT;

    /* Generamos la respuesta estructurada para el Frontend.
       Usamos lógica condicional para dar un mensaje humano ("Reactivada" vs "Desactivada"). */
    SELECT 
        CASE 
            WHEN _Nuevo_Estatus = 1 THEN CONCAT('ÉXITO: La Modalidad "', v_Nombre_Modalidad, '" ha sido REACTIVADA y está disponible para nuevas asignaciones.')
            ELSE CONCAT('ÉXITO: La Modalidad "', v_Nombre_Modalidad, '" ha sido DESACTIVADA (Baja Lógica) correctamente.')
        END AS Mensaje,
        'ESTATUS_CAMBIADO' AS Accion,
        v_Estatus_Actual AS Estado_Anterior,
        _Nuevo_Estatus AS Estado_Nuevo;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_CambiarEstatusParticipante (Gestor de Ciclo de Vida)                    
   ====================================================================================================

   ----------------------------------------------------------------------------------------------------
   I. MANIFIESTO DE PROPÓSITO Y CONTEXTO OPERATIVO (THE "WHY")
   ----------------------------------------------------------------------------------------------------
   [DEFINICIÓN DEL COMPONENTE]:
   Este Stored Procedure (SP) no es un simple script de actualización. Es el **Gobernador de Disponibilidad**
   del catálogo `Cat_Estatus_Participante`. Su responsabilidad es administrar la transición de estados
   entre "Operativo" (1) y "Obsoleto/Baja Lógica" (0).

   [EL PROBLEMA DE LA "HISTORIA VIVA" (THE LIVE HISTORY PROBLEM)]:
   En este sistema, la tabla `Capacitaciones_Participantes` actúa como una bitácora histórica inmutable
   (no tiene borrado lógico). Esto presenta un desafío único para la integridad referencial:
   
   * Si desactivamos el estatus "INSCRITO", ¿qué pasa con los alumnos que están en clase AHORA MISMO?
   
   No podemos simplemente preguntar "¿Este estatus se ha usado antes?". La respuesta siempre será SÍ.
   Debemos preguntar: **"¿Este estatus se está usando en un proceso VIVO en este preciso segundo?"**

   [SOLUCIÓN: EL KILLSWITCH FORENSE DINÁMICO]:
   Implementamos un algoritmo de **Validación de Integridad Transitiva de 4 Niveles**:
   1.  Nivel 1 (El Estatus): ¿Quién lo tiene asignado?
   2.  Nivel 2 (El Alumno): ¿A qué capacitación pertenece ese alumno?
   3.  Nivel 3 (La Vida del Curso): ¿El registro del curso está activo (`Activo=1`)?
   4.  Nivel 4 (La Fase del Curso): ¿El curso está en una etapa operativa (No Final)?

   Solo si se superan los 4 niveles de riesgo, se bloquea la desactivación. De lo contrario, se permite
   archivar el estatus como "historia antigua".

   ----------------------------------------------------------------------------------------------------
   II. MATRIZ DE REGLAS DE BLINDAJE (HARD CONSTRAINTS)
   ----------------------------------------------------------------------------------------------------
   [RN-01] INTEGRIDAD DE DOMINIO (INPUT HYGIENE):
      - Principio: "Calidad a la entrada, calidad a la salida".
      - Mecanismo: Se rechazan explícitamente valores NULL o fuera del rango binario [0,1].
      - Objetivo: Prevenir comportamientos indefinidos por lógica trivalente de SQL.

   [RN-02] AISLAMIENTO SERIALIZABLE (ACID CONCURRENCY):
      - Principio: "Un solo escritor a la vez".
      - Mecanismo: Uso de `SELECT ... FOR UPDATE` (Bloqueo Pesimista / Pessimistic Locking).
      - Objetivo: Evitar la "Condición de Carrera" (Race Condition) donde dos administradores
        intentan modificar el mismo estatus simultáneamente.

   [RN-03] IDEMPOTENCIA DE ESTADO (RESOURCE OPTIMIZATION):
      - Principio: "Si no está roto, no lo arregles".
      - Mecanismo: Si el estado en disco ya es igual al solicitado, se aborta la escritura.
      - Objetivo: Reducir I/O de disco, evitar crecimiento del Transaction Log y preservar la
        fidelidad forense del campo `updated_at`.

   [RN-04] PROTOCOLO DE DESACTIVACIÓN SEGURA (SAFE DELETE):
      - Principio: "No apagues la luz si hay gente operando".
      - Mecanismo: Escaneo profundo de dependencias vivas mediante JOINs.
      - Acción: Error 409 (Conflict) si se detectan dependencias activas.

   ----------------------------------------------------------------------------------------------------
   III. ESPECIFICACIÓN TÉCNICA (TECHNICAL SPECS)
   ----------------------------------------------------------------------------------------------------
   - TIPO: Transacción Atómica.
   - SCOPE: `Cat_Estatus_Participante` (Target), `Capacitaciones_Participantes` (Dependency),
            `DatosCapacitaciones` (Context), `Cat_Estatus_Capacitacion` (Logic).
   - OUTPUT: JSON-Structure Resultset { Mensaje, Accion, Estado_Nuevo, Estado_Anterior, Id }.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_CambiarEstatusParticipante`$$

CREATE PROCEDURE `SP_CambiarEstatusParticipante`(
    /* ------------------------------------------------------------------------------------------------
       SECCIÓN A: CAPA DE ENTRADA (INPUT PARAMETERS)
       Recibimos los datos atómicos necesarios para ejecutar la transacción.
       ------------------------------------------------------------------------------------------------ */
    IN _Id_Estatus    INT,       -- [OBLIGATORIO] Identificador Único (PK) del estatus a modificar.
    IN _Nuevo_Estatus TINYINT    -- [OBLIGATORIO] Bandera de estado deseado (1=Activar, 0=Desactivar).
)
THIS_PROC: BEGIN
    
    /* ============================================================================================
       SECCIÓN B: DECLARACIÓN DE VARIABLES Y CONTEXTO (VARIABLE SCOPE)
       Definimos los contenedores de memoria necesarios para el procesamiento lógico.
       ============================================================================================ */
    
    /* [B.1] Variables de Snapshot (Estado Previo):
       Almacenan la "foto" del registro tal como existe en disco antes de tocarlo.
       Vitales para la lógica de Idempotencia y para construir mensajes de error humanos. */
    DECLARE v_Nombre_Actual VARCHAR(255) DEFAULT NULL; -- Nombre descriptivo (ej: 'APROBADO')
    DECLARE v_Activo_Actual TINYINT      DEFAULT NULL; -- Estado actual (0 o 1)
    
    /* [B.2] Semáforo Forense (Integrity Flag):
       Variable crítica que almacenará el conteo de conflictos de integridad encontrados.
       Si este valor > 0, significa que hay riesgo operativo y debemos abortar. */
    DECLARE v_Dependencias_Vivas INT DEFAULT 0;

    /* [B.3] Variables de Diagnóstico (Debugging):
       Utilizadas para construir el mensaje de error detallado en caso de bloqueo. */
    DECLARE v_Folio_Curso_Conflicto VARCHAR(50) DEFAULT NULL; -- Para decirle al usuario QUÉ curso estorba.
    DECLARE v_Estado_Curso_Conflicto VARCHAR(255) DEFAULT NULL; -- Para decirle EN QUÉ estado está.

    /* [B.4] Buffer de Mensajería:
       Almacena el texto final que se enviará al cliente. */
    DECLARE v_Mensaje_Final TEXT;
    DECLARE v_Mensaje_Error TEXT;

    /* ============================================================================================
       SECCIÓN C: GESTIÓN DE EXCEPCIONES Y SEGURIDAD (SAFETY NET)
       Configuración de handlers para asegurar una salida limpia ante errores catastróficos.
       ============================================================================================ */
    
    /* [C.1] Handler Genérico (SQLEXCEPTION):
       Captura cualquier error no controlado (Deadlocks, Timeout, Disco Lleno, Sintaxis).
       ACCIÓN:
         1. ROLLBACK: Revertir cualquier cambio parcial.
         2. RESIGNAL: Propagar el error original al backend para que quede en el log del servidor. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ============================================================================================
       SECCIÓN D: VALIDACIONES PREVIAS (FAIL FAST STRATEGY)
       Protegemos la base de datos rechazando peticiones "basura" antes de iniciar la transacción.
       ============================================================================================ */
    
    /* [D.1] Validación de Integridad de Identidad:
       El ID debe ser un número entero positivo. Un ID negativo o nulo es un error de sistema. */
    IF _Id_Estatus IS NULL OR _Id_Estatus <= 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR DE SISTEMA [400]: El ID de Estatus proporcionado es inválido o nulo.';
    END IF;

    /* [D.2] Validación de Dominio Estricta:
       El estatus es un valor binario. SQL permite NULL, pero nuestra lógica de negocio NO.
       Rechazamos explícitamente los Nulos para evitar lógica trivalente peligrosa. */
    IF _Nuevo_Estatus IS NULL OR _Nuevo_Estatus NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' 
-- CAMBIO: Quitamos los guiones bajos para que se lea natural
        SET MESSAGE_TEXT = 'ERROR DE LÓGICA [400]: El campo "Nuevo Estatus" es obligatorio y solo acepta valores binarios: 0 (Inactivo) o 1 (Activo).';
    END IF;

    /* ============================================================================================
       SECCIÓN E: INICIO DE TRANSACCIÓN Y AISLAMIENTO (ACID BEGINS)
       A partir de este punto, entramos en modo "Atomicidad". O todo ocurre, o nada ocurre.
       ============================================================================================ */
    START TRANSACTION;

    /* --------------------------------------------------------------------------------------------
       PASO E.1: ADQUISICIÓN DE SNAPSHOT CON BLOQUEO (PESSIMISTIC LOCK)
       
       [QUÉ HACE]: Ejecuta un `SELECT ... FOR UPDATE`.
       
       [POR QUÉ LO HACEMOS]:
       Necesitamos "congelar" el tiempo para este registro. 
       - Imaginemos que el Admin A intenta desactivar el estatus.
       - Al mismo tiempo, el Admin B intenta cambiarle el nombre a "PENDIENTE URGENTE".
       - Sin bloqueo, podríamos desactivar un estatus que acaba de cambiar de significado.
       
       [EFECTO TÉCNICO]:
       InnoDB coloca un candado exclusivo (X-Lock) en la fila del índice primario.
       Nadie más puede leer (en modo lock) o escribir en esta fila hasta que terminemos.
       -------------------------------------------------------------------------------------------- */
    SELECT `Nombre`, `Activo`
    INTO v_Nombre_Actual, v_Activo_Actual
    FROM `Cat_Estatus_Participante`
    WHERE `Id_CatEstPart` = _Id_Estatus
    LIMIT 1
    FOR UPDATE;

    /* --------------------------------------------------------------------------------------------
       PASO E.2: VALIDACIÓN DE EXISTENCIA (NOT FOUND)
       Si las variables siguen siendo NULL después del SELECT, el registro no existe físicamente.
       -------------------------------------------------------------------------------------------- */
    IF v_Nombre_Actual IS NULL THEN
        ROLLBACK; -- Liberamos recursos del lock inmediatamente.
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [404]: El Estatus solicitado no existe en el catálogo maestro. Pudo haber sido eliminado previamente.';
    END IF;

    /* --------------------------------------------------------------------------------------------
       PASO E.3: VERIFICACIÓN DE IDEMPOTENCIA (OPTIMIZACIÓN)
       
       [LÓGICA]: "Si ya está encendido, no gastes energía en encenderlo de nuevo".
       
       [BENEFICIO CRÍTICO]: 
       1. **Ahorro de I/O:** No se escribe en disco si no es necesario.
       2. **Integridad de Auditoría:** Si hacemos un UPDATE con los mismos valores, MySQL podría
          actualizar el `updated_at` (dependiendo de la config). Queremos evitar falsos positivos
          de modificación.
       -------------------------------------------------------------------------------------------- */
    IF v_Activo_Actual = _Nuevo_Estatus THEN
        
        COMMIT; -- Liberamos el bloqueo. La transacción termina aquí benignamente.
        
        /* Construimos respuesta informativa */
        SELECT CONCAT('AVISO DE SISTEMA: El Estatus "', v_Nombre_Actual, '" ya se encuentra en el estado solicitado (', IF(_Nuevo_Estatus=1,'ACTIVO','INACTIVO'), '). No se requirieron cambios.') AS Mensaje,
               'SIN_CAMBIOS' AS Accion,
               v_Activo_Actual AS Estado_Anterior,
               _Nuevo_Estatus AS Estado_Nuevo;
        
        LEAVE THIS_PROC; -- Salida limpia y temprana del SP.
    END IF;

    /* ============================================================================================
       SECCIÓN F: ANÁLISIS DE IMPACTO Y KILLSWITCH (THE LOGIC CORE)
       Aquí reside la inteligencia del procedimiento. Decidimos si es seguro proceder.
       ============================================================================================ */
    
    /* --------------------------------------------------------------------------------------------
       CASO F.1: PROTOCOLO DE DESACTIVACIÓN (KILLSWITCH / BAJA LÓGICA)
       Condición: `_Nuevo_Estatus = 0` (El usuario quiere APAGAR el estatus).
       
       [RIESGO]: Dejar "ciegos" a los reportes de cursos actuales.
       [DEFENSA]: Integridad Referencial Transitiva.
       -------------------------------------------------------------------------------------------- */
    IF _Nuevo_Estatus = 0 THEN
        
        /* [CONSULTA FORENSE MULTI-NIVEL]:
           Buscamos si existe AL MENOS UN CASO que impida la desactivación.
           
           Navegación de la consulta:
           1. FROM `Capacitaciones_Participantes` CP: 
              -> ¿Hay alumnos con este estatus? (Histórico y Actual).
              
           2. INNER JOIN `DatosCapacitaciones` DC: 
              -> ¿A qué curso específico pertenecen esos alumnos?
              
           3. INNER JOIN `Capacitaciones` C:
              -> Necesario para obtener el Folio (Numero_Capacitacion) para el error.
              
           4. INNER JOIN `Cat_Estatus_Capacitacion` EC:
              -> EL CEREBRO. Consultamos la bandera `Es_Final`.
              
           5. WHERE ...
              -> CP.Fk... = _Id_Estatus: Filtramos por el estatus que queremos borrar.
              -> DC.Activo = 1: El registro histórico del curso es el vigente.
              -> EC.Es_Final = 0: EL CURSO ESTÁ VIVO (No ha finalizado).
        */
        
        SELECT 
            C.Numero_Capacitacion, -- Evidencia 1: El folio del curso culpable
            EC.Nombre              -- Evidencia 2: El estado del curso (ej: "EN CURSO")
        INTO 
            v_Folio_Curso_Conflicto,
            v_Estado_Curso_Conflicto
        FROM `Capacitaciones_Participantes` CP
        
        /* Conexión con el Historial del Curso */
        INNER JOIN `DatosCapacitaciones` DC ON CP.Fk_Id_DatosCap = DC.Id_DatosCap
        
        /* Conexión con la Cabecera del Curso (Para el Folio) */
        INNER JOIN `Capacitaciones` C ON DC.Fk_Id_Capacitacion = C.Id_Capacitacion
        
        /* Conexión con el Catálogo de Estatus del Curso (Para la Lógica de Negocio) */
        INNER JOIN `Cat_Estatus_Capacitacion` EC ON DC.Fk_Id_CatEstCap = EC.Id_CatEstCap
        
        WHERE 
            CP.Fk_Id_CatEstPart = _Id_Estatus  -- Buscamos uso de ESTE estatus
            AND DC.Activo = 1                  -- En cursos que no han sido borrados (Soft Delete)
            AND C.Activo = 1                   -- En cabeceras que no han sido borradas
            
            /* --- EL CANDADO MAESTRO --- */
            AND EC.Es_Final = 0                -- Solo nos importan los cursos OPERATIVOS.
                                               -- Si Es_Final=1 (Finalizado/Cancelado), no bloqueamos.
        
        LIMIT 1; -- Con encontrar UN solo conflicto es suficiente para abortar.

        /* [EVALUACIÓN DEL SEMÁFORO]:
           Si las variables de conflicto se llenaron (IS NOT NULL), tenemos un problema. */
        IF v_Folio_Curso_Conflicto IS NOT NULL THEN
            
            ROLLBACK; -- Cancelación inmediata de la transacción. Seguridad ante todo.
            
            /* Construcción del Mensaje Forense:
               Le explicamos al usuario EXACTAMENTE por qué no puede proceder. */
            SET v_Mensaje_Error = CONCAT(
                'BLOQUEO DE INTEGRIDAD [409]: Operación Denegada. ',
                'No se puede desactivar el estatus "', v_Nombre_Actual, '" ',
                'porque está siendo utilizado activamente por participantes en el curso con Folio "', v_Folio_Curso_Conflicto, '" ',
                'que se encuentra actualmente en estado "', v_Estado_Curso_Conflicto, '". ',
                'Este curso se considera OPERATIVO (No Finalizado). ',
                'Para proceder, debe finalizar el curso o cambiar el estatus de los alumnos involucrados.'
            );
                                   
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = v_Mensaje_Error;
        END IF;
        
        /* Si llegamos aquí, significa que v_Folio_Curso_Conflicto es NULL.
           El estatus puede haber sido usado 1000 veces en el pasado, pero NO se está usando
           en ningún curso vivo hoy. Es seguro proceder. */
    END IF;

    /* --------------------------------------------------------------------------------------------
       CASO F.2: PROTOCOLO DE REACTIVACIÓN (RESURRECTION)
       Condición: `_Nuevo_Estatus = 1` (El usuario quiere PRENDER el estatus).
       
       [ANÁLISIS]:
       Reactivar es seguro. No rompe integridad. Solo vuelve disponible una opción.
       No requiere validaciones adicionales en este diseño.
       -------------------------------------------------------------------------------------------- */
    IF _Nuevo_Estatus = 1 THEN
        -- Pasamos directo a la persistencia.
        SET v_Dependencias_Vivas = 0; 
    END IF;

    /* ============================================================================================
       SECCIÓN G: PERSISTENCIA Y CIERRE (COMMIT PHASE)
       Si el flujo llega a este punto, hemos pasado todas las aduanas de seguridad forense.
       ============================================================================================ */
    
    /* G.1 Ejecución del Cambio de Estado (UPDATE) */
    UPDATE `Cat_Estatus_Participante`
    SET `Activo` = _Nuevo_Estatus,
        `updated_at` = NOW() -- Auditoría: Se marca el momento exacto de la modificación.
    WHERE `Id_CatEstPart` = _Id_Estatus;

    /* G.2 Confirmación de la Transacción */
    COMMIT; -- Los cambios se hacen permanentes y visibles para otros usuarios. Se libera el Lock.

    /* ============================================================================================
       SECCIÓN H: RESPUESTA AL CLIENTE (FEEDBACK LAYER)
       Generamos un mensaje humano que confirme la acción específica realizada.
       ============================================================================================ */
    SELECT 
        CASE 
            WHEN _Nuevo_Estatus = 1 THEN CONCAT('ÉXITO: El Estatus "', v_Nombre_Actual, '" ha sido REACTIVADO y está disponible nuevamente en los selectores operativos.')
            ELSE CONCAT('ÉXITO: El Estatus "', v_Nombre_Actual, '" ha sido DESACTIVADO (Baja Lógica). Se mantendrá en el histórico pero no podrá seleccionarse en nuevos registros.')
        END AS Mensaje,
        'ESTATUS_CAMBIADO' AS Accion,
        v_Activo_Actual AS Estado_Anterior,
        _Nuevo_Estatus AS Estado_Nuevo,
        _Id_Estatus AS Id_Estatus_Participante;

END$$

DELIMITER ;
