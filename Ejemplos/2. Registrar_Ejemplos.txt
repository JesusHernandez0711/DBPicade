
/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarUbicaciones
   ============================================================================================
   OBJETIVO
   --------
   Resolver o registrar una jerarquía completa de ubicaciones:
      País -> Estado -> Municipio
   en una sola operación, pensada para FORMULARIO donde TODO es obligatorio
   (Código y Nombre en los 3 niveles).

   QUÉ HACE (CONTRATO DE NEGOCIO)
   ------------------------------
   Para cada nivel (País, Estado, Municipio) este SP aplica la MISMA regla:

   1) Busca primero por CÓDIGO (regla principal) dentro de su “padre” cuando aplica.
      - Si existe: valida que el NOMBRE coincida.
      - Si no coincide: ERROR controlado (conflicto Código <-> Nombre).

   2) Si no existe por CÓDIGO, busca por NOMBRE dentro de su “padre” cuando aplica.
      - Si existe: valida que el CÓDIGO coincida.
      - Si no coincide: ERROR controlado (conflicto Nombre <-> Código).

   3) Si NO existe por CÓDIGO ni por NOMBRE:
      - Crea el registro (INSERT).

   4) Si existe y está Activo = 0:
      - Reactiva (UPDATE Activo=1).

   ACCIONES DEVUELTAS
   ------------------
   El SP devuelve una acción por nivel:
      Accion_Pais      = 'CREADA' | 'REUSADA' | 'REACTIVADA'
      Accion_Estado    = 'CREADA' | 'REUSADA' | 'REACTIVADA'
      Accion_Municipio = 'CREADA' | 'REUSADA' | 'REACTIVADA'

   - 'CREADA'      => se insertó un nuevo registro.
   - 'REUSADA'     => ya existía activa y se reutilizó (no se insertó).
   - 'REACTIVADA'  => ya existía pero estaba inactiva, se reactivó y se reutilizó.

   SEGURIDAD / INTEGRIDAD
   ----------------------
   - Usa TRANSACTION: si algo falla, ROLLBACK y RESIGNAL (no quedan datos a medias).
   - Resolución determinística (nada de "OR ... LIMIT 1").
   - Blindaje ante concurrencia/doble-submit:
       * Los SELECT de búsqueda usan FOR UPDATE para serializar la lectura cuando hay fila.
       * Las constraints UNIQUE (Código+FK, Nombre+FK) son el candado final contra duplicados.

   RESULTADO
   ---------
   Retorna:
   - Id_Pais, Id_Estado, Id_Municipio
   - Accion_* por cada nivel
   - Id_Nuevo_Pais       SOLO si Accion_Pais='CREADA', si no NULL
   - Id_Nuevo_Estado     SOLO si Accion_Estado='CREADA', si no NULL
   - Id_Nuevo_Municipio  SOLO si Accion_Municipio='CREADA', si no NULL
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_RegistrarUbicaciones$$
CREATE PROCEDURE SP_RegistrarUbicaciones(
    IN _Codigo_Municipio VARCHAR(50),   /* Código del Municipio (OBLIGATORIO en formulario) */
    IN _Nombre_Municipio VARCHAR(255),  /* Nombre del Municipio (OBLIGATORIO) */
    IN _Codigo_Estado    VARCHAR(50),   /* Código del Estado (OBLIGATORIO) */
    IN _Nombre_Estado    VARCHAR(255),  /* Nombre del Estado (OBLIGATORIO) */
    IN _Codigo_Pais      VARCHAR(50),   /* Código del País (OBLIGATORIO) */
    IN _Nombre_Pais      VARCHAR(255)   /* Nombre del País (OBLIGATORIO) */
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES INTERNAS
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Id_Pais      INT DEFAULT NULL;
    DECLARE v_Id_Estado    INT DEFAULT NULL;
    DECLARE v_Id_Municipio INT DEFAULT NULL;

    /* Buffers para validación cruzada cuando el registro ya existe */
    DECLARE v_Codigo VARCHAR(50);
    DECLARE v_Nombre VARCHAR(255);
    DECLARE v_Activo TINYINT(1);

    /* Acciones por nivel */
    DECLARE v_Accion_Pais      VARCHAR(20) DEFAULT NULL;
    DECLARE v_Accion_Estado    VARCHAR(20) DEFAULT NULL;
    DECLARE v_Accion_Municipio VARCHAR(20) DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       MANEJO DE ERRORES
    ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR 1062
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Registro Duplicado por concurrencia o restricción UNIQUE. Refresca y reintenta; si ya existe se reutilizará/reactivará.';
    END;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN BÁSICA
    ---------------------------------------------------------------------------------------- */
    SET _Codigo_Pais      = NULLIF(TRIM(_Codigo_Pais), '');
    SET _Nombre_Pais      = NULLIF(TRIM(_Nombre_Pais), '');
    SET _Codigo_Estado    = NULLIF(TRIM(_Codigo_Estado), '');
    SET _Nombre_Estado    = NULLIF(TRIM(_Nombre_Estado), '');
    SET _Codigo_Municipio = NULLIF(TRIM(_Codigo_Municipio), '');
    SET _Nombre_Municipio = NULLIF(TRIM(_Nombre_Municipio), '');

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE NEGOCIO (FORMULARIO: TODO OBLIGATORIO)
    ---------------------------------------------------------------------------------------- */
    IF _Codigo_Pais IS NULL OR _Nombre_Pais IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: País incompleto (Código y Nombre obligatorios).';
    END IF;

    IF _Codigo_Estado IS NULL OR _Nombre_Estado IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Estado incompleto (Código y Nombre obligatorios).';
    END IF;

    IF _Codigo_Municipio IS NULL OR _Nombre_Municipio IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Municipio incompleto (Código y Nombre obligatorios).';
    END IF;

    /* ----------------------------------------------------------------------------------------
       INICIO TRANSACCIÓN
    ---------------------------------------------------------------------------------------- */
    START TRANSACTION;

    /* ========================================================================================
       1) RESOLVER / CREAR PAÍS
       ======================================================================================== */

    /* 1A) Buscar por CÓDIGO */
    SET v_Id_Pais = NULL;
    SELECT Id_Pais, Codigo, Nombre, Activo
      INTO v_Id_Pais, v_Codigo, v_Nombre, v_Activo
    FROM Pais
    WHERE Codigo = _Codigo_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Pais IS NOT NULL THEN
        IF v_Nombre <> _Nombre_Pais THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto País. El Código existe pero el Nombre no coincide.';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Pais
            SET Activo = 1, updated_at = NOW()
            WHERE Id_Pais = v_Id_Pais;
            SET v_Accion_Pais = 'REACTIVADA';
        ELSE
            SET v_Accion_Pais = 'REUSADA';
        END IF;

    ELSE
        /* 1B) Buscar por NOMBRE */
        SELECT Id_Pais, Codigo, Nombre, Activo
          INTO v_Id_Pais, v_Codigo, v_Nombre, v_Activo
        FROM Pais
        WHERE Nombre = _Nombre_Pais
        LIMIT 1
        FOR UPDATE;

        IF v_Id_Pais IS NOT NULL THEN
            IF v_Codigo <> _Codigo_Pais THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'ERROR: Conflicto País. El Nombre existe pero el Código no coincide.';
            END IF;

            IF v_Activo = 0 THEN
                UPDATE Pais
                SET Activo = 1, updated_at = NOW()
                WHERE Id_Pais = v_Id_Pais;
                SET v_Accion_Pais = 'REACTIVADA';
            ELSE
                SET v_Accion_Pais = 'REUSADA';
            END IF;

        ELSE
            /* 1C) Crear */
            INSERT INTO Pais (Codigo, Nombre)
            VALUES (_Codigo_Pais, _Nombre_Pais);

            SET v_Id_Pais = LAST_INSERT_ID();
            SET v_Accion_Pais = 'CREADA';
        END IF;
    END IF;

    /* ========================================================================================
       2) RESOLVER / CREAR ESTADO (dentro del País resuelto)
       ======================================================================================== */

    /* 2A) Buscar por CÓDIGO dentro del país */
    SET v_Id_Estado = NULL;
    SELECT Id_Estado, Codigo, Nombre, Activo
      INTO v_Id_Estado, v_Codigo, v_Nombre, v_Activo
    FROM Estado
    WHERE Codigo = _Codigo_Estado
      AND Fk_Id_Pais = v_Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Estado IS NOT NULL THEN
        IF v_Nombre <> _Nombre_Estado THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Estado. El Código existe pero el Nombre no coincide (en ese País).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Estado
            SET Activo = 1, updated_at = NOW()
            WHERE Id_Estado = v_Id_Estado;
            SET v_Accion_Estado = 'REACTIVADA';
        ELSE
            SET v_Accion_Estado = 'REUSADA';
        END IF;

    ELSE
        /* 2B) Buscar por NOMBRE dentro del país */
        SELECT Id_Estado, Codigo, Nombre, Activo
          INTO v_Id_Estado, v_Codigo, v_Nombre, v_Activo
        FROM Estado
        WHERE Nombre = _Nombre_Estado
          AND Fk_Id_Pais = v_Id_Pais
        LIMIT 1
        FOR UPDATE;

        IF v_Id_Estado IS NOT NULL THEN
            IF v_Codigo <> _Codigo_Estado THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'ERROR: Conflicto Estado. El Nombre existe pero el Código no coincide (en ese País).';
            END IF;

            IF v_Activo = 0 THEN
                UPDATE Estado
                SET Activo = 1, updated_at = NOW()
                WHERE Id_Estado = v_Id_Estado;
                SET v_Accion_Estado = 'REACTIVADA';
            ELSE
                SET v_Accion_Estado = 'REUSADA';
            END IF;

        ELSE
            /* 2C) Crear */
            INSERT INTO Estado (Codigo, Nombre, Fk_Id_Pais)
            VALUES (_Codigo_Estado, _Nombre_Estado, v_Id_Pais);

            SET v_Id_Estado = LAST_INSERT_ID();
            SET v_Accion_Estado = 'CREADA';
        END IF;
    END IF;

    /* ========================================================================================
       3) RESOLVER / CREAR MUNICIPIO (dentro del Estado resuelto)
       ======================================================================================== */

    /* 3A) Buscar por CÓDIGO dentro del estado */
    SET v_Id_Municipio = NULL;
    SELECT Id_Municipio, Codigo, Nombre, Activo
      INTO v_Id_Municipio, v_Codigo, v_Nombre, v_Activo
    FROM Municipio
    WHERE Codigo = _Codigo_Municipio
      AND Fk_Id_Estado = v_Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Municipio IS NOT NULL THEN
        IF v_Nombre <> _Nombre_Municipio THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Municipio. El Código existe pero el Nombre no coincide (en ese Estado).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Municipio
            SET Activo = 1, updated_at = NOW()
            WHERE Id_Municipio = v_Id_Municipio;
            SET v_Accion_Municipio = 'REACTIVADA';
        ELSE
            SET v_Accion_Municipio = 'REUSADA';
        END IF;

    ELSE
        /* 3B) Buscar por NOMBRE dentro del estado */
        SELECT Id_Municipio, Codigo, Nombre, Activo
          INTO v_Id_Municipio, v_Codigo, v_Nombre, v_Activo
        FROM Municipio
        WHERE Nombre = _Nombre_Municipio
          AND Fk_Id_Estado = v_Id_Estado
        LIMIT 1
        FOR UPDATE;

        IF v_Id_Municipio IS NOT NULL THEN
            IF v_Codigo <> _Codigo_Municipio THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'ERROR: Conflicto Municipio. El Nombre existe pero el Código no coincide (en ese Estado).';
            END IF;

            IF v_Activo = 0 THEN
                UPDATE Municipio
                SET Activo = 1, updated_at = NOW()
                WHERE Id_Municipio = v_Id_Municipio;
                SET v_Accion_Municipio = 'REACTIVADA';
            ELSE
                SET v_Accion_Municipio = 'REUSADA';
            END IF;

        ELSE
            /* 3C) Crear */
            INSERT INTO Municipio (Codigo, Nombre, Fk_Id_Estado)
            VALUES (_Codigo_Municipio, _Nombre_Municipio, v_Id_Estado);

            SET v_Id_Municipio = LAST_INSERT_ID();
            SET v_Accion_Municipio = 'CREADA';
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       CONFIRMAR TRANSACCIÓN Y RESPUESTA
    ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT
        'Registro Exitoso' AS Mensaje,

        v_Id_Pais      AS Id_Pais,
        v_Id_Estado    AS Id_Estado,
        v_Id_Municipio AS Id_Municipio,

        v_Accion_Pais      AS Accion_Pais,
        v_Accion_Estado    AS Accion_Estado,
        v_Accion_Municipio AS Accion_Municipio,

        CASE 
			WHEN v_Accion_Pais = 'CREADA' THEN v_Id_Pais 
			ELSE NULL 
		END AS Id_Nuevo_Pais,
        CASE 
			WHEN v_Accion_Estado = 'CREADA' THEN v_Id_Estado 
            ELSE NULL 
		END AS Id_Nuevo_Estado,
        CASE 
			WHEN v_Accion_Municipio = 'CREADA' THEN v_Id_Municipio 
            ELSE NULL 
		END AS Id_Nuevo_Municipio;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarPais  (VERSIÓN PRO: 1062 => RE-RESOLVE)
   ============================================================================================
   OBJETIVO
   --------
   Registrar un País (Codigo + Nombre) con blindaje fuerte contra duplicados y carreras
   (concurrencia), devolviendo una respuesta “limpia” para el frontend:

   - Si el País NO existe -> INSERT -> Accion = 'CREADA'
   - Si el País existe pero Activo=0 -> UPDATE Activo=1 -> Accion = 'REACTIVADA'
   - Si el País ya existía (por doble submit / carrera) -> NO error -> Accion='REUSADA'
   - Si hay conflicto real (mismo código con otro nombre, o viceversa) -> ERROR controlado.

   ¿CUÁNDO SE USA?
   --------------
   - Formulario "Alta de País" (catálogo).
   - Casos típicos de concurrencia:
       * El usuario da doble clic a “Guardar”
       * La red está lenta y re-envía
       * Dos usuarios registran lo mismo casi al mismo tiempo

   REGLAS DE NEGOCIO (CONTRATO)
   ---------------------------
   Reglas determinísticas (SIN “OR ... LIMIT 1” ambiguo):

   1) Primero se resuelve por CÓDIGO (regla principal):
      - Si existe:
          a) Si NOMBRE no coincide -> ERROR (conflicto)
          b) Si Activo=0 -> REACTIVA (UPDATE Activo=1)
          c) Si Activo=1 -> ERROR (duplicado real, no es “carrera”)
      - Si no existe -> continúa

   2) Si no existe por CÓDIGO, se resuelve por NOMBRE:
      - Si existe:
          a) Si CÓDIGO no coincide -> ERROR (conflicto)
          b) Si Activo=0 -> REACTIVA
          c) Si Activo=1 -> ERROR (duplicado real)
      - Si no existe -> continúa

   3) Si NO existe por CÓDIGO ni por NOMBRE:
      - INTENTA INSERT.
      - Aquí es donde puede ocurrir la carrera (1062) si alguien insertó “en el mismo instante”.

   CONCURRENCIA (POR QUÉ EXISTE EL RE-RESOLVE)
   ------------------------------------------
   Importante: `SELECT ... FOR UPDATE` solo bloquea SI EXISTE una fila.
   Si NO hay fila (aún no existe el País), no hay nada que bloquear.
   Entonces, dos transacciones pueden llegar al `INSERT` al mismo tiempo:

     Tx A: no encuentra fila -> INSERT -> OK
     Tx B: no encuentra fila -> INSERT -> 1062 (UNIQUE lo frena)

   En la versión simple, Tx B regresaría error.
   En esta versión PRO, Tx B:
     - Detecta 1062 (bandera v_Dup=1)
     - Hace ROLLBACK
     - Re-consulta el registro ya creado
     - Devuelve REUSADA (o REACTIVADA si estaba inactivo)

   SEGURIDAD / INTEGRIDAD
   ----------------------
   - UNIQUE en tabla sigue siendo la última línea de defensa:
       Pais.Codigo UNIQUE
       Pais.Nombre UNIQUE
   - TRANSACTION + HANDLERS:
       * 1062 => NO aborta inmediato, marca bandera y permite “re-resolver”
       * Cualquier otro error => ROLLBACK y RESIGNAL (error real)
   - SELECT ... FOR UPDATE:
       * Serializa cuando la fila ya existe (evita cambios concurrentes inconsistentes)
       * Permite reactivar de forma segura

   RESULTADO
   ---------
   Retorna:
     - Mensaje (texto para UX)
     - Id_Pais
     - Accion: 'CREADA' | 'REACTIVADA' | 'REUSADA'

============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_RegistrarPais$$
CREATE PROCEDURE SP_RegistrarPais(
    IN _Codigo VARCHAR(50),
    IN _Nombre VARCHAR(255)
)
SP: BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES DE TRABAJO
       - v_* guardan el registro encontrado (si existe).
       - v_Dup es una BANDERA para detectar que ocurrió 1062 durante el INSERT.
         (OJO: al ser CONTINUE HANDLER, si no revisas v_Dup, te puedes ir a COMMIT sin insertar.)
    ---------------------------------------------------------------------------------------- */
    DECLARE v_Id_Pais INT DEFAULT NULL;
    DECLARE v_Codigo  VARCHAR(50) DEFAULT NULL;
    DECLARE v_Nombre  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Activo  TINYINT(1) DEFAULT NULL;

    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ----------------------------------------------------------------------------------------
       HANDLERS
       - 1062 (Duplicate entry): no aborta de golpe; solo marca bandera.
         Esto es CLAVE para poder hacer "re-resolve" sin mostrar error al usuario.
       - SQLEXCEPTION: cualquier otro error sí aborta (rollback + resignal).
    ---------------------------------------------------------------------------------------- */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN DE INPUTS
       - TRIM: evita que "MEX " y "MEX" se comporten como cosas diferentes
       - NULLIF: convierte '' en NULL para validar obligatorios de forma limpia
    ---------------------------------------------------------------------------------------- */
    SET _Codigo = NULLIF(TRIM(_Codigo), '');
    SET _Nombre = NULLIF(TRIM(_Nombre), '');

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES BÁSICAS
    ---------------------------------------------------------------------------------------- */
    IF _Codigo IS NULL OR _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Código y Nombre del País son obligatorios.';
    END IF;

    /* ========================================================================================
       TRANSACCIÓN PRINCIPAL (INTENTO NORMAL)
       - Aquí resolvemos por CÓDIGO -> por NOMBRE -> INSERT
    ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1: BUSCAR POR CÓDIGO (REGLA PRINCIPAL)
       - FOR UPDATE:
         Si la fila existe, la bloquea para evitar carreras en reactivación/cambios simultáneos.
       - Limpieza de variables:
         Evita que queden valores viejos si el SELECT no retorna fila.
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Pais = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Pais, Codigo, Nombre, Activo
      INTO v_Id_Pais, v_Codigo, v_Nombre, v_Activo
    FROM Pais
    WHERE Codigo = _Codigo
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Pais IS NOT NULL THEN
        /* Conflicto fuerte: mismo código pero otro nombre => datos inconsistentes */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto País. El Código ya existe pero el Nombre no coincide.';
        END IF;

        /* Si existe pero está inactivo => reactivación segura (borrado lógico) */
        IF v_Activo = 0 THEN
            UPDATE Pais
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Pais = v_Id_Pais;

            COMMIT;
            SELECT 'País reactivado exitosamente' AS Mensaje,
                   v_Id_Pais AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Si existe y está activo => duplicado REAL (no es concurrencia) */
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe un País ACTIVO con ese Código.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2: BUSCAR POR NOMBRE (REGLA SECUNDARIA)
       - Misma lógica que el código, pero al revés.
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Pais = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Pais, Codigo, Nombre, Activo
      INTO v_Id_Pais, v_Codigo, v_Nombre, v_Activo
    FROM Pais
    WHERE Nombre = _Nombre
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Pais IS NOT NULL THEN
        /* Conflicto fuerte: mismo nombre pero otro código => datos inconsistentes */
        IF v_Codigo <> _Codigo THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto País. El Nombre ya existe pero el Código no coincide.';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Pais
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Pais = v_Id_Pais;

            COMMIT;
            SELECT 'País reactivado exitosamente' AS Mensaje,
                   v_Id_Pais AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe un País ACTIVO con ese Nombre.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3: INSERT (CREACIÓN REAL)
       - Este es el único punto donde la concurrencia puede provocar 1062:
         porque NO había fila para bloquear con FOR UPDATE.
       - v_Dup se reinicia antes del INSERT para que sea confiable.
    ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    INSERT INTO Pais (Codigo, Nombre)
    VALUES (_Codigo, _Nombre);

    /* Si NO hubo 1062, v_Dup sigue en 0 => Insert exitoso */
    IF v_Dup = 0 THEN
        COMMIT;
        SELECT 'País registrado exitosamente' AS Mensaje,
               LAST_INSERT_ID() AS Id_Pais,
               'CREADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ========================================================================================
       SI LLEGAMOS AQUÍ:
       - v_Dup = 1 => el INSERT falló con 1062
       - Eso significa: “alguien ya insertó antes” (carrera/doble-submit)
       => RE-RESOLVE: localizar el registro y devolverlo como REUSADA/REACTIVADA
    ======================================================================================== */

    /* IMPORTANTE: revertimos el intento para salir “limpios” y sin locks */
    ROLLBACK;

    /* ----------------------------------------------------------------------------------------
       TRANSACCIÓN DE RE-RESOLVE
       - Nueva transacción para:
         1) Evitar quedarnos con locks/estado del intento anterior
         2) Poder usar FOR UPDATE sobre la fila real encontrada
    ---------------------------------------------------------------------------------------- */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE A) Localizar por CÓDIGO
       - Si aparece: validamos coherencia con el Nombre solicitado.
       - Si está inactivo: lo reactivamos y devolvemos REACTIVADA.
       - Si está activo: devolvemos REUSADA (UX limpia).
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Pais = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Pais, Codigo, Nombre, Activo
      INTO v_Id_Pais, v_Codigo, v_Nombre, v_Activo
    FROM Pais
    WHERE Codigo = _Codigo
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Pais IS NOT NULL THEN
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Código existe con otro Nombre.';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Pais
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Pais = v_Id_Pais;

            COMMIT;
            SELECT 'País reactivado (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Pais AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'País ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Pais AS Id_Pais,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE B) Si no apareció por código (muy raro), buscamos por NOMBRE
       - Misma lógica, pero validando coherencia del Código.
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Pais = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Pais, Codigo, Nombre, Activo
      INTO v_Id_Pais, v_Codigo, v_Nombre, v_Activo
    FROM Pais
    WHERE Nombre = _Nombre
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Pais IS NOT NULL THEN
        IF v_Codigo <> _Codigo THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Nombre existe con otro Código.';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Pais
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Pais = v_Id_Pais;

            COMMIT;
            SELECT 'País reactivado (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Pais AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'País ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Pais AS Id_Pais,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE C) Caso extremadamente raro
       - Hubo 1062 pero no localizamos la fila.
       - En InnoDB normal esto “no debería pasar”.
       - Devolvemos error controlado para que el frontend reintente.
    ---------------------------------------------------------------------------------------- */
    SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada (1062) pero no se pudo localizar el registro. Reintenta.';

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarEstado  (VERSIÓN PRO: 1062 => RE-RESOLVE)
   ============================================================================================
   OBJETIVO
   --------
   Registrar un nuevo Estado dentro de un País específico (seleccionado por dropdown),
   con blindaje fuerte contra duplicados y con manejo PRO de concurrencia (doble submit).

   ¿CUÁNDO SE USA?
   --------------
   - Formulario “Alta de Estado”
   - El usuario captura:
        * Codigo (ej: 'TAB')
        * Nombre (ej: 'TABASCO')
     y selecciona un País ACTIVO del dropdown:
        * _Fk_Id_Pais (Id_Pais)

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   En el País _Fk_Id_Pais se aplica la MISMA regla determinística que ya estás usando:

   1) Buscar primero por CÓDIGO dentro del País (regla principal).
      - Si existe:
          a) El NOMBRE debe coincidir, si no => ERROR (conflicto Código <-> Nombre).
          b) Si Activo=0 => REACTIVAR (UPDATE Activo=1) y devolver 'REACTIVADA'.
          c) Si Activo=1 => ERROR (ya existe activo).

   2) Si no existe por CÓDIGO, buscar por NOMBRE dentro del País.
      - Si existe:
          a) El CÓDIGO debe coincidir, si no => ERROR (conflicto Nombre <-> Código).
          b) Si Activo=0 => REACTIVAR y devolver 'REACTIVADA'.
          c) Si Activo=1 => ERROR (ya existe activo).

   3) Si no existe por ninguno => INSERT y devolver 'CREADA'.

   CONCURRENCIA (EL PROBLEMA REAL)
   -------------------------------
   Caso típico:
   - Usuario A y Usuario B intentan registrar el mismo Estado (mismo Codigo o mismo Nombre)
     en el MISMO País casi al mismo tiempo.
   - Los SELECT ... FOR UPDATE NO bloquean nada si “no hay fila todavía”.
   - Ambos intentan INSERT.
   - Uno gana y el otro pierde con error 1062 (violación de UNIQUE).

   SOLUCIÓN PRO: 1062 => “RE-RESOLVE”
   ---------------------------------
   En vez de devolver un error feo al segundo:
   - Detectamos el 1062 (handler).
   - Hacemos ROLLBACK del intento.
   - Abrimos una nueva transacción y “localizamos” el registro ganador.
   - Devolvemos:
        Accion='REUSADA'  (ya existía y se reutiliza)
     o Accion='REACTIVADA' (si estaba inactivo y se reactivó).

   IMPORTANTE: ¿POR QUÉ SE RESETEAN VARIABLES A NULL ANTES DE CADA SELECT INTO?
   ----------------------------------------------------------------------------
   En MySQL, si un SELECT ... INTO no encuentra filas:
   - NO asigna nada (las variables se quedan con el valor anterior).
   Por eso SIEMPRE hacemos:
      SET v_Id_Estado = NULL; ...
   antes del SELECT, para que “no encontrado” sea detectable como NULL.

   SEGURIDAD / INTEGRIDAD (TU ESQUEMA)
   -----------------------------------
   - Pais tiene Activo (dropdown debe ser solo activos).
   - Estado tiene UNIQUE compuestos:
        Uk_Estado_Codigo_Pais UNIQUE (Codigo, Fk_Id_Pais)
        Uk_Estado_Nombre_Pais UNIQUE (Nombre, Fk_Id_Pais)
   - TRANSACTION + SELECT ... FOR UPDATE:
        * Si la fila existe => la bloquea y serializa.
        * Si no existe => el candado final es el UNIQUE (y ahí entra el 1062).

   RESULTADO
   ---------
   Retorna:
     - Mensaje
     - Id_Estado
     - Id_Pais
     - Accion: 'CREADA' | 'REACTIVADA' | 'REUSADA'
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_RegistrarEstado$$
CREATE PROCEDURE SP_RegistrarEstado(
    IN _Codigo      VARCHAR(50),
    IN _Nombre      VARCHAR(255),
    IN _Fk_Id_Pais   INT
)
SP: BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES DE TRABAJO (resultado de búsquedas)
    ---------------------------------------------------------------------------------------- */
    DECLARE v_Id_Estado INT DEFAULT NULL;
    DECLARE v_Codigo    VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre    VARCHAR(255) DEFAULT NULL;
    DECLARE v_Activo    TINYINT(1)   DEFAULT NULL;

    /* Variables para validar País padre con lock */
    DECLARE v_Pais_Existe INT DEFAULT NULL;
    DECLARE v_Pais_Activo TINYINT(1) DEFAULT NULL;

    /* Bandera de duplicado por concurrencia (error 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ----------------------------------------------------------------------------------------
       HANDLERS
       - 1062: NO salimos del SP. Marcamos bandera y el flujo continúa.
       - SQLEXCEPTION: cualquier error distinto => rollback y relanzar.
    ---------------------------------------------------------------------------------------- */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN (evita duplicados por espacios o strings vacíos)
    ---------------------------------------------------------------------------------------- */
    SET _Codigo = NULLIF(TRIM(_Codigo), '');
    SET _Nombre = NULLIF(TRIM(_Nombre), '');

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES BÁSICAS (rápidas, antes de tocar datos)
    ---------------------------------------------------------------------------------------- */
    IF _Fk_Id_Pais IS NULL OR _Fk_Id_Pais <= 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Id_Pais inválido (dropdown).';
    END IF;

    IF _Codigo IS NULL OR _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Código y Nombre del Estado son obligatorios.';
    END IF;

    /* ========================================================================================
       TRANSACCIÓN PRINCIPAL (INTENTO NORMAL)
    ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 0) BLOQUEAR Y VALIDAR PAÍS PADRE
       - Esto evita carreras raras donde:
           * alguien desactiva el País mientras tú estás registrando un Estado
       - Como tu UI lista solo activos, normalmente siempre pasa.
       - Aun así, se blinda el sistema ante requests manipuladas.
    ---------------------------------------------------------------------------------------- */
    SET v_Pais_Existe = NULL; SET v_Pais_Activo = NULL;

    SELECT 1, Activo
      INTO v_Pais_Existe, v_Pais_Activo
    FROM Pais
    WHERE Id_Pais = _Fk_Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Pais_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El País no existe.';
    END IF;

    IF v_Pais_Activo <> 1 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El País está inactivo. No puedes registrar Estados ahí.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 1) BUSCAR POR CÓDIGO DENTRO DEL PAÍS (REGLA PRINCIPAL)
       - Si existe, se bloquea la fila Estado (FOR UPDATE).
       - Si no existe, NO hay lock (y por eso 1062 puede ocurrir en el INSERT).
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Estado = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Estado, Codigo, Nombre, Activo
      INTO v_Id_Estado, v_Codigo, v_Nombre, v_Activo
    FROM Estado
    WHERE Codigo = _Codigo
      AND Fk_Id_Pais = _Fk_Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Estado IS NOT NULL THEN
        /* Conflicto: mismo Código pero distinto Nombre => datos inconsistentes */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Estado. El Código ya existe pero el Nombre no coincide (en ese País).';
        END IF;

        /* Existe pero estaba inactivo => se reactiva */
        IF v_Activo = 0 THEN
            UPDATE Estado
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Estado = v_Id_Estado;

            COMMIT;
            SELECT 'Estado reactivado exitosamente' AS Mensaje,
                   v_Id_Estado AS Id_Estado,
                   _Fk_Id_Pais AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Existe y está activo => no se permite alta */
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe un Estado ACTIVO con ese Código en el País seleccionado.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) BUSCAR POR NOMBRE DENTRO DEL PAÍS (SEGUNDA REGLA)
       - Si existe por Nombre, el Código debe coincidir.
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Estado = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Estado, Codigo, Nombre, Activo
      INTO v_Id_Estado, v_Codigo, v_Nombre, v_Activo
    FROM Estado
    WHERE Nombre = _Nombre
      AND Fk_Id_Pais = _Fk_Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Estado IS NOT NULL THEN
        /* Conflicto: mismo Nombre pero distinto Código => datos inconsistentes */
        IF v_Codigo <> _Codigo THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Estado. El Nombre ya existe pero el Código no coincide (en ese País).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Estado
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Estado = v_Id_Estado;

            COMMIT;
            SELECT 'Estado reactivado exitosamente' AS Mensaje,
                   v_Id_Estado AS Id_Estado,
                   _Fk_Id_Pais AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe un Estado ACTIVO con ese Nombre en el País seleccionado.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) INSERT FINAL
       - Aquí es donde puede aparecer el 1062 por carrera.
       - v_Dup se reinicia antes del INSERT.
    ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    INSERT INTO Estado (Codigo, Nombre, Fk_Id_Pais)
    VALUES (_Codigo, _Nombre, _Fk_Id_Pais);

    /* Si el INSERT NO disparó 1062, todo bien => CREADA */
    IF v_Dup = 0 THEN
        COMMIT;
        SELECT 'Estado registrado exitosamente' AS Mensaje,
               LAST_INSERT_ID() AS Id_Estado,
               _Fk_Id_Pais AS Id_Pais,
               'CREADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ========================================================================================
       SI LLEGAMOS AQUÍ: HUBO 1062 EN EL INSERT
       => ALGUIEN INSERTÓ PRIMERO (CONCURRENCIA / DOBLE SUBMIT)
       => RE-RESOLVE: localizar y devolver REUSADA/REACTIVADA (UX limpia)
    ======================================================================================== */
    ROLLBACK;

    /* Segunda transacción limpia:
       - no arrastrar locks del intento fallido
       - bloquear la fila real con FOR UPDATE si toca reactivar */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE A) Localizar por CÓDIGO dentro del País (más determinístico por UNIQUE)
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Estado = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Estado, Codigo, Nombre, Activo
      INTO v_Id_Estado, v_Codigo, v_Nombre, v_Activo
    FROM Estado
    WHERE Codigo = _Codigo
      AND Fk_Id_Pais = _Fk_Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Estado IS NOT NULL THEN
        /* Si el “ganador” tiene otro Nombre => conflicto real (no es el mismo registro lógico) */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Código existe con otro Nombre (en ese País).';
        END IF;

        /* Si por alguna razón estaba inactivo => reactivar */
        IF v_Activo = 0 THEN
            UPDATE Estado
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Estado = v_Id_Estado;

            COMMIT;
            SELECT 'Estado reactivado (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Estado AS Id_Estado,
                   _Fk_Id_Pais AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Ya existe activo => REUSADA (sin error al usuario) */
        COMMIT;
        SELECT 'Estado ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Estado AS Id_Estado,
               _Fk_Id_Pais AS Id_Pais,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE B) Si no aparece por Código (raro), buscar por NOMBRE dentro del País
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Estado = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Estado, Codigo, Nombre, Activo
      INTO v_Id_Estado, v_Codigo, v_Nombre, v_Activo
    FROM Estado
    WHERE Nombre = _Nombre
      AND Fk_Id_Pais = _Fk_Id_Pais
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Estado IS NOT NULL THEN
        IF v_Codigo <> _Codigo THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Nombre existe con otro Código (en ese País).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Estado
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Estado = v_Id_Estado;

            COMMIT;
            SELECT 'Estado reactivado (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Estado AS Id_Estado,
                   _Fk_Id_Pais AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'Estado ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Estado AS Id_Estado,
               _Fk_Id_Pais AS Id_Pais,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* Caso ultra raro: 1062 ocurrió pero no encontramos el registro */
    SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada (1062) pero no se pudo localizar el Estado. Refresca y reintenta.';

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarMunicipio  (VERSIÓN PRO: 1062 => RE-RESOLVE)
   ============================================================================================
   OBJETIVO
   --------
   Registrar un nuevo Municipio dentro de un Estado específico (seleccionado por dropdown),
   con blindaje fuerte contra duplicados y con manejo PRO de concurrencia (doble-submit).

   ¿CUÁNDO SE USA?
   --------------
   - Formulario “Alta de Municipio”
   - El usuario captura:
        * _Codigo  (ej: '001')
        * _Nombre  (ej: 'CENTRO')
     y selecciona por dropdown:
        * _Id_Pais_Seleccionado  (solo países ACTIVO=1, usado para filtrar estados)
        * _Id_Estado             (solo estados ACTIVO=1 que pertenecen a ese país)

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   Dentro del Estado _Id_Estado se aplica la misma regla determinística:

   1) Buscar primero por CÓDIGO dentro del Estado (regla principal).
      - Si existe:
          a) El NOMBRE debe coincidir, si no => ERROR (conflicto Código <-> Nombre).
          b) Si Activo=0 => REACTIVAR (UPDATE Activo=1) y devolver 'REACTIVADA'.
          c) Si Activo=1 => ERROR (ya existe activo).

   2) Si no existe por CÓDIGO, buscar por NOMBRE dentro del Estado.
      - Si existe:
          a) El CÓDIGO debe coincidir, si no => ERROR (conflicto Nombre <-> Código).
          b) Si Activo=0 => REACTIVAR y devolver 'REACTIVADA'.
          c) Si Activo=1 => ERROR (ya existe activo).

   3) Si no existe por ninguno => INSERT y devolver 'CREADA'.

   VALIDACIÓN JERÁRQUICA (PAÍS -> ESTADO)
   --------------------------------------
   Aunque el frontend use dropdowns (y “debería” mandar combos válidos), este SP valida:
   - El País existe y está ACTIVO
   - El Estado existe, está ACTIVO y pertenece a ese País
   Esto blinda el backend ante:
   - Requests manipuladas
   - Bugs del frontend
   - Datos “viejos” en cache del navegador (usuario deja la pantalla abierta y cambia catálogo)

   CONCURRENCIA (EL PROBLEMA REAL)
   -------------------------------
   - SELECT ... FOR UPDATE solo bloquea si la fila existe.
   - Si el municipio no existe todavía:
       * Dos usuarios pueden pasar los SELECT sin bloquear nada
       * Ambos intentan INSERT
       * Uno gana, el otro cae en 1062 (por UNIQUE)
   Tu tabla Municipio tiene UNIQUE:
     - Uk_Municipio_Codigo_Estado UNIQUE (Codigo, Fk_Id_Estado)
     - Uk_Municipio_Estado        UNIQUE (Nombre, Fk_Id_Estado)

   SOLUCIÓN PRO: 1062 => “RE-RESOLVE”
   ---------------------------------
   En vez de mostrar error al segundo:
   - Detectamos 1062 (handler)
   - ROLLBACK del intento
   - Nueva transacción
   - Localizamos el registro “ganador”
   - Devolvemos:
        Accion='REUSADA' (ya existía activa)
     o Accion='REACTIVADA' (si estaba inactivo)

   IMPORTANTE: ¿POR QUÉ SE RESETEAN VARIABLES A NULL ANTES DE CADA SELECT INTO?
   ----------------------------------------------------------------------------
   En MySQL, si un SELECT ... INTO no encuentra filas:
   - NO asigna nada (variables conservan valor anterior).
   Por eso hacemos:
      SET v_Id_Municipio = NULL; ...
   antes del SELECT, para que “no encontrado” quede en NULL de forma confiable.

   RESULTADO
   ---------
   Retorna:
     - Mensaje
     - Id_Municipio
     - Id_Estado
     - Id_Pais
     - Accion: 'CREADA' | 'REACTIVADA' | 'REUSADA'
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_RegistrarMunicipio$$
CREATE PROCEDURE SP_RegistrarMunicipio(
    IN _Codigo VARCHAR(50),
    IN _Nombre VARCHAR(255),
    IN _Id_Pais_Seleccionado INT,
    IN _Id_Estado INT
)
SP: BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES DE TRABAJO (resultado de búsquedas)
    ---------------------------------------------------------------------------------------- */
    DECLARE v_Id_Municipio INT DEFAULT NULL;
    DECLARE v_Codigo       VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre       VARCHAR(255) DEFAULT NULL;
    DECLARE v_Activo       TINYINT(1)   DEFAULT NULL;

    /* Variables para validar y BLOQUEAR jerarquía padre (País y Estado) */
    DECLARE v_Pais_Existe  INT DEFAULT NULL;
    DECLARE v_Pais_Activo  TINYINT(1) DEFAULT NULL;

    DECLARE v_Estado_Existe INT DEFAULT NULL;
    DECLARE v_Estado_Activo TINYINT(1) DEFAULT NULL;
    DECLARE v_Estado_Pais   INT DEFAULT NULL;

    /* Bandera de duplicado por concurrencia (error 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ----------------------------------------------------------------------------------------
       HANDLERS
       - 1062: NO salimos del SP. Marcamos bandera y el flujo continúa.
       - SQLEXCEPTION: cualquier error distinto => rollback y relanzar.
    ---------------------------------------------------------------------------------------- */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN
       - TRIM evita "CENTRO " vs "CENTRO"
       - NULLIF convierte '' a NULL para detectar vacíos
    ---------------------------------------------------------------------------------------- */
    SET _Codigo = NULLIF(TRIM(_Codigo), '');
    SET _Nombre = NULLIF(TRIM(_Nombre), '');

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES BÁSICAS (rápidas, antes de tocar datos)
    ---------------------------------------------------------------------------------------- */
    IF _Codigo IS NULL OR _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Código y Nombre del Municipio son obligatorios.';
    END IF;

    IF _Id_Pais_Seleccionado IS NULL OR _Id_Pais_Seleccionado <= 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Id_Pais seleccionado inválido (dropdown).';
    END IF;

    IF _Id_Estado IS NULL OR _Id_Estado <= 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Id_Estado inválido (dropdown).';
    END IF;

    /* ========================================================================================
       TRANSACCIÓN PRINCIPAL (INTENTO NORMAL)
    ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 0) BLOQUEAR Y VALIDAR PAÍS PADRE
       - Aunque el dropdown mande solo activos, blindamos backend.
       - FOR UPDATE aquí evita carreras raras con cambios de estatus del País.
    ---------------------------------------------------------------------------------------- */
    SET v_Pais_Existe = NULL; SET v_Pais_Activo = NULL;

    SELECT 1, Activo
      INTO v_Pais_Existe, v_Pais_Activo
    FROM Pais
    WHERE Id_Pais = _Id_Pais_Seleccionado
    LIMIT 1
    FOR UPDATE;

    IF v_Pais_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El País no existe.';
    END IF;

    IF v_Pais_Activo <> 1 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El País está inactivo. No puedes registrar Municipios ahí.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 1) BLOQUEAR Y VALIDAR ESTADO DESTINO + PERTENENCIA AL PAÍS
       - Este es el blindaje “País -> Estado”:
           * Estado debe existir
           * Estado debe estar activo
           * Estado debe pertenecer al País seleccionado
    ---------------------------------------------------------------------------------------- */
    SET v_Estado_Existe = NULL; SET v_Estado_Activo = NULL; SET v_Estado_Pais = NULL;

    SELECT 1, Activo, Fk_Id_Pais
      INTO v_Estado_Existe, v_Estado_Activo, v_Estado_Pais
    FROM Estado
    WHERE Id_Estado = _Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_Estado_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El Estado no existe.';
    END IF;

    IF v_Estado_Pais <> _Id_Pais_Seleccionado THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El Estado no pertenece al País seleccionado.';
    END IF;

    IF v_Estado_Activo <> 1 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: El Estado está inactivo. No puedes registrar Municipios ahí.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) BUSCAR POR CÓDIGO DENTRO DEL ESTADO (REGLA PRINCIPAL)
       - Si existe fila => FOR UPDATE la bloquea.
       - Si no existe => no hay lock; el candado final será el UNIQUE del INSERT.
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Municipio = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Municipio, Codigo, Nombre, Activo
      INTO v_Id_Municipio, v_Codigo, v_Nombre, v_Activo
    FROM Municipio
    WHERE Codigo = _Codigo
      AND Fk_Id_Estado = _Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Municipio IS NOT NULL THEN
        /* Conflicto: mismo Código pero distinto Nombre */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Municipio. El Código ya existe pero el Nombre no coincide (en ese Estado).';
        END IF;

        /* Existe pero estaba inactivo => reactivar */
        IF v_Activo = 0 THEN
            UPDATE Municipio
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Municipio = v_Id_Municipio;

            COMMIT;
            SELECT 'Municipio reactivado exitosamente' AS Mensaje,
                   v_Id_Municipio AS Id_Municipio,
                   _Id_Estado AS Id_Estado,
                   _Id_Pais_Seleccionado AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Existe y está activo => alta bloqueada */
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe un Municipio ACTIVO con ese Código en el Estado seleccionado.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) BUSCAR POR NOMBRE DENTRO DEL ESTADO (SEGUNDA REGLA)
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Municipio = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Municipio, Codigo, Nombre, Activo
      INTO v_Id_Municipio, v_Codigo, v_Nombre, v_Activo
    FROM Municipio
    WHERE Nombre = _Nombre
      AND Fk_Id_Estado = _Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Municipio IS NOT NULL THEN
        /* Conflicto: mismo Nombre pero distinto Código */
        IF v_Codigo <> _Codigo THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Municipio. El Nombre ya existe pero el Código no coincide (en ese Estado).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Municipio
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Municipio = v_Id_Municipio;

            COMMIT;
            SELECT 'Municipio reactivado exitosamente' AS Mensaje,
                   v_Id_Municipio AS Id_Municipio,
                   _Id_Estado AS Id_Estado,
                   _Id_Pais_Seleccionado AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe un Municipio ACTIVO con ese Nombre en el Estado seleccionado.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) INSERT FINAL
       - Aquí puede aparecer el 1062 por carrera (dos usuarios insertando al mismo tiempo).
       - Reiniciamos v_Dup antes del INSERT.
    ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    INSERT INTO Municipio (Codigo, Nombre, Fk_Id_Estado)
    VALUES (_Codigo, _Nombre, _Id_Estado);

    /* Si el INSERT NO disparó 1062 => CREADA */
    IF v_Dup = 0 THEN
        COMMIT;
        SELECT 'Municipio registrado exitosamente' AS Mensaje,
               LAST_INSERT_ID() AS Id_Municipio,
               _Id_Estado AS Id_Estado,
               _Id_Pais_Seleccionado AS Id_Pais,
               'CREADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ========================================================================================
       SI LLEGAMOS AQUÍ: HUBO 1062 EN EL INSERT
       => ALGUIEN INSERTÓ PRIMERO (CONCURRENCIA)
       => RE-RESOLVE: localizar y devolver REUSADA/REACTIVADA (UX limpia)
    ======================================================================================== */
    ROLLBACK;

    /* Nueva transacción:
       - evitar quedarnos con locks del intento fallido
       - bloquear la fila real con FOR UPDATE si hay que reactivar */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE A) Localizar por CÓDIGO dentro del Estado (más determinístico por UNIQUE)
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Municipio = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Municipio, Codigo, Nombre, Activo
      INTO v_Id_Municipio, v_Codigo, v_Nombre, v_Activo
    FROM Municipio
    WHERE Codigo = _Codigo
      AND Fk_Id_Estado = _Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Municipio IS NOT NULL THEN
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Código existe con otro Nombre (en ese Estado).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Municipio
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Municipio = v_Id_Municipio;

            COMMIT;
            SELECT 'Municipio reactivado (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Municipio AS Id_Municipio,
                   _Id_Estado AS Id_Estado,
                   _Id_Pais_Seleccionado AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'Municipio ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Municipio AS Id_Municipio,
               _Id_Estado AS Id_Estado,
               _Id_Pais_Seleccionado AS Id_Pais,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE B) Si no aparece por Código (raro), buscar por NOMBRE dentro del Estado
    ---------------------------------------------------------------------------------------- */
    SET v_Id_Municipio = NULL; SET v_Codigo = NULL; SET v_Nombre = NULL; SET v_Activo = NULL;

    SELECT Id_Municipio, Codigo, Nombre, Activo
      INTO v_Id_Municipio, v_Codigo, v_Nombre, v_Activo
    FROM Municipio
    WHERE Nombre = _Nombre
      AND Fk_Id_Estado = _Id_Estado
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Municipio IS NOT NULL THEN
        IF v_Codigo <> _Codigo THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Nombre existe con otro Código (en ese Estado).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Municipio
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_Municipio = v_Id_Municipio;

            COMMIT;
            SELECT 'Municipio reactivado (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Municipio AS Id_Municipio,
                   _Id_Estado AS Id_Estado,
                   _Id_Pais_Seleccionado AS Id_Pais,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'Municipio ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Municipio AS Id_Municipio,
               _Id_Estado AS Id_Estado,
               _Id_Pais_Seleccionado AS Id_Pais,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* Caso ultra raro: 1062 ocurrió pero no encontramos la fila */
    SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada (1062) pero no se pudo localizar el Municipio. Refresca y reintenta.';

END$$

DELIMITER ;

/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarOrganizacion
   ============================================================================================
   OBJETIVO
   --------
   Resolver o registrar una jerarquía completa de organización:
      Dirección -> Subdirección -> Gerencia
   en una sola operación, pensada para FORMULARIO donde TODO es obligatorio
   (Clave y Nombre en los 3 niveles).

   QUÉ HACE (CONTRATO DE NEGOCIO)
   ------------------------------
   Para cada nivel (Dirección, Subdirección, Gerencia) este SP aplica la MISMA regla:

   1) Busca primero por CLAVE (regla principal) dentro de su “padre” cuando aplica.
      - Si existe: valida que el NOMBRE coincida.
      - Si no coincide: ERROR controlado (conflicto Clave <-> Nombre).

   2) Si no existe por CLAVE, busca por NOMBRE dentro de su “padre” cuando aplica.
      - Si existe: valida que la CLAVE coincida.
      - Si no coincide: ERROR controlado (conflicto Nombre <-> Clave).

   3) Si NO existe por CLAVE ni por NOMBRE:
      - Crea el registro (INSERT).

   4) Si existe y está Activo = 0:
      - Reactiva (UPDATE Activo=1).

   ACCIONES DEVUELTAS
   ------------------
   El SP devuelve una acción por nivel:
      Accion_Direccion    = 'CREADA' | 'REUSADA' | 'REACTIVADA'
      Accion_Subdireccion = 'CREADA' | 'REUSADA' | 'REACTIVADA'
      Accion_Gerencia     = 'CREADA' | 'REUSADA' | 'REACTIVADA'

   SEGURIDAD / INTEGRIDAD
   ----------------------
   - Usa TRANSACTION: si algo falla, ROLLBACK y RESIGNAL (no quedan datos a medias).
   - Resolución determinística.
   - Blindaje ante concurrencia/doble-submit:
       * Los SELECT de búsqueda usan FOR UPDATE para serializar la lectura cuando hay fila.
       * Las constraints UNIQUE son el candado final contra duplicados.

   RESULTADO
   ---------
   Retorna:
   - Id_Direccion, Id_Subdireccion, Id_Gerencia
   - Accion_* por cada nivel
   - Id_Nueva_Direccion      SOLO si Accion_Direccion='CREADA', si no NULL
   - Id_Nueva_Subdireccion   SOLO si Accion_Subdireccion='CREADA', si no NULL
   - Id_Nueva_Gerencia       SOLO si Accion_Gerencia='CREADA', si no NULL
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_RegistrarOrganizacion$$
CREATE PROCEDURE SP_RegistrarOrganizacion(
    IN _Clave_Gerencia        VARCHAR(50),   /* Clave de Gerencia (OBLIGATORIO en formulario) */
    IN _Nombre_Gerencia       VARCHAR(255),  /* Nombre de Gerencia (OBLIGATORIO) */
    IN _Clave_Subdireccion    VARCHAR(50),   /* Clave de Subdirección (OBLIGATORIO) */
    IN _Nombre_Subdireccion   VARCHAR(255),  /* Nombre de Subdirección (OBLIGATORIO) */
    IN _Clave_Direccion       VARCHAR(50),   /* Clave de Dirección (OBLIGATORIO) */
    IN _Nombre_Direccion      VARCHAR(255)   /* Nombre de Dirección (OBLIGATORIO) */
)
BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES INTERNAS
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Id_Direccion    INT DEFAULT NULL;
    DECLARE v_Id_Subdireccion INT DEFAULT NULL;
    DECLARE v_Id_Gerencia     INT DEFAULT NULL;

    /* Buffers para validación cruzada cuando el registro ya existe */
    DECLARE v_Clave  VARCHAR(50);
    DECLARE v_Nombre VARCHAR(255);
    DECLARE v_Activo TINYINT(1);

    /* Acciones por nivel */
    DECLARE v_Accion_Direccion    VARCHAR(20) DEFAULT NULL;
    DECLARE v_Accion_Subdireccion VARCHAR(20) DEFAULT NULL;
    DECLARE v_Accion_Gerencia     VARCHAR(20) DEFAULT NULL;

    /* ----------------------------------------------------------------------------------------
       MANEJO DE ERRORES
       ---------------------------------------------------------------------------------------- */
    DECLARE EXIT HANDLER FOR 1062
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'ERROR: Registro Duplicado por concurrencia o restricción UNIQUE. Refresca y reintenta; si ya existe se reutilizará/reactivará.';
    END;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN BÁSICA
       ---------------------------------------------------------------------------------------- */
    SET _Clave_Direccion     = NULLIF(TRIM(_Clave_Direccion), '');
    SET _Nombre_Direccion    = NULLIF(TRIM(_Nombre_Direccion), '');
    SET _Clave_Subdireccion  = NULLIF(TRIM(_Clave_Subdireccion), '');
    SET _Nombre_Subdireccion = NULLIF(TRIM(_Nombre_Subdireccion), '');
    SET _Clave_Gerencia      = NULLIF(TRIM(_Clave_Gerencia), '');
    SET _Nombre_Gerencia     = NULLIF(TRIM(_Nombre_Gerencia), '');

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE NEGOCIO (FORMULARIO: TODO OBLIGATORIO)
       ---------------------------------------------------------------------------------------- */
    IF _Clave_Direccion IS NULL OR _Nombre_Direccion IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Dirección incompleta (Clave y Nombre obligatorios).';
    END IF;

    IF _Clave_Subdireccion IS NULL OR _Nombre_Subdireccion IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Subdirección incompleta (Clave y Nombre obligatorios).';
    END IF;

    IF _Clave_Gerencia IS NULL OR _Nombre_Gerencia IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Gerencia incompleta (Clave y Nombre obligatorios).';
    END IF;

    /* ----------------------------------------------------------------------------------------
       INICIO TRANSACCIÓN
       ---------------------------------------------------------------------------------------- */
    START TRANSACTION;

    /* ========================================================================================
       1) RESOLVER / CREAR DIRECCIÓN (ABUELO)
       ======================================================================================== */

    /* 1A) Buscar por CLAVE (regla principal) */
    SET v_Id_Direccion = NULL;
    SELECT Id_CatDirecc, Clave, Nombre, Activo
      INTO v_Id_Direccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Direcciones
    WHERE Clave = _Clave_Direccion
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Direccion IS NOT NULL THEN
        /* Si existe por Clave, validar que el Nombre coincida */
        IF v_Nombre <> _Nombre_Direccion THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto Dirección. La Clave existe pero el Nombre no coincide.';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Direcciones 
            SET Activo = 1, updated_at = NOW() 
            WHERE Id_CatDirecc = v_Id_Direccion;
            SET v_Accion_Direccion = 'REACTIVADA';
        ELSE
            SET v_Accion_Direccion = 'REUSADA';
        END IF;

    ELSE
        /* 1B) Buscar por NOMBRE (regla secundaria) */
        SELECT Id_CatDirecc, Clave, Nombre, Activo
          INTO v_Id_Direccion, v_Clave, v_Nombre, v_Activo
        FROM Cat_Direcciones
        WHERE Nombre = _Nombre_Direccion
        LIMIT 1
        FOR UPDATE;

        IF v_Id_Direccion IS NOT NULL THEN
            /* Si existe por Nombre, validar que la Clave coincida */
            IF v_Clave <> _Clave_Direccion THEN
                SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto Dirección. El Nombre existe pero la Clave no coincide.';
            END IF;

            IF v_Activo = 0 THEN
                UPDATE Cat_Direcciones 
                SET Activo = 1, updated_at = NOW() 
                WHERE Id_CatDirecc = v_Id_Direccion;
                SET v_Accion_Direccion = 'REACTIVADA';
            ELSE
                SET v_Accion_Direccion = 'REUSADA';
            END IF;

        ELSE
            /* 1C) Crear */
            INSERT INTO Cat_Direcciones (Clave, Nombre)
            VALUES (_Clave_Direccion, _Nombre_Direccion);

            SET v_Id_Direccion = LAST_INSERT_ID();
            SET v_Accion_Direccion = 'CREADA';
        END IF;
    END IF;

    /* ========================================================================================
       2) RESOLVER / CREAR SUBDIRECCIÓN (dentro de la Dirección resuelta)
       ======================================================================================== */

    /* 2A) Buscar por CLAVE dentro de la Dirección */
    SET v_Id_Subdireccion = NULL;
    SELECT Id_CatSubDirec, Clave, Nombre, Activo
      INTO v_Id_Subdireccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Subdirecciones
    WHERE Clave = _Clave_Subdireccion
      AND Fk_Id_CatDirecc = v_Id_Direccion
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Subdireccion IS NOT NULL THEN
        /* Validar consistencia */
        IF v_Nombre <> _Nombre_Subdireccion THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto Subdirección. La Clave existe pero el Nombre no coincide (en esa Dirección).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Subdirecciones 
            SET Activo = 1, updated_at = NOW() 
            WHERE Id_CatSubDirec = v_Id_Subdireccion;
            SET v_Accion_Subdireccion = 'REACTIVADA';
        ELSE
            SET v_Accion_Subdireccion = 'REUSADA';
        END IF;

    ELSE
        /* 2B) Buscar por NOMBRE dentro de la Dirección */
        SELECT Id_CatSubDirec, Clave, Nombre, Activo
          INTO v_Id_Subdireccion, v_Clave, v_Nombre, v_Activo
        FROM Cat_Subdirecciones
        WHERE Nombre = _Nombre_Subdireccion
          AND Fk_Id_CatDirecc = v_Id_Direccion
        LIMIT 1
        FOR UPDATE;

        IF v_Id_Subdireccion IS NOT NULL THEN
            /* Validar consistencia */
            IF v_Clave <> _Clave_Subdireccion THEN
                SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto Subdirección. El Nombre existe pero la Clave no coincide (en esa Dirección).';
            END IF;

            IF v_Activo = 0 THEN
                UPDATE Cat_Subdirecciones 
                SET Activo = 1, updated_at = NOW() 
                WHERE Id_CatSubDirec = v_Id_Subdireccion;
                SET v_Accion_Subdireccion = 'REACTIVADA';
            ELSE
                SET v_Accion_Subdireccion = 'REUSADA';
            END IF;

        ELSE
            /* 2C) Crear */
            INSERT INTO Cat_Subdirecciones (Fk_Id_CatDirecc, Clave, Nombre)
            VALUES (v_Id_Direccion, _Clave_Subdireccion, _Nombre_Subdireccion);

            SET v_Id_Subdireccion = LAST_INSERT_ID();
            SET v_Accion_Subdireccion = 'CREADA';
        END IF;
    END IF;

    /* ========================================================================================
       3) RESOLVER / CREAR GERENCIA (dentro de la Subdirección resuelta)
       ======================================================================================== */

    /* 3A) Buscar por CLAVE dentro de la Subdirección */
    SET v_Id_Gerencia = NULL;
    SELECT Id_CatGeren, Clave, Nombre, Activo
      INTO v_Id_Gerencia, v_Clave, v_Nombre, v_Activo
    FROM Cat_Gerencias_Activos
    WHERE Clave = _Clave_Gerencia
      AND Fk_Id_CatSubDirec = v_Id_Subdireccion
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Gerencia IS NOT NULL THEN
        /* Validar consistencia */
        IF v_Nombre <> _Nombre_Gerencia THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto Gerencia. La Clave existe pero el Nombre no coincide (en esa Subdirección).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Gerencias_Activos 
            SET Activo = 1, updated_at = NOW() 
            WHERE Id_CatGeren = v_Id_Gerencia;
            SET v_Accion_Gerencia = 'REACTIVADA';
        ELSE
            SET v_Accion_Gerencia = 'REUSADA';
        END IF;

    ELSE
        /* 3B) Buscar por NOMBRE dentro de la Subdirección */
        SELECT Id_CatGeren, Clave, Nombre, Activo
          INTO v_Id_Gerencia, v_Clave, v_Nombre, v_Activo
        FROM Cat_Gerencias_Activos
        WHERE Nombre = _Nombre_Gerencia
          AND Fk_Id_CatSubDirec = v_Id_Subdireccion
        LIMIT 1
        FOR UPDATE;

        IF v_Id_Gerencia IS NOT NULL THEN
            /* Validar consistencia */
            IF v_Clave <> _Clave_Gerencia THEN
                SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto Gerencia. El Nombre existe pero la Clave no coincide (en esa Subdirección).';
            END IF;

            IF v_Activo = 0 THEN
                UPDATE Cat_Gerencias_Activos 
                SET Activo = 1, updated_at = NOW() 
                WHERE Id_CatGeren = v_Id_Gerencia;
                SET v_Accion_Gerencia = 'REACTIVADA';
            ELSE
                SET v_Accion_Gerencia = 'REUSADA';
            END IF;

        ELSE
            /* 3C) Crear */
            INSERT INTO Cat_Gerencias_Activos (Fk_Id_CatSubDirec, Clave, Nombre)
            VALUES (v_Id_Subdireccion, _Clave_Gerencia, _Nombre_Gerencia);

            SET v_Id_Gerencia = LAST_INSERT_ID();
            SET v_Accion_Gerencia = 'CREADA';
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       CONFIRMAR TRANSACCIÓN Y RESPUESTA
       ---------------------------------------------------------------------------------------- */
    COMMIT;

    SELECT 
        'Registro Exitoso' AS Mensaje,

        v_Id_Direccion    AS Id_Direccion,
        v_Id_Subdireccion AS Id_Subdireccion,
        v_Id_Gerencia     AS Id_Gerencia,

        v_Accion_Direccion    AS Accion_Direccion,
        v_Accion_Subdireccion AS Accion_Subdireccion,
        v_Accion_Gerencia     AS Accion_Gerencia,

        CASE 
            WHEN v_Accion_Direccion = 'CREADA' THEN v_Id_Direccion 
            ELSE NULL 
        END AS Id_Nueva_Direccion,
        
        CASE 
            WHEN v_Accion_Subdireccion = 'CREADA' THEN v_Id_Subdireccion 
            ELSE NULL 
        END AS Id_Nueva_Subdireccion,
        
        CASE 
            WHEN v_Accion_Gerencia = 'CREADA' THEN v_Id_Gerencia 
            ELSE NULL 
        END AS Id_Nueva_Gerencia;

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarDireccion  (VERSIÓN PRO: 1062 => RE-RESOLVE)
   ============================================================================================
   OBJETIVO
   --------
   Registrar una Dirección (Clave + Nombre) con blindaje fuerte contra duplicados y carreras
   (concurrencia), devolviendo una respuesta “limpia” para el frontend:

   - Si la Dirección NO existe -> INSERT -> Accion = 'CREADA'
   - Si existe pero Activo=0 -> UPDATE Activo=1 -> Accion = 'REACTIVADA'
   - Si ya existía (por doble submit / carrera) -> NO error -> Accion='REUSADA'
   - Si hay conflicto real (mismo código con otro nombre, o viceversa) -> ERROR controlado.

   ¿CUÁNDO SE USA?
   --------------
   - Formulario "Alta de Dirección" (catálogo).
   - Casos típicos de concurrencia:
       * El usuario da doble clic a “Guardar”
       * La red está lenta y re-envía el paquete
       * Dos usuarios registran lo mismo casi al mismo tiempo

   REGLAS DE NEGOCIO (CONTRATO)
   ---------------------------
   Reglas determinísticas (SIN “OR ... LIMIT 1” ambiguo):

   1) Primero se resuelve por CLAVE (regla principal):
      - Si existe:
          a) Si NOMBRE no coincide -> ERROR (conflicto)
          b) Si Activo=0 -> REACTIVA (UPDATE Activo=1)
          c) Si Activo=1 -> ERROR (duplicado real, no es “carrera”)
      - Si no existe -> continúa

   2) Si no existe por CLAVE, se resuelve por NOMBRE:
      - Si existe:
          a) Si CLAVE no coincide -> ERROR (conflicto)
          b) Si Activo=0 -> REACTIVA
          c) Si Activo=1 -> ERROR (duplicado real)
      - Si no existe -> continúa

   3) Si NO existe por CLAVE ni por NOMBRE:
      - INTENTA INSERT.
      - Aquí es donde puede ocurrir la carrera (1062) si alguien insertó “en el mismo instante”.

   CONCURRENCIA (POR QUÉ EXISTE EL RE-RESOLVE)
   ------------------------------------------
   Importante: `SELECT ... FOR UPDATE` solo bloquea SI EXISTE una fila.
   Si NO hay fila (aún no existe la Dirección), no hay nada que bloquear.
   Entonces, dos transacciones pueden llegar al `INSERT` al mismo tiempo:

     Tx A: no encuentra fila -> INSERT -> OK
     Tx B: no encuentra fila -> INSERT -> 1062 (UNIQUE lo frena)

   En la versión simple, Tx B regresaría error.
   En esta versión PRO, Tx B:
      - Detecta 1062 (bandera v_Dup=1)
      - Hace ROLLBACK
      - Re-consulta el registro ya creado (por Tx A)
      - Devolvemos REUSADA (o REACTIVADA si estaba inactivo)

   SEGURIDAD / INTEGRIDAD
   ----------------------
   - UNIQUE en tabla sigue siendo la última línea de defensa:
       Cat_Direcciones.Clave UNIQUE
       Cat_Direcciones.Nombre UNIQUE
   - TRANSACTION + HANDLERS:
       * 1062 => NO aborta inmediato, marca bandera y permite “re-resolver”
       * Cualquier otro error => ROLLBACK y RESIGNAL (error real)
   - SELECT ... FOR UPDATE:
       * Serializa cuando la fila ya existe (evita cambios concurrentes inconsistentes)
       * Permite reactivar de forma segura

   RESULTADO
   ---------
   Retorna:
     - Mensaje (texto para UX)
     - Id_CatDirecc
     - Accion: 'CREADA' | 'REACTIVADA' | 'REUSADA'

============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_RegistrarDireccion$$
CREATE PROCEDURE SP_RegistrarDireccion(
    IN _Clave VARCHAR(50),
    IN _Nombre VARCHAR(255)
)
SP: BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES DE TRABAJO
       - v_* guardan el registro encontrado (si existe).
       - v_Dup es una BANDERA para detectar que ocurrió 1062 durante el INSERT.
         (OJO: al ser CONTINUE HANDLER, si no revisas v_Dup, te puedes ir a COMMIT sin insertar.)
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Id_Direccion INT DEFAULT NULL;
    DECLARE v_Clave        VARCHAR(50) DEFAULT NULL;
    DECLARE v_Nombre       VARCHAR(255) DEFAULT NULL;
    DECLARE v_Activo       TINYINT(1) DEFAULT NULL;

    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ----------------------------------------------------------------------------------------
       HANDLERS
       - 1062 (Duplicate entry): no aborta de golpe; solo marca bandera.
         Esto es CLAVE para poder hacer "re-resolve" sin mostrar error al usuario.
       - SQLEXCEPTION: cualquier otro error sí aborta (rollback + resignal).
       ---------------------------------------------------------------------------------------- */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN DE INPUTS
       - TRIM: evita que "DIR " y "DIR" se comporten como cosas diferentes
       - NULLIF: convierte '' en NULL para validar obligatorios de forma limpia
       ---------------------------------------------------------------------------------------- */
    SET _Clave = NULLIF(TRIM(_Clave), '');
    SET _Nombre = NULLIF(TRIM(_Nombre), '');

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES BÁSICAS
       ---------------------------------------------------------------------------------------- */
    IF _Clave IS NULL OR _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Clave y Nombre de la Dirección son obligatorios.';
    END IF;

    /* ========================================================================================
       TRANSACCIÓN PRINCIPAL (INTENTO NORMAL)
       - Aquí resolvemos por CLAVE -> por NOMBRE -> INSERT
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1: BUSCAR POR CLAVE (REGLA PRINCIPAL)
       - FOR UPDATE:
         Si la fila existe, la bloquea para evitar carreras en reactivación/cambios simultáneos.
       - Limpieza de variables:
         Evita que queden valores viejos si el SELECT no retorna fila.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Direccion = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatDirecc, Clave, Nombre, Activo
      INTO v_Id_Direccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Direcciones
    WHERE Clave = _Clave
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Direccion IS NOT NULL THEN
        /* Conflicto fuerte: misma clave pero otro nombre => datos inconsistentes */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Dirección. La Clave ya existe pero el Nombre no coincide.';
        END IF;

        /* Si existe pero está inactivo => reactivación segura (borrado lógico) */
        IF v_Activo = 0 THEN
            UPDATE Cat_Direcciones
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatDirecc = v_Id_Direccion;

            COMMIT;
            SELECT 'Dirección reactivada exitosamente' AS Mensaje,
                   v_Id_Direccion AS Id_CatDirecc,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Si existe y está activo => duplicado REAL (no es concurrencia) */
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe una Dirección ACTIVA con esa Clave.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2: BUSCAR POR NOMBRE (REGLA SECUNDARIA)
       - Misma lógica que la clave, pero al revés.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Direccion = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatDirecc, Clave, Nombre, Activo
      INTO v_Id_Direccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Direcciones
    WHERE Nombre = _Nombre
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Direccion IS NOT NULL THEN
        /* Conflicto fuerte: mismo nombre pero otra clave => datos inconsistentes */
        IF v_Clave <> _Clave THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Dirección. El Nombre ya existe pero la Clave no coincide.';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Direcciones
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatDirecc = v_Id_Direccion;

            COMMIT;
            SELECT 'Dirección reactivada exitosamente' AS Mensaje,
                   v_Id_Direccion AS Id_CatDirecc,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe una Dirección ACTIVA con ese Nombre.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3: INSERT (CREACIÓN REAL)
       - Este es el único punto donde la concurrencia puede provocar 1062:
         porque NO había fila para bloquear con FOR UPDATE.
       - v_Dup se reinicia antes del INSERT para que sea confiable.
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    INSERT INTO Cat_Direcciones (Clave, Nombre)
    VALUES (_Clave, _Nombre);

    /* Si NO hubo 1062, v_Dup sigue en 0 => Insert exitoso */
    IF v_Dup = 0 THEN
        COMMIT;
        SELECT 'Dirección registrada exitosamente' AS Mensaje,
               LAST_INSERT_ID() AS Id_CatDirecc,
               'CREADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ========================================================================================
       SI LLEGAMOS AQUÍ:
       - v_Dup = 1 => el INSERT falló con 1062
       - Eso significa: “alguien ya insertó antes” (carrera/doble-submit)
       => RE-RESOLVE: localizar el registro y devolverlo como REUSADA/REACTIVADA
       ======================================================================================== */

    /* IMPORTANTE: revertimos el intento para salir “limpios” y sin locks */
    ROLLBACK;

    /* ----------------------------------------------------------------------------------------
       TRANSACCIÓN DE RE-RESOLVE
       - Nueva transacción para:
         1) Evitar quedarnos con locks/estado del intento anterior
         2) Poder usar FOR UPDATE sobre la fila real encontrada
       ---------------------------------------------------------------------------------------- */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE A) Localizar por CLAVE
       - Si aparece: validamos coherencia con el Nombre solicitado.
       - Si está inactivo: lo reactivamos y devolvemos REACTIVADA.
       - Si está activo: devolvemos REUSADA (UX limpia).
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Direccion = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatDirecc, Clave, Nombre, Activo
      INTO v_Id_Direccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Direcciones
    WHERE Clave = _Clave
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Direccion IS NOT NULL THEN
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Clave existe con otro Nombre.';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Direcciones
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatDirecc = v_Id_Direccion;

            COMMIT;
            SELECT 'Dirección reactivada (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Direccion AS Id_CatDirecc,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'Dirección ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Direccion AS Id_CatDirecc,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE B) Si no apareció por clave (muy raro), buscamos por NOMBRE
       - Misma lógica, pero validando coherencia de la Clave.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Direccion = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatDirecc, Clave, Nombre, Activo
      INTO v_Id_Direccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Direcciones
    WHERE Nombre = _Nombre
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Direccion IS NOT NULL THEN
        IF v_Clave <> _Clave THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Nombre existe con otra Clave.';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Direcciones
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatDirecc = v_Id_Direccion;

            COMMIT;
            SELECT 'Dirección reactivada (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Direccion AS Id_CatDirecc,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'Dirección ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Direccion AS Id_CatDirecc,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE C) Caso extremadamente raro
       - Hubo 1062 pero no localizamos la fila.
       - En InnoDB normal esto “no debería pasar”.
       - Devolvemos error controlado para que el frontend reintente.
       ---------------------------------------------------------------------------------------- */
    SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada (1062) pero no se pudo localizar el registro. Reintenta.';

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarSubdireccion  (VERSIÓN PRO: 1062 => RE-RESOLVE)
   ============================================================================================
   OBJETIVO
   --------
   Registrar una nueva Subdirección dentro de una Dirección específica (seleccionada por -- DROPdown),
   con blindaje fuerte contra duplicados y con manejo PRO de concurrencia (doble submit).

   ¿CUÁNDO SE USA?
   --------------
   - Formulario “Alta de Subdirección”.
   - El usuario captura:
        * Clave (ej: 'SGRH')
        * Nombre (ej: 'SUBDIRECCIÓN DE RECURSOS HUMANOS')
     y selecciona una Dirección ACTIVA del -- DROPdown:
        * _Fk_Id_CatDirecc (Id_Direccion)

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   En la Dirección _Fk_Id_CatDirecc se aplica la MISMA regla determinística que en Estado:

   1) Buscar primero por CLAVE dentro de la Dirección (regla principal).
      - Si existe:
          a) El NOMBRE debe coincidir, si no => ERROR (conflicto Clave <-> Nombre).
          b) Si Activo=0 => REACTIVAR (UPDATE Activo=1) y devolver 'REACTIVADA'.
          c) Si Activo=1 => ERROR (ya existe activo).

   2) Si no existe por CLAVE, buscar por NOMBRE dentro de la Dirección.
      - Si existe:
          a) La CLAVE debe coincidir, si no => ERROR (conflicto Nombre <-> Clave).
          b) Si Activo=0 => REACTIVAR y devolver 'REACTIVADA'.
          c) Si Activo=1 => ERROR (ya existe activo).

   3) Si no existe por ninguno => INSERT y devolver 'CREADA'.

   CONCURRENCIA (EL PROBLEMA REAL)
   -------------------------------
   Caso típico:
   - Usuario A y Usuario B intentan registrar la misma Subdirección (misma Clave o mismo Nombre)
     en la MISMA Dirección casi al mismo tiempo.
   - Los SELECT ... FOR UPDATE NO bloquean nada si “no hay fila todavía”.
   - Ambos intentan INSERT.
   - Uno gana y el otro pierde con error 1062 (violación de UNIQUE).

   SOLUCIÓN PRO: 1062 => “RE-RESOLVE”
   ---------------------------------
   En vez de devolver un error feo al segundo:
   - Detectamos el 1062 (handler).
   - Hacemos ROLLBACK del intento.
   - Abrimos una nueva transacción y “localizamos” el registro ganador.
   - Devolvemos:
        Accion='REUSADA'  (ya existía y se reutiliza)
     o Accion='REACTIVADA' (si estaba inactivo y se reactivó).

   IMPORTANTE: ¿POR QUÉ SE RESETEAN VARIABLES A NULL ANTES DE CADA SELECT INTO?
   ----------------------------------------------------------------------------
   En MySQL, si un SELECT ... INTO no encuentra filas:
   - NO asigna nada (las variables se quedan con el valor anterior).
   Por eso SIEMPRE hacemos:
      SET v_Id_Subdireccion = NULL; ...
   antes del SELECT, para que “no encontrado” sea detectable como NULL.

   SEGURIDAD / INTEGRIDAD (TU ESQUEMA)
   -----------------------------------
   - Dirección tiene Activo (-- DROPdown debe ser solo activos).
   - Subdirección tiene UNIQUE compuestos:
        Uk_Subdireccion_Clave_Direccion UNIQUE (Clave, Fk_Id_CatDirecc)
        Uk_Subdireccion_Nombre_Direccion UNIQUE (Nombre, Fk_Id_CatDirecc)
   - TRANSACTION + SELECT ... FOR UPDATE:
        * Si la fila existe => la bloquea y serializa.
        * Si no existe => el candado final es el UNIQUE (y ahí entra el 1062).

   RESULTADO
   ---------
   Retorna:
     - Mensaje
     - Id_CatSubDirec
     - Id_Direccion (Fk_Id_CatDirecc)
     - Accion: 'CREADA' | 'REACTIVADA' | 'REUSADA'
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_RegistrarSubdireccion$$
CREATE PROCEDURE SP_RegistrarSubdireccion(
    IN _Clave           VARCHAR(50),
    IN _Nombre          VARCHAR(255),
    IN _Fk_Id_CatDirecc INT
)
SP: BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES DE TRABAJO (resultado de búsquedas)
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Id_Subdireccion INT DEFAULT NULL;
    DECLARE v_Clave           VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre          VARCHAR(255) DEFAULT NULL;
    DECLARE v_Activo          TINYINT(1)   DEFAULT NULL;

    /* Variables para validar Dirección padre con lock */
    DECLARE v_Direccion_Existe INT DEFAULT NULL;
    DECLARE v_Direccion_Activo TINYINT(1) DEFAULT NULL;

    /* Bandera de duplicado por concurrencia (error 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ----------------------------------------------------------------------------------------
       HANDLERS
       - 1062: NO salimos del SP. Marcamos bandera y el flujo continúa.
       - SQLEXCEPTION: cualquier error distinto => rollback y relanzar.
       ---------------------------------------------------------------------------------------- */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN (evita duplicados por espacios o strings vacíos)
       ---------------------------------------------------------------------------------------- */
    SET _Clave  = NULLIF(TRIM(_Clave), '');
    SET _Nombre = NULLIF(TRIM(_Nombre), '');

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES BÁSICAS (rápidas, antes de tocar datos)
       ---------------------------------------------------------------------------------------- */
    IF _Fk_Id_CatDirecc IS NULL OR _Fk_Id_CatDirecc <= 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Id_CatDirecc inválido (-- DROPdown).';
    END IF;

    IF _Clave IS NULL OR _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Clave y Nombre de la Subdirección son obligatorios.';
    END IF;

    /* ========================================================================================
       TRANSACCIÓN PRINCIPAL (INTENTO NORMAL)
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 0) BLOQUEAR Y VALIDAR DIRECCIÓN PADRE
       - Esto evita carreras raras donde:
           * alguien desactiva la Dirección mientras tú estás registrando una Subdirección
       - Como tu UI lista solo activos, normalmente siempre pasa.
       - Aun así, se blinda el sistema ante requests manipuladas.
       ---------------------------------------------------------------------------------------- */
    SET v_Direccion_Existe = NULL; 
    SET v_Direccion_Activo = NULL;

    SELECT 1, Activo
      INTO v_Direccion_Existe, v_Direccion_Activo
    FROM Cat_Direcciones
    WHERE Id_CatDirecc = _Fk_Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_Direccion_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: La Dirección padre no existe.';
    END IF;

    IF v_Direccion_Activo <> 1 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: La Dirección está inactiva. No puedes registrar Subdirecciones ahí.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 1) BUSCAR POR CLAVE DENTRO DE LA DIRECCIÓN (REGLA PRINCIPAL)
       - Si existe, se bloquea la fila Subdirección (FOR UPDATE).
       - Si no existe, NO hay lock (y por eso 1062 puede ocurrir en el INSERT).
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Subdireccion = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatSubDirec, Clave, Nombre, Activo
      INTO v_Id_Subdireccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Subdirecciones
    WHERE Clave = _Clave
      AND Fk_Id_CatDirecc = _Fk_Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Subdireccion IS NOT NULL THEN
        /* Conflicto: misma Clave pero distinto Nombre => datos inconsistentes */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Subdirección. La Clave ya existe pero el Nombre no coincide (en esa Dirección).';
        END IF;

        /* Existe pero estaba inactivo => se reactiva */
        IF v_Activo = 0 THEN
            UPDATE Cat_Subdirecciones
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatSubDirec = v_Id_Subdireccion;

            COMMIT;
            SELECT 'Subdirección reactivada exitosamente' AS Mensaje,
                   v_Id_Subdireccion AS Id_CatSubDirec,
                   _Fk_Id_CatDirecc AS Id_CatDirecc,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Existe y está activo => no se permite alta */
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe una Subdirección ACTIVA con esa Clave en la Dirección seleccionada.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) BUSCAR POR NOMBRE DENTRO DE LA DIRECCIÓN (SEGUNDA REGLA)
       - Si existe por Nombre, la Clave debe coincidir.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Subdireccion = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatSubDirec, Clave, Nombre, Activo
      INTO v_Id_Subdireccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Subdirecciones
    WHERE Nombre = _Nombre
      AND Fk_Id_CatDirecc = _Fk_Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Subdireccion IS NOT NULL THEN
        /* Conflicto: mismo Nombre pero distinta Clave => datos inconsistentes */
        IF v_Clave <> _Clave THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Subdirección. El Nombre ya existe pero la Clave no coincide (en esa Dirección).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Subdirecciones
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatSubDirec = v_Id_Subdireccion;

            COMMIT;
            SELECT 'Subdirección reactivada exitosamente' AS Mensaje,
                   v_Id_Subdireccion AS Id_CatSubDirec,
                   _Fk_Id_CatDirecc AS Id_CatDirecc,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe una Subdirección ACTIVA con ese Nombre en la Dirección seleccionada.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) INSERT FINAL
       - Aquí es donde puede aparecer el 1062 por carrera.
       - v_Dup se reinicia antes del INSERT.
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    INSERT INTO Cat_Subdirecciones (Clave, Nombre, Fk_Id_CatDirecc)
    VALUES (_Clave, _Nombre, _Fk_Id_CatDirecc);

    /* Si el INSERT NO disparó 1062, todo bien => CREADA */
    IF v_Dup = 0 THEN
        COMMIT;
        SELECT 'Subdirección registrada exitosamente' AS Mensaje,
               LAST_INSERT_ID() AS Id_CatSubDirec,
               _Fk_Id_CatDirecc AS Id_CatDirecc,
               'CREADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ========================================================================================
       SI LLEGAMOS AQUÍ: HUBO 1062 EN EL INSERT
       => ALGUIEN INSERTÓ PRIMERO (CONCURRENCIA / DOBLE SUBMIT)
       => RE-RESOLVE: localizar y devolver REUSADA/REACTIVADA (UX limpia)
       ======================================================================================== */
    ROLLBACK;

    /* Segunda transacción limpia:
       - no arrastrar locks del intento fallido
       - bloquear la fila real con FOR UPDATE si toca reactivar */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE A) Localizar por CLAVE dentro de la Dirección (más determinístico por UNIQUE)
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Subdireccion = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatSubDirec, Clave, Nombre, Activo
      INTO v_Id_Subdireccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Subdirecciones
    WHERE Clave = _Clave
      AND Fk_Id_CatDirecc = _Fk_Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Subdireccion IS NOT NULL THEN
        /* Si el “ganador” tiene otro Nombre => conflicto real (no es el mismo registro lógico) */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Clave existe con otro Nombre (en esa Dirección).';
        END IF;

        /* Si por alguna razón estaba inactivo => reactivar */
        IF v_Activo = 0 THEN
            UPDATE Cat_Subdirecciones
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatSubDirec = v_Id_Subdireccion;

            COMMIT;
            SELECT 'Subdirección reactivada (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Subdireccion AS Id_CatSubDirec,
                   _Fk_Id_CatDirecc AS Id_CatDirecc,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Ya existe activo => REUSADA (sin error al usuario) */
        COMMIT;
        SELECT 'Subdirección ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Subdireccion AS Id_CatSubDirec,
               _Fk_Id_CatDirecc AS Id_CatDirecc,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE B) Si no aparece por Clave (raro), buscar por NOMBRE dentro de la Dirección
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Subdireccion = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatSubDirec, Clave, Nombre, Activo
      INTO v_Id_Subdireccion, v_Clave, v_Nombre, v_Activo
    FROM Cat_Subdirecciones
    WHERE Nombre = _Nombre
      AND Fk_Id_CatDirecc = _Fk_Id_CatDirecc
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Subdireccion IS NOT NULL THEN
        IF v_Clave <> _Clave THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Nombre existe con otra Clave (en esa Dirección).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Subdirecciones
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatSubDirec = v_Id_Subdireccion;

            COMMIT;
            SELECT 'Subdirección reactivada (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Subdireccion AS Id_CatSubDirec,
                   _Fk_Id_CatDirecc AS Id_CatDirecc,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'Subdirección ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Subdireccion AS Id_CatSubDirec,
               _Fk_Id_CatDirecc AS Id_CatDirecc,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* Caso ultra raro: 1062 ocurrió pero no encontramos el registro */
    SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada (1062) pero no se pudo localizar la Subdirección. Refresca y reintenta.';

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarGerencia  (VERSIÓN PRO: 1062 => RE-RESOLVE)
   ============================================================================================
   OBJETIVO
   --------
   Registrar una nueva Gerencia dentro de una Subdirección específica (seleccionada por -- DROPdown),
   con blindaje fuerte contra duplicados y con manejo PRO de concurrencia (doble-submit).

   ¿CUÁNDO SE USA?
   --------------
   - Formulario “Alta de Gerencia”.
   - El usuario captura:
        * _Codigo  (ej: 'GER-RH')  -> Clave
        * _Nombre  (ej: 'GERENCIA DE CAPITAL HUMANO')
     y selecciona por -- DROPdown:
        * _Id_Direccion_Seleccionada  (solo direcciones ACTIVO=1, usado para filtrar subdirecciones)
        * _Id_Subdireccion            (solo subdirecciones ACTIVO=1 que pertenecen a esa dirección)

   REGLAS (CONTRATO DE NEGOCIO)
   ----------------------------
   Dentro de la Subdirección _Id_Subdireccion se aplica la misma regla determinística:

   1) Buscar primero por CLAVE dentro de la Subdirección (regla principal).
      - Si existe:
          a) El NOMBRE debe coincidir, si no => ERROR (conflicto Clave <-> Nombre).
          b) Si Activo=0 => REACTIVAR (UPDATE Activo=1) y devolver 'REACTIVADA'.
          c) Si Activo=1 => ERROR (ya existe activo).

   2) Si no existe por CLAVE, buscar por NOMBRE dentro de la Subdirección.
      - Si existe:
          a) La CLAVE debe coincidir, si no => ERROR (conflicto Nombre <-> Clave).
          b) Si Activo=0 => REACTIVAR y devolver 'REACTIVADA'.
          c) Si Activo=1 => ERROR (ya existe activo).

   3) Si no existe por ninguno => INSERT y devolver 'CREADA'.

   VALIDACIÓN JERÁRQUICA (DIRECCIÓN -> SUBDIRECCIÓN)
   -------------------------------------------------
   Aunque el frontend use -- DROPdowns (y “debería” mandar combos válidos), este SP valida:
   - La Dirección (Abuelo) existe y está ACTIVA.
   - La Subdirección (Padre) existe, está ACTIVA y pertenece a esa Dirección.
   Esto blinda el backend ante:
   - Requests manipuladas.
   - Bugs del frontend.
   - Datos “viejos” en cache del navegador (usuario deja la pantalla abierta y cambia catálogo).

   CONCURRENCIA (EL PROBLEMA REAL)
   -------------------------------
   - SELECT ... FOR UPDATE solo bloquea si la fila existe.
   - Si la Gerencia no existe todavía:
        * Dos usuarios pueden pasar los SELECT sin bloquear nada.
        * Ambos intentan INSERT.
        * Uno gana, el otro cae en 1062 (por UNIQUE).
   Tu tabla Gerencias tiene UNIQUE:
      - Uk_Gerencia_Clave_Subdireccion UNIQUE (Clave, Fk_Id_CatSubDirec)
      - Uk_Gerencia_Nombre_Subdireccion UNIQUE (Nombre, Fk_Id_CatSubDirec)

   SOLUCIÓN PRO: 1062 => “RE-RESOLVE”
   ---------------------------------
   En vez de mostrar error al segundo usuario:
   - Detectamos 1062 (handler).
   - ROLLBACK del intento.
   - Nueva transacción.
   - Localizamos el registro “ganador”.
   - Devolvemos:
        Accion='REUSADA' (ya existía activa)
     o Accion='REACTIVADA' (si estaba inactivo).

   IMPORTANTE: ¿POR QUÉ SE RESETEAN VARIABLES A NULL ANTES DE CADA SELECT INTO?
   ----------------------------------------------------------------------------
   En MySQL, si un SELECT ... INTO no encuentra filas:
   - NO asigna nada (las variables se quedan con el valor anterior).
   Por eso hacemos:
      SET v_Id_Gerencia = NULL; ...
   antes del SELECT, para que “no encontrado” quede en NULL de forma confiable.

   RESULTADO
   ---------
   Retorna:
     - Mensaje
     - Id_CatGeren
     - Id_Subdireccion
     - Id_Direccion
     - Accion: 'CREADA' | 'REACTIVADA' | 'REUSADA'
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS SP_RegistrarGerencia$$
CREATE PROCEDURE SP_RegistrarGerencia(
    IN _Clave VARCHAR(50),
    IN _Nombre VARCHAR(255),
    IN _Id_Direccion_Seleccionada INT,
    IN _Id_Subdireccion INT
)
SP: BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES DE TRABAJO (resultado de búsquedas)
       ---------------------------------------------------------------------------------------- */
    DECLARE v_Id_Gerencia INT DEFAULT NULL;
    DECLARE v_Clave       VARCHAR(50)  DEFAULT NULL;
    DECLARE v_Nombre      VARCHAR(255) DEFAULT NULL;
    DECLARE v_Activo      TINYINT(1)   DEFAULT NULL;

    /* Variables para validar y BLOQUEAR jerarquía padre (Dirección y Subdirección) */
    DECLARE v_Direccion_Existe  INT DEFAULT NULL;
    DECLARE v_Direccion_Activo  TINYINT(1) DEFAULT NULL;

    DECLARE v_Subdireccion_Existe INT DEFAULT NULL;
    DECLARE v_Subdireccion_Activo TINYINT(1) DEFAULT NULL;
    DECLARE v_Subdireccion_Direccion INT DEFAULT NULL;

    /* Bandera de duplicado por concurrencia (error 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ----------------------------------------------------------------------------------------
       HANDLERS
       - 1062: NO salimos del SP. Marcamos bandera y el flujo continúa.
       - SQLEXCEPTION: cualquier error distinto => rollback y relanzar.
       ---------------------------------------------------------------------------------------- */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN
       - TRIM evita "GERENCIA " vs "GERENCIA"
       - NULLIF convierte '' a NULL para detectar vacíos
       ---------------------------------------------------------------------------------------- */
    SET _Clave  = NULLIF(TRIM(_Clave), '');
    SET _Nombre = NULLIF(TRIM(_Nombre), '');

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES BÁSICAS (rápidas, antes de tocar datos)
       ---------------------------------------------------------------------------------------- */
    IF _Clave IS NULL OR _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Clave y Nombre de la Gerencia son obligatorios.';
    END IF;

    IF _Id_Direccion_Seleccionada IS NULL OR _Id_Direccion_Seleccionada <= 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Id_Direccion seleccionada inválido (-- DROPdown).';
    END IF;

    IF _Id_Subdireccion IS NULL OR _Id_Subdireccion <= 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Id_Subdireccion inválido (-- DROPdown).';
    END IF;

    /* ========================================================================================
       TRANSACCIÓN PRINCIPAL (INTENTO NORMAL)
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 0) BLOQUEAR Y VALIDAR DIRECCIÓN (ABUELO)
       - Aunque el -- DROPdown mande solo activos, blindamos backend.
       - FOR UPDATE aquí evita carreras raras con cambios de estatus de la Dirección.
       ---------------------------------------------------------------------------------------- */
    SET v_Direccion_Existe = NULL; 
    SET v_Direccion_Activo = NULL;

    SELECT 1, Activo
      INTO v_Direccion_Existe, v_Direccion_Activo
    FROM Cat_Direcciones
    WHERE Id_CatDirecc = _Id_Direccion_Seleccionada
    LIMIT 1
    FOR UPDATE;

    IF v_Direccion_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: La Dirección seleccionada no existe.';
    END IF;

    IF v_Direccion_Activo <> 1 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: La Dirección seleccionada está inactiva. No puedes registrar Gerencias ahí.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 1) BLOQUEAR Y VALIDAR SUBDIRECCIÓN (PADRE) + PERTENENCIA A DIRECCIÓN
       - Este es el blindaje “Dirección -> Subdirección”:
            * Subdirección debe existir
            * Subdirección debe estar activa
            * Subdirección debe pertenecer a la Dirección seleccionada
       ---------------------------------------------------------------------------------------- */
    SET v_Subdireccion_Existe = NULL; 
    SET v_Subdireccion_Activo = NULL; 
    SET v_Subdireccion_Direccion = NULL;

    SELECT 1, Activo, Fk_Id_CatDirecc
      INTO v_Subdireccion_Existe, v_Subdireccion_Activo, v_Subdireccion_Direccion
    FROM Cat_Subdirecciones
    WHERE Id_CatSubDirec = _Id_Subdireccion
    LIMIT 1
    FOR UPDATE;

    IF v_Subdireccion_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: La Subdirección no existe.';
    END IF;

    IF v_Subdireccion_Direccion <> _Id_Direccion_Seleccionada THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: La Subdirección no pertenece a la Dirección seleccionada.';
    END IF;

    IF v_Subdireccion_Activo <> 1 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: La Subdirección está inactiva. No puedes registrar Gerencias ahí.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) BUSCAR POR CLAVE DENTRO DE LA SUBDIRECCIÓN (REGLA PRINCIPAL)
       - Si existe fila => FOR UPDATE la bloquea.
       - Si no existe => no hay lock; el candado final será el UNIQUE del INSERT.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Gerencia = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatGeren, Clave, Nombre, Activo
      INTO v_Id_Gerencia, v_Clave, v_Nombre, v_Activo
    FROM Cat_Gerencias_Activos
    WHERE Clave = _Clave
      AND Fk_Id_CatSubDirec = _Id_Subdireccion
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Gerencia IS NOT NULL THEN
        /* Conflicto: misma Clave pero distinto Nombre */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Gerencia. La Clave ya existe pero el Nombre no coincide (en esa Subdirección).';
        END IF;

        /* Existe pero estaba inactivo => reactivar */
        IF v_Activo = 0 THEN
            UPDATE Cat_Gerencias_Activos
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatGeren = v_Id_Gerencia;

            COMMIT;
            SELECT 'Gerencia reactivada exitosamente' AS Mensaje,
                   v_Id_Gerencia AS Id_Gerencia,
                   _Id_Subdireccion AS Id_Subdireccion,
                   _Id_Direccion_Seleccionada AS Id_Direccion,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Existe y está activo => alta bloqueada */
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe una Gerencia ACTIVA con esa Clave en la Subdirección seleccionada.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) BUSCAR POR NOMBRE DENTRO DE LA SUBDIRECCIÓN (SEGUNDA REGLA)
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Gerencia = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatGeren, Clave, Nombre, Activo
      INTO v_Id_Gerencia, v_Clave, v_Nombre, v_Activo
    FROM Cat_Gerencias_Activos
    WHERE Nombre = _Nombre
      AND Fk_Id_CatSubDirec = _Id_Subdireccion
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Gerencia IS NOT NULL THEN
        /* Conflicto: mismo Nombre pero distinta Clave */
        IF v_Clave <> _Clave THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Conflicto Gerencia. El Nombre ya existe pero la Clave no coincide (en esa Subdirección).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Gerencias_Activos
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatGeren = v_Id_Gerencia;

            COMMIT;
            SELECT 'Gerencia reactivada exitosamente' AS Mensaje,
                   v_Id_Gerencia AS Id_Gerencia,
                   _Id_Subdireccion AS Id_Subdireccion,
                   _Id_Direccion_Seleccionada AS Id_Direccion,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'ERROR: Ya existe una Gerencia ACTIVA con ese Nombre en la Subdirección seleccionada.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) INSERT FINAL
       - Aquí puede aparecer el 1062 por carrera (dos usuarios insertando al mismo tiempo).
       - Reiniciamos v_Dup antes del INSERT.
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    INSERT INTO Cat_Gerencias_Activos (Clave, Nombre, Fk_Id_CatSubDirec)
    VALUES (_Clave, _Nombre, _Id_Subdireccion);

    /* Si el INSERT NO disparó 1062 => CREADA */
    IF v_Dup = 0 THEN
        COMMIT;
        SELECT 'Gerencia registrada exitosamente' AS Mensaje,
               LAST_INSERT_ID() AS Id_Gerencia,
               _Id_Subdireccion AS Id_Subdireccion,
               _Id_Direccion_Seleccionada AS Id_Direccion,
               'CREADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ========================================================================================
       SI LLEGAMOS AQUÍ: HUBO 1062 EN EL INSERT
       => ALGUIEN INSERTÓ PRIMERO (CONCURRENCIA / DOBLE SUBMIT)
       => RE-RESOLVE: localizar y devolver REUSADA/REACTIVADA (UX limpia)
       ======================================================================================== */
    ROLLBACK;

    /* Nueva transacción:
       - evitar quedarnos con locks del intento fallido
       - bloquear la fila real con FOR UPDATE si hay que reactivar */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE A) Localizar por CLAVE dentro de la Subdirección (más determinístico por UNIQUE)
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Gerencia = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatGeren, Clave, Nombre, Activo
      INTO v_Id_Gerencia, v_Clave, v_Nombre, v_Activo
    FROM Cat_Gerencias_Activos
    WHERE Clave = _Clave
      AND Fk_Id_CatSubDirec = _Id_Subdireccion
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Gerencia IS NOT NULL THEN
        /* Si el “ganador” tiene otro Nombre => conflicto real */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Clave existe con otro Nombre (en esa Subdirección).';
        END IF;

        /* Si por alguna razón estaba inactivo => reactivar */
        IF v_Activo = 0 THEN
            UPDATE Cat_Gerencias_Activos
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatGeren = v_Id_Gerencia;

            COMMIT;
            SELECT 'Gerencia reactivada (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Gerencia AS Id_Gerencia,
                   _Id_Subdireccion AS Id_Subdireccion,
                   _Id_Direccion_Seleccionada AS Id_Direccion,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        /* Ya existe activo => REUSADA (sin error al usuario) */
        COMMIT;
        SELECT 'Gerencia ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Gerencia AS Id_Gerencia,
               _Id_Subdireccion AS Id_Subdireccion,
               _Id_Direccion_Seleccionada AS Id_Direccion,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       RE-RESOLVE B) Si no aparece por Clave, buscar por NOMBRE dentro de la Subdirección
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Gerencia = NULL; 
    SET v_Clave = NULL; 
    SET v_Nombre = NULL; 
    SET v_Activo = NULL;

    SELECT Id_CatGeren, Clave, Nombre, Activo
      INTO v_Id_Gerencia, v_Clave, v_Nombre, v_Activo
    FROM Cat_Gerencias_Activos
    WHERE Nombre = _Nombre
      AND Fk_Id_CatSubDirec = _Id_Subdireccion
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Gerencia IS NOT NULL THEN
        IF v_Clave <> _Clave THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada pero hay conflicto: Nombre existe con otra Clave (en esa Subdirección).';
        END IF;

        IF v_Activo = 0 THEN
            UPDATE Cat_Gerencias_Activos
            SET Activo = 1,
                updated_at = NOW()
            WHERE Id_CatGeren = v_Id_Gerencia;

            COMMIT;
            SELECT 'Gerencia reactivada (re-resuelto por concurrencia)' AS Mensaje,
                   v_Id_Gerencia AS Id_Gerencia,
                   _Id_Subdireccion AS Id_Subdireccion,
                   _Id_Direccion_Seleccionada AS Id_Direccion,
                   'REACTIVADA' AS Accion;
            LEAVE SP;
        END IF;

        COMMIT;
        SELECT 'Gerencia ya existía (reusado por concurrencia)' AS Mensaje,
               v_Id_Gerencia AS Id_Gerencia,
               _Id_Subdireccion AS Id_Subdireccion,
               _Id_Direccion_Seleccionada AS Id_Direccion,
               'REUSADA' AS Accion;
        LEAVE SP;
    END IF;

    /* Caso ultra raro: 1062 ocurrió pero no encontramos la fila */
    SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Concurrencia detectada (1062) pero no se pudo localizar la Gerencia. Refresca y reintenta.';

END$$

DELIMITER ;

/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarDepartamento
   ============================================================================================
   OBJETIVO
   --------
   Registrar un nuevo Departamento en el catálogo corporativo, garantizando la integridad
   referencial con su ubicación geográfica y aplicando reglas de unicidad flexibles.

   ESTRATEGIA DE IDENTIDAD (LA "TRIPLE RESTRICCIÓN")
   -------------------------------------------------
   A diferencia de los Centros de Trabajo (donde el Código es único globalmente), los 
   Departamentos siguen una lógica de identidad compuesta.
   
   La identidad única se define por la combinación exacta de tres factores:
      1. CÓDIGO (Ej: 'DEP-RH')
      2. NOMBRE (Ej: 'Recursos Humanos')
      3. MUNICIPIO (Ej: ID 45 - Villahermosa)

   ¿Por qué?
   - Esto permite que exista el departamento 'DEP-RH' en Villahermosa y TAMBIÉN el
     'DEP-RH' en Paraíso. Son entidades distintas operativamente.
   - Sin embargo, bloquea que existan DOS 'DEP-RH' en Villahermosa (Duplicado real).

   REGLAS DE NEGOCIO (EL CONTRATO)
   -------------------------------
   1. INTEGRIDAD DEL PADRE (MUNICIPIO):
      - El Departamento DEBE anclarse a un Municipio existente y ACTIVO.
      - Se aplica un BLOQUEO DE LECTURA (FOR UPDATE) al registro del Municipio durante la
        transacción para evitar que sea desactivado por otro administrador mientras
        estamos registrando hijos en él.

   2. AUTO-SANACIÓN DE DATOS (SELF-HEALING):
      - Si el sistema detecta que el departamento YA EXISTÍA pero estaba eliminado lógicamente
        (Estatus = 0), no solo lo reactiva.
      - También verifica si el usuario envió una nueva `Direccion_Fisica`. Si es así,
        ACTUALIZA ese dato al reactivar el registro.
      - Esto mantiene la base de datos fresca sin obligar al usuario a ir a "Editar" después.

   3. MANEJO DE CONCURRENCIA (RACE CONDITIONS - ERROR 1062):
      - Escenario: Dos usuarios (A y B) envían el registro del mismo departamento al mismo tiempo.
      - Ambos pasan la validación de "No existe". Ambos intentan el INSERT.
      - Uno gana. El otro recibe un error nativo de MySQL (1062 Duplicate Entry).
      - SOLUCIÓN: Usamos un HANDLER para atrapar ese error, hacer ROLLBACK silencioso,
        buscar el registro que acaba de crear el "ganador" y devolverlo como éxito.
      - Resultado: Cero errores técnicos en pantalla para el usuario final.

   RETORNO
   -------
   Devuelve una tabla con:
      - Mensaje: Texto amigable para notificación UI.
      - Id_Departamento: La llave primaria (Nueva o Reutilizada).
      - Accion: 'CREADA', 'REACTIVADA', 'REUSADA'.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarDepartamento`$$
CREATE PROCEDURE `SP_RegistrarDepartamento`(
    IN _Codigo           VARCHAR(50),
    IN _Nombre           VARCHAR(255),
    IN _Direccion_Fisica VARCHAR(255),
    IN _Id_Municipio     INT
)
SP: BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES DE ESTADO Y CONTROL
       ---------------------------------------------------------------------------------------- */
    /* Para almacenar datos del registro encontrado (si existe) */
    DECLARE v_Id_Dep     INT DEFAULT NULL;
    DECLARE v_Activo     TINYINT(1) DEFAULT NULL;
    
    /* Para validación del Padre (Municipio) */
    DECLARE v_Mun_Existe INT DEFAULT NULL;
    DECLARE v_Mun_Activo TINYINT(1) DEFAULT NULL;

    /* Bandera para control de flujo en Concurrencia */
    DECLARE v_Dup        TINYINT(1) DEFAULT 0;

    /* ----------------------------------------------------------------------------------------
       HANDLERS (MANEJO DE EXCEPCIONES)
       ---------------------------------------------------------------------------------------- */
    
    /* HANDLER 1062: Duplicate Entry
       Este es el corazón de la tolerancia a concurrencia. Si el INSERT falla por duplicado,
       el código NO se detiene; se activa la bandera v_Dup = 1 y continuamos. */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* HANDLER SQLEXCEPTION: Fallos Generales
       Cualquier otro error (disco lleno, desconexión, sintaxis) aborta la transacción. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN Y LIMPIEZA DE INPUTS
       ---------------------------------------------------------------------------------------- */
    SET _Codigo           = NULLIF(TRIM(_Codigo), '');
    SET _Nombre           = NULLIF(TRIM(_Nombre), '');
    SET _Direccion_Fisica = NULLIF(TRIM(_Direccion_Fisica), '');
    
    /* Protección contra IDs inválidos (0 o negativos se tratan como NULL) */
    IF _Id_Municipio <= 0 THEN SET _Id_Municipio = NULL; END IF;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE ENTRADA (FAIL FAST)
       ---------------------------------------------------------------------------------------- */
    IF _Codigo IS NULL OR _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El Código y el Nombre son obligatorios.';
    END IF;

    IF _Id_Municipio IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: Debe seleccionar un Municipio válido.';
    END IF;

    /* ========================================================================================
       INICIO DE LA TRANSACCIÓN
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1) VALIDAR INTEGRIDAD DEL PADRE (MUNICIPIO)
       ----------------------------------------------------------------------------------------
       Usamos `FOR UPDATE` para bloquear la fila del Municipio.
       Esto previene la condición de carrera donde un Admin A registra un departamento mientras
       un Admin B desactiva el municipio al mismo tiempo. */
    
    SELECT 1, `Activo` 
      INTO v_Mun_Existe, v_Mun_Activo
    FROM `Municipio`
    WHERE `Id_Municipio` = _Id_Municipio
    LIMIT 1
    FOR UPDATE;

    IF v_Mun_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD: El Municipio seleccionado no existe en el catálogo.';
    END IF;

    IF v_Mun_Activo = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO: El Municipio seleccionado está INACTIVO. No es posible registrar nuevos Departamentos en él.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) VERIFICACIÓN DE EXISTENCIA (LA TRIPLE RESTRICCIÓN)
       ----------------------------------------------------------------------------------------
       Buscamos una coincidencia EXACTA de la triada: [Código + Nombre + Municipio].
       También usamos `FOR UPDATE` para serializar el acceso a este registro si ya existe. */
    
    SET v_Id_Dep = NULL;
    
    SELECT `Id_CatDep`, `Activo` 
      INTO v_Id_Dep, v_Activo
    FROM `Cat_Departamentos`
    WHERE `Codigo` = _Codigo 
      AND `Nombre` = _Nombre 
      AND `Fk_Id_Municipio_CatDep` = _Id_Municipio
    LIMIT 1 
    FOR UPDATE;

    /* SI EL REGISTRO YA EXISTE... */
    IF v_Id_Dep IS NOT NULL THEN
        
        /* CASO 2.1: Existe pero estaba eliminado lógicamente (Activo = 0) -> REACTIVAR */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Departamentos` 
            SET `Activo` = 1, 
                /* Lógica de Autosanación:
                   Si el usuario envió una dirección física nueva, actualizamos el dato viejo.
                   Si envió NULL, mantenemos la dirección antigua. */
                `Direccion_Fisica` = COALESCE(_Direccion_Fisica, `Direccion_Fisica`), 
                `updated_at` = NOW() 
            WHERE `Id_CatDep` = v_Id_Dep;
            
            COMMIT; 
            SELECT 'Departamento reactivado exitosamente.' AS Mensaje, 
                   v_Id_Dep AS Id_Departamento, 
                   'REACTIVADA' AS Accion; 
            LEAVE SP;
        
        ELSE
            /* CASO 2.2: Existe y ya estaba activo -> IDEMPOTENCIA (No hacemos nada, reportamos éxito) */
            COMMIT; 
            SELECT 'El Departamento ya existe con esos datos en este Municipio.' AS Mensaje, 
                   v_Id_Dep AS Id_Departamento, 
                   'REUSADA' AS Accion; 
            LEAVE SP;
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) INSERTAR (CREACIÓN DE NUEVO REGISTRO)
       ----------------------------------------------------------------------------------------
       Si llegamos aquí, no encontramos coincidencias. Procedemos a insertar.
       Aquí podría saltar el Error 1062 si alguien insertó milisegundos antes. */
    
    SET v_Dup = 0; /* Reset de bandera */
    
    INSERT INTO `Cat_Departamentos` 
        (`Codigo`, `Nombre`, `Direccion_Fisica`, `Fk_Id_Municipio_CatDep`)
    VALUES 
        (_Codigo, _Nombre, _Direccion_Fisica, _Id_Municipio);

    /* Verificamos si la bandera v_Dup sigue en 0 (Éxito) */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'Departamento registrado exitosamente.' AS Mensaje, 
               LAST_INSERT_ID() AS Id_Departamento, 
               'CREADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* ========================================================================================
       PASO 4) RE-RESOLVE (MANEJO AVANZADO DE CONCURRENCIA)
       ========================================================================================
       Si llegamos aquí, v_Dup = 1. Significa que el INSERT falló por duplicado (1062).
       Otro usuario ganó la carrera. Debemos recuperar ese ID y devolverlo limpiamente. */
    
    ROLLBACK; /* Revertimos nuestra transacción fallida para limpiar bloqueos */
    
    START TRANSACTION; /* Iniciamos una nueva para buscar al ganador */
    
    SET v_Id_Dep = NULL;
    
    /* Buscamos de nuevo (ahora sí debe aparecer) */
    SELECT `Id_CatDep`, `Activo` 
      INTO v_Id_Dep, v_Activo
    FROM `Cat_Departamentos` 
    WHERE `Codigo` = _Codigo 
      AND `Nombre` = _Nombre 
      AND `Fk_Id_Municipio_CatDep` = _Id_Municipio
    LIMIT 1 
    FOR UPDATE;

    IF v_Id_Dep IS NOT NULL THEN
        /* Si el ganador estaba inactivo, lo reactivamos nosotros */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Departamentos` SET `Activo` = 1, `updated_at` = NOW() WHERE `Id_CatDep` = v_Id_Dep;
            COMMIT; 
            SELECT 'Departamento reactivado (recuperado tras concurrencia).' AS Mensaje, 
                   v_Id_Dep AS Id_Departamento, 
                   'REACTIVADA' AS Accion; 
            LEAVE SP;
        END IF;

        /* Si estaba activo, simplemente lo reusamos */
        COMMIT; 
        SELECT 'Departamento ya existía (reusado tras concurrencia).' AS Mensaje, 
               v_Id_Dep AS Id_Departamento, 
               'REUSADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO FINAL: EXCEPCIÓN DE SISTEMA
       Si falló el insert por duplicado (1062) PERO luego no encontramos el registro,
       estamos ante un error de corrupción de índices o comportamiento anómalo grave. */
    SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR CRÍTICO DE SISTEMA: Fallo de concurrencia no recuperable (Error Fantasma). Contacte a Soporte.';

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarCentroTrabajo
   ============================================================================================
   OBJETIVO
   --------
   Registrar un nuevo Centro de Trabajo (CT) en el catálogo, asegurando la consistencia total 
   de los datos y manejando escenarios complejos de duplicidad y concurrencia.

   REGLAS DE NEGOCIO (EL CONTRATO)
   -------------------------------
   1. INTEGRIDAD DEL PADRE (MUNICIPIO):
      - El Centro de Trabajo DEBE pertenecer a un Municipio válido y ACTIVO.
      - Se aplica un bloqueo de lectura (FOR UPDATE) al Municipio para asegurar que
        nadie lo desactive justo en el milisegundo en que estamos registrando el CT.

   2. IDENTIDAD PRIMARIA (CÓDIGO ÚNICO GLOBAL):
      - Regla: El campo 'Codigo' es único en toda la tabla (Constraint `Uk_Codigo_CatCT`).
      - Validación: Buscamos si el código ya existe.
      - Resolución:
         * Si existe y (Nombre + Municipio) coinciden -> REUTILIZAR/REACTIVAR.
         * Si existe y los datos NO coinciden -> ERROR (Conflicto: Código ya usado por otro CT).

   3. IDENTIDAD SECUNDARIA (NOMBRE + MUNICIPIO):
      - Regla: No pueden existir dos CTs con el mismo Nombre en el mismo Municipio
        (Constraint `Uk_Nombre_Municipio_CT`).
      - Validación: Si el código es nuevo, buscamos por Nombre + Municipio.
      - Resolución:
         * Si encontramos coincidencia -> ERROR (Conflicto: Ya existe ese lugar físico, 
           pero intentaste registrarlo con un Código diferente al que ya tiene).

   4. MANEJO DE CONCURRENCIA (RACE CONDITIONS - ERROR 1062):
      - Problema: Dos usuarios envían el mismo registro al mismo tiempo. 
        Ambos pasan los SELECT iniciales (porque no existe aún). Ambos hacen INSERT.
        Uno gana, el otro falla con error 1062 (Duplicate Key).
      - Solución (Re-Resolve):
        El SP atrapa el error 1062, hace rollback silencioso, busca el registro que acaba
        de crear el otro usuario y lo devuelve como "REUSADA" o "REACTIVADA".
        El usuario final nunca ve un error técnico.

   RESULTADO
   ---------
   Retorna:
     - Mensaje (Feedback para el usuario)
     - Id_CatCT (El ID del registro, sea nuevo o reutilizado)
     - Accion ('CREADA', 'REACTIVADA', 'REUSADA')
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarCentroTrabajo`$$
CREATE PROCEDURE `SP_RegistrarCentroTrabajo`(
    IN _Codigo           VARCHAR(50),
    IN _Nombre           VARCHAR(255),
    IN _Direccion_Fisica VARCHAR(255),
    IN _Id_Municipio     INT
)
SP: BEGIN
    /* ----------------------------------------------------------------------------------------
       VARIABLES DE TRABAJO
       ---------------------------------------------------------------------------------------- */
    /* Para almacenar datos del registro encontrado (si existe) */
    DECLARE v_Id_CT         INT DEFAULT NULL;
    DECLARE v_Codigo        VARCHAR(50) DEFAULT NULL;
    DECLARE v_Nombre        VARCHAR(255) DEFAULT NULL;
    DECLARE v_Id_Mun        INT DEFAULT NULL;
    DECLARE v_Activo        TINYINT(1) DEFAULT NULL;

    /* Para validación del Municipio (Padre) */
    DECLARE v_Mun_Existe    INT DEFAULT NULL;
    DECLARE v_Mun_Activo    TINYINT(1) DEFAULT NULL;

    /* Bandera para detectar error de concurrencia (1062) */
    DECLARE v_Dup           TINYINT(1) DEFAULT 0;

    /* ----------------------------------------------------------------------------------------
       HANDLERS (MANEJO DE ERRORES)
       ---------------------------------------------------------------------------------------- */
    /* 1. Handler para Duplicados (1062):
          Evita que el SP aborte. Marca la bandera v_Dup para que podamos manejarlo. */
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_Dup = 1;
    END;

    /* 2. Handler Genérico (SQLEXCEPTION):
          Para cualquier otro error (ej: conexión, disco lleno), hacemos Rollback y salimos. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    /* ----------------------------------------------------------------------------------------
       NORMALIZACIÓN Y LIMPIEZA DE DATOS
       ---------------------------------------------------------------------------------------- */
    SET _Codigo           = NULLIF(TRIM(_Codigo), '');
    SET _Nombre           = NULLIF(TRIM(_Nombre), '');
    SET _Direccion_Fisica = NULLIF(TRIM(_Direccion_Fisica), '');
    
    /* Si envían 0 o negativo como ID, lo tratamos como NULL */
    IF _Id_Municipio <= 0 THEN SET _Id_Municipio = NULL; END IF;

    /* ----------------------------------------------------------------------------------------
       VALIDACIONES DE ENTRADA (OBLIGATORIOS)
       ---------------------------------------------------------------------------------------- */
    IF _Codigo IS NULL OR _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Código y Nombre del Centro de Trabajo son obligatorios.';
    END IF;

    IF _Id_Municipio IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Debe seleccionar un Municipio válido.';
    END IF;

    /* ========================================================================================
       INICIO DE LA TRANSACCIÓN
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 1) VALIDAR INTEGRIDAD DEL PADRE (MUNICIPIO)
       - Usamos FOR UPDATE para bloquear la fila del municipio.
       - Esto asegura que nadie lo desactive o elimine mientras nosotros registramos al hijo.
       ---------------------------------------------------------------------------------------- */
    SET v_Mun_Existe = NULL;
    
    SELECT 1, `Activo` 
      INTO v_Mun_Existe, v_Mun_Activo
    FROM `Municipio`
    WHERE `Id_Municipio` = _Id_Municipio
    LIMIT 1
    FOR UPDATE;

    IF v_Mun_Existe IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El Municipio seleccionado no existe.';
    END IF;

    IF v_Mun_Activo = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: El Municipio seleccionado está INACTIVO. No se pueden registrar Centros de Trabajo en él.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 2) RESOLVER POR CÓDIGO (REGLA PRIMARIA - GLOBAL UNIQUE)
       - Buscamos si el Código ya existe en el sistema.
       - Si existe, verificamos consistencia con Nombre y Municipio.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_CT = NULL, v_Nombre = NULL, v_Id_Mun = NULL, v_Activo = NULL;

    SELECT `Id_CatCT`, `Nombre`, `Fk_Id_Municipio_CatCT`, `Activo`
      INTO v_Id_CT, v_Nombre, v_Id_Mun, v_Activo
    FROM `Cat_Centros_Trabajo`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;

    IF v_Id_CT IS NOT NULL THEN
        /* 2.1) Validar Consistencia de Nombre */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto de Datos. El Código ya existe pero pertenece a un Centro con diferente Nombre.';
        END IF;

        /* 2.2) Validar Consistencia de Municipio (usamos <=> para comparar NULLs de forma segura) */
        IF NOT (v_Id_Mun <=> _Id_Municipio) THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto de Datos. El Código ya existe pero está asignado a un Municipio diferente.';
        END IF;

        /* 2.3) Autosanación: Reactivar si estaba borrado, o Reusar si está activo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Centros_Trabajo` 
            SET `Activo` = 1, 
                `Direccion_Fisica` = COALESCE(_Direccion_Fisica, `Direccion_Fisica`), /* Actualiza dirección solo si enviaron una nueva */
                `updated_at` = NOW() 
            WHERE `Id_CatCT` = v_Id_CT;
            
            COMMIT; 
            SELECT 'Centro de Trabajo reactivado exitosamente' AS Mensaje, v_Id_CT AS Id_CatCT, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        ELSE
            COMMIT; 
            SELECT 'El Centro de Trabajo ya existe y está activo.' AS Mensaje, v_Id_CT AS Id_CatCT, 'REUSADA' AS Accion; 
            LEAVE SP;
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3) RESOLVER POR NOMBRE + MUNICIPIO (REGLA SECUNDARIA)
       - Si llegamos aquí, el Código es NUEVO.
       - Ahora verificamos: ¿Ya existe un CT con ese Nombre en ese Municipio?
       ---------------------------------------------------------------------------------------- */
    SET v_Id_CT = NULL, v_Codigo = NULL, v_Activo = NULL;

    SELECT `Id_CatCT`, `Codigo`, `Activo`
      INTO v_Id_CT, v_Codigo, v_Activo
    FROM `Cat_Centros_Trabajo`
    WHERE `Nombre` = _Nombre
      AND `Fk_Id_Municipio_CatCT` = _Id_Municipio /* Comparación estricta porque Id_Mun es obligatorio aquí */
    LIMIT 1
    FOR UPDATE;

    IF v_Id_CT IS NOT NULL THEN
        /* Conflicto Lógico: El lugar ya existe (Nombre+Mun), pero el usuario mandó un código diferente. */
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR: Conflicto de Datos. Ya existe un Centro de Trabajo con ese Nombre en este Municipio, pero tiene un Código diferente.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4) INSERTAR (CREACIÓN)
       - Si pasamos las validaciones, procedemos al INSERT.
       - No incluimos 'Activo' (la tabla pone 1 por default).
       - No incluimos 'created_at' (la tabla pone timestamp por default).
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0;

    INSERT INTO `Cat_Centros_Trabajo` 
        (`Codigo`, `Nombre`, `Direccion_Fisica`, `Fk_Id_Municipio_CatCT`)
    VALUES 
        (_Codigo, _Nombre, _Direccion_Fisica, _Id_Municipio);

    /* Si v_Dup sigue en 0, el insert fue exitoso */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'Centro de Trabajo registrado exitosamente' AS Mensaje, 
               LAST_INSERT_ID() AS Id_CatCT, 
               'CREADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* ========================================================================================
       PASO 5) RE-RESOLVE (MANEJO AVANZADO DE CONCURRENCIA - ERROR 1062)
       - Si llegamos aquí, v_Dup = 1.
       - Significa que entre nuestros SELECTs y nuestro INSERT, alguien más insertó el registro.
       - Estrategia: ROLLBACK para limpiar y buscar al ganador.
       ======================================================================================== */
    ROLLBACK;
    
    START TRANSACTION;

    /* 5.1) Intento de Recuperación: Buscar por Código (lo más probable en race condition) */
    SET v_Id_CT = NULL, v_Activo = NULL, v_Nombre = NULL;

    SELECT `Id_CatCT`, `Activo`, `Nombre`
      INTO v_Id_CT, v_Activo, v_Nombre
    FROM `Cat_Centros_Trabajo`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;

    IF v_Id_CT IS NOT NULL THEN
        /* Verificación paranoica: asegurarnos que sea el mismo dato lógico */
        IF v_Nombre <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO: Concurrencia detectada con conflicto de datos (Código duplicado con diferente nombre).';
        END IF;

        /* Reactivar si es necesario */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Centros_Trabajo` SET `Activo` = 1, `updated_at` = NOW() WHERE `Id_CatCT` = v_Id_CT;
            COMMIT; 
            SELECT 'Centro de Trabajo reactivado (re-resuelto)' AS Mensaje, v_Id_CT AS Id_CatCT, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        END IF;

        /* Reusar */
        COMMIT; 
        SELECT 'Centro de Trabajo ya existía (reusado por concurrencia)' AS Mensaje, v_Id_CT AS Id_CatCT, 'REUSADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* 5.2) Si no lo encontramos tras el fallo 1062, es un error fatal de sistema */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: Fallo de concurrencia no recuperable (1062 sin registro visible).';

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarSede
   ============================================================================================
   OBJETIVO DE NEGOCIO
   -------------------
   Registrar una nueva Sede (CASES) en el catálogo corporativo, gestionando integralmente:
     1. Identidad Administrativa (Código y Nombre únicos).
     2. Ubicación Geográfica (Integridad con Municipios).
     3. Capacidad Instalada (Inventario de infraestructura).

   REGLAS CRÍTICAS (EL CONTRATO DE INTEGRIDAD)
   -------------------------------------------
   A) IDENTIDAD GLOBAL (DOBLE UNICIDAD):
      La tabla `Cat_Cases_Sedes` tiene dos restricciones UNIQUE fuertes:
      1. `Uk_Codigo`: No pueden existir dos sedes con el mismo Código (ej: 'CASES-01').
      2. `Uk_Nombre`: No pueden existir dos sedes con el mismo Nombre (ej: 'CASES PARAISO').
      
      Estrategia de Resolución:
      - Primero buscamos por CÓDIGO (Regla Primaria).
      - Si no existe, buscamos por NOMBRE (Regla Secundaria).
      - Si encontramos coincidencia cruzada (ej: Nombre existe pero con otro Código), 
        se lanza un ERROR DE CONFLICTO para evitar corrupción de datos.

   B) INTEGRIDAD DEL PADRE (UBICACIÓN):
      - Una Sede no puede existir en el vacío. Debe estar anclada a un MUNICIPIO ACTIVO.
      - Se aplica BLOQUEO PESIMISTA (`FOR UPDATE`) al registro del Municipio.
      - Esto evita la condición de carrera donde un Administrador desactiva el Municipio 
        en el preciso instante en que estamos registrando una Sede en él.

   C) MANEJO DE INVENTARIO (SANITIZACIÓN DE NULOS):
      - Los campos de infraestructura (Aulas, Salas, Albercas, etc.) son contadores.
      - Regla: "La ausencia de dato equivale a cero".
      - El SP intercepta cualquier `NULL` enviado por el Frontend y lo convierte a `0` 
        antes de guardar. Esto garantiza que las sumas y reportes futuros no fallen.

   D) CONCURRENCIA AVANZADA (EL PATRÓN "RE-RESOLVE"):
      - Problema: Dos usuarios envían el registro de la misma Sede simultáneamente.
        Ambos pasan las validaciones de lectura (SELECT). Ambos intentan INSERT.
        Uno gana, el otro falla con Error 1062 (Duplicate Key).
      - Solución: 
        1. Atrapamos el error 1062 con un HANDLER.
        2. Hacemos ROLLBACK silencioso.
        3. Iniciamos nueva transacción y buscamos el registro que acaba de crear el "ganador".
        4. Devolvemos éxito ('REUSADA' o 'REACTIVADA') en lugar de un error técnico.

   RESULTADO
   ---------
   Retorna una tabla con:
     - Mensaje: Feedback legible para el usuario.
     - Id_Sede: El ID del registro (nuevo o recuperado).
     - Accion: 'CREADA', 'REACTIVADA', 'REUSADA'.
============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarSede`$$
CREATE PROCEDURE `SP_RegistrarSede`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA
       ----------------------------------------------------------------- */
    /* BLOQUE 1: IDENTIDAD Y UBICACIÓN (Datos Obligatorios) */
    IN _Codigo               VARCHAR(50),   -- Clave única (ej: 'CASES-TAB-01')
    IN _Nombre               VARCHAR(255),  -- Nombre descriptivo único
    IN _DescripcionDireccion VARCHAR(255),  -- Dirección física (Calle/Número)
    IN _Id_Municipio         INT,           -- FK hacia Municipio
    
    /* BLOQUE 2: INFRAESTRUCTURA (Inventario Variable - Opcionales)
       Nota: Si el frontend envía NULL, se asume 0. */
    IN _Capacidad_Total      INT,
    IN _Aulas                TINYINT,
    IN _Salas                TINYINT,
    IN _Alberca              TINYINT,
    IN _CampoPracticas       TINYINT,
    IN _Muelle               TINYINT,
    IN _BotesCapacidad       TINYINT
)
SP: BEGIN
    /* ========================================================================================
       VARIABLES DE TRABAJO
       ======================================================================================== */
    /* Para almacenar el estado del registro si ya existe */
    DECLARE v_Id_Sede INT DEFAULT NULL;
    DECLARE v_Activo  TINYINT(1) DEFAULT NULL;
    DECLARE v_Nombre  VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo  VARCHAR(50) DEFAULT NULL;
    
    /* Para validación del Padre (Municipio) */
    DECLARE v_Mun_Existe INT DEFAULT NULL;
    DECLARE v_Mun_Activo TINYINT(1) DEFAULT NULL;
    
    /* Bandera para control de flujo en Concurrencia (Error 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ========================================================================================
       HANDLERS (MANEJO DE EXCEPCIONES TÉCNICAS)
       ======================================================================================== */
    
    /* HANDLER 1062: Duplicate Entry
       Este es el corazón de la tolerancia a concurrencia. Si el INSERT falla por duplicado,
       el código NO se detiene; se activa la bandera v_Dup = 1 y continuamos hacia el bloque de resolución. */
    DECLARE CONTINUE HANDLER FOR 1062 
    BEGIN
        SET v_Dup = 1;
    END;

    /* HANDLER SQLEXCEPTION: Fallos Generales
       Cualquier otro error (disco lleno, desconexión, sintaxis) aborta la transacción inmediatamente. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       PARTE 1: NORMALIZACIÓN Y SANITIZACIÓN DE INPUTS
       ======================================================================================== */
    
    /* 1.1 Limpieza de Strings (Trim de espacios) */
    SET _Codigo               = NULLIF(TRIM(_Codigo), '');
    SET _Nombre               = NULLIF(TRIM(_Nombre), '');
    SET _DescripcionDireccion = NULLIF(TRIM(_DescripcionDireccion), '');
    
    /* 1.2 Sanitización de Infraestructura (Lógica de Negocio: NULL -> 0)
       Esto asegura que la tabla siempre tenga valores numéricos válidos (NOT NULL DEFAULT 0). */
    SET _Capacidad_Total = IFNULL(_Capacidad_Total, 0);
    SET _Aulas           = IFNULL(_Aulas, 0);
    SET _Salas           = IFNULL(_Salas, 0);
    SET _Alberca         = IFNULL(_Alberca, 0);
    SET _CampoPracticas  = IFNULL(_CampoPracticas, 0);
    SET _Muelle          = IFNULL(_Muelle, 0);
    SET _BotesCapacidad  = IFNULL(_BotesCapacidad, 0);

    /* ========================================================================================
       PARTE 2: VALIDACIONES DE ENTRADA (FAIL FAST)
       ======================================================================================== */
    
    /* Regla: El Código es Obligatorio (Llave de búsqueda rápida) */
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El CÓDIGO de la Sede es obligatorio.';
    END IF;

    /* Regla: El Nombre es Obligatorio (Identidad humana) */
    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El NOMBRE de la Sede es obligatorio.';
    END IF;

    /* Regla: La Ubicación es Obligatoria */
    IF _Id_Municipio IS NULL OR _Id_Municipio <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: Debe seleccionar un MUNICIPIO válido.';
    END IF;

    /* ========================================================================================
       INICIO DE LA TRANSACCIÓN
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3: VALIDAR INTEGRIDAD DEL MUNICIPIO (PADRE)
       ----------------------------------------------------------------------------------------
       Usamos `FOR UPDATE` para bloquear la fila del Municipio.
       Esto previene la condición de carrera donde un usuario desactiva el municipio
       mientras nosotros intentamos registrar una sede en él. */
    
    SELECT 1, `Activo` 
    INTO v_Mun_Existe, v_Mun_Activo
    FROM `Municipio` 
    WHERE `Id_Municipio` = _Id_Municipio 
    LIMIT 1 
    FOR UPDATE;

    IF v_Mun_Existe IS NULL THEN 
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD: El Municipio seleccionado no existe en el catálogo.'; 
    END IF;
    
    IF v_Mun_Activo = 0 THEN 
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO: El Municipio seleccionado está INACTIVO. No se pueden registrar Sedes en una ubicación cerrada.'; 
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 4: RESOLVER POR CÓDIGO (REGLA DE UNICIDAD PRIMARIA)
       ----------------------------------------------------------------------------------------
       Buscamos si el Código (_Codigo) ya existe en la base de datos.
       Constraint implicado: `Uk_Codigo_CatCases_Sedes` */
    
    SET v_Id_Sede = NULL;
    
    SELECT `Id_CatCases_Sedes`, `Nombre`, `Activo` 
    INTO v_Id_Sede, v_Nombre, v_Activo
    FROM `Cat_Cases_Sedes` 
    WHERE `Codigo` = _Codigo 
    LIMIT 1 
    FOR UPDATE; -- Bloqueamos para evitar cambios simultáneos

    /* CASO 4.1: EL CÓDIGO YA EXISTE */
    IF v_Id_Sede IS NOT NULL THEN
        
        /* Validación de Consistencia de Identidad:
           Si el código existe, el Nombre TAMBIÉN debe coincidir.
           Si el código es igual pero el nombre es diferente, es un CONFLICTO DE DATOS. */
        IF v_Nombre <> _Nombre THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'ERROR DE CONFLICTO: El CÓDIGO ingresado ya existe pero pertenece a una Sede con diferente NOMBRE. Verifique sus datos.';
        END IF;
        
        /* Autosanación: Reactivar si estaba borrado lógicamente */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Cases_Sedes`
            SET `Activo` = 1,
                `DescripcionDireccion`       = COALESCE(_DescripcionDireccion, `DescripcionDireccion`),
                /* AL REACTIVAR, ACTUALIZAMOS EL INVENTARIO CON LOS DATOS NUEVOS */
                `Capacidad_Total`            = _Capacidad_Total,
                `Aulas`                      = _Aulas,
                `Salas`                      = _Salas,
                `Alberca`                    = _Alberca,
                `CampoPracticas_Escenario`   = _CampoPracticas,
                `Muelle_Entrenamiento_Botes` = _Muelle,
                `BoteSalvavida_Capacidad`    = _BotesCapacidad,
                `updated_at`                 = NOW()
            WHERE `Id_CatCases_Sedes` = v_Id_Sede;
            
            COMMIT; 
            SELECT 'Sede reactivada y actualizada exitosamente' AS Mensaje, v_Id_Sede AS Id_Sedes, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        ELSE
            /* Si ya existe y está activa -> Idempotencia (No hacemos nada, reportamos éxito) */
            COMMIT; 
            SELECT 'La Sede ya se encuentra registrada y activa.' AS Mensaje, v_Id_Sede AS Id_Sedes, 'REUSADA' AS Accion; 
            LEAVE SP;
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 5: RESOLVER POR NOMBRE (REGLA DE UNICIDAD SECUNDARIA)
       ----------------------------------------------------------------------------------------
       Si llegamos aquí, el CÓDIGO es nuevo (no existe).
       Ahora verificamos: ¿Ya existe una Sede con ese NOMBRE?
       Constraint implicado: `Uk_Nombre_CatCases_Sedes` */
    
    SET v_Id_Sede = NULL;
    
    SELECT `Id_CatCases_Sedes`, `Codigo`
    INTO v_Id_Sede, v_Codigo
    FROM `Cat_Cases_Sedes` 
    WHERE `Nombre` = _Nombre 
    LIMIT 1 
    FOR UPDATE;

    /* CASO 5.1: EL NOMBRE YA EXISTE (Pero con otro Código, o no estaríamos aquí) */
    IF v_Id_Sede IS NOT NULL THEN
        /* Esto es un CONFLICTO DE IDENTIDAD grave.
           Significa que intentas registrar "CASES PARAISO" con el código "X", 
           pero ya existe "CASES PARAISO" con el código "Y". */
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'ERROR DE CONFLICTO: El NOMBRE ingresado ya existe asociado a otro CÓDIGO diferente. No se permiten nombres duplicados.';
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 6: INSERTAR (CREACIÓN DE NUEVO REGISTRO)
       ----------------------------------------------------------------------------------------
       Si pasamos las validaciones anteriores, el registro es nuevo y válido.
       Procedemos a insertar. Aquí podría saltar el Error 1062 si hay una "Race Condition". */
    
    SET v_Dup = 0; -- Reiniciamos bandera
    
    INSERT INTO `Cat_Cases_Sedes`
    (
        `Codigo`, 
        `Nombre`, 
        `DescripcionDireccion`, 
        `Fk_Id_Municipio`,
        /* Campos de Infraestructura */
        `Capacidad_Total`, 
        `Aulas`, 
        `Salas`, 
        `Alberca`, 
        `CampoPracticas_Escenario`, 
        `Muelle_Entrenamiento_Botes`, 
        `BoteSalvavida_Capacidad`
    )
    VALUES
    (
        _Codigo, 
        _Nombre, 
        _DescripcionDireccion, 
        _Id_Municipio,
        _Capacidad_Total, 
        _Aulas, 
        _Salas, 
        _Alberca, 
        _CampoPracticas, 
        _Muelle, 
        _BotesCapacidad
    );

    /* Verificamos si la inserción fue exitosa (v_Dup sigue en 0) */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'Sede registrada exitosamente' AS Mensaje, LAST_INSERT_ID() AS Id_Sedes, 'CREADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* ========================================================================================
       PASO 7: RE-RESOLVE (MANEJO AVANZADO DE CONCURRENCIA - ERROR 1062)
       ========================================================================================
       Si llegamos aquí, v_Dup = 1.
       Significa que entre nuestros SELECTs (Paso 4/5) y nuestro INSERT (Paso 6), 
       OTRO usuario insertó el registro.
       
       Estrategia: 
       1. ROLLBACK para limpiar la transacción fallida.
       2. START TRANSACTION nueva.
       3. Buscar el registro "ganador" y devolverlo limpiamente. */
    
    ROLLBACK;
    
    START TRANSACTION;
    
    /* Intentamos recuperar por CÓDIGO (Regla más fuerte) */
    SET v_Id_Sede = NULL;
    
    SELECT `Id_CatCases_Sedes`, `Activo`, `Nombre` 
    INTO v_Id_Sede, v_Activo, v_Nombre
    FROM `Cat_Cases_Sedes` 
    WHERE `Codigo` = _Codigo 
    LIMIT 1 
    FOR UPDATE;
    
    IF v_Id_Sede IS NOT NULL THEN
        /* Validación paranoica: Asegurar que el registro que ganó sea consistente */
        IF v_Nombre <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO DE SISTEMA: Concurrencia detectada con conflicto de datos (Nombres distintos).';
        END IF;

        /* Si el ganador estaba inactivo, aprovechamos para reactivarlo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Cases_Sedes` 
            SET `Activo` = 1, `updated_at` = NOW() 
            WHERE `Id_CatCases_Sedes` = v_Id_Sede;
            
            COMMIT; 
            SELECT 'Sede reactivada (recuperada tras concurrencia)' AS Mensaje, v_Id_Sede AS Id_Sedes, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        END IF;
        
        /* Si ya estaba activo, simplemente lo retornamos */
        COMMIT; 
        SELECT 'Sede ya existía (reusada tras concurrencia)' AS Mensaje, v_Id_Sede AS Id_Sedes, 'REUSADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* Si falló por 1062 pero no encontramos el registro (caso extremadamente raro) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: Fallo de concurrencia no recuperable (Error Fantasma). Contacte a Soporte.';

END$$

DELIMITER ;


/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarRegimen
   ============================================================================================ 
   1. OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------
   Gestionar el alta de un nuevo "Régimen de Trabajo" (ej: Planta, Transitorio, Confianza) en el
   Catálogo Corporativo. Este procedimiento actúa como una **Capa de Lógica de Negocio** en la base
   de datos, asegurando que solo datos completos, íntegros y únicos sean persistidos.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ---------------------------------------------------
   A) INTEGRIDAD DE DATOS (NOT NULL / NOT EMPTY):
      - Principio: "Basura que entra, basura que sale". Se prohíbe terminantemente el ingreso de
        cadenas vacías o espacios en blanco.
      - Alcance: Los campos `Código`, `Nombre` y `Descripción` son MANDATORIOS.
      - Acción: Si algún campo llega vacío tras la sanitización (`TRIM`), se aborta la operación
        con un error de validación (SQLSTATE 45000) antes de iniciar cualquier transacción.

   B) IDENTIDAD UNÍVOCA (DOBLE FACTOR):
      - Unicidad por CÓDIGO: No pueden existir dos regímenes con la clave 'CONF'.
      - Unicidad por NOMBRE: No pueden existir dos regímenes llamados 'CONFIANZA'.
      - Resolución de Conflictos: Se verifica primero el Código (Identificador fuerte) y luego
        el Nombre (Identificador semántico).

   3. ESTRATEGIA DE PERSISTENCIA Y CONCURRENCIA (ACID & RACE CONDITIONS)
   ---------------------------------------------------------------------
   A) BLOQUEO PESIMISTA (PESSIMISTIC LOCKING):
      - Se utiliza `SELECT ... FOR UPDATE` durante las verificaciones de existencia.
      - Justificación: Esto "serializa" las transacciones concurrentes sobre el mismo registro,
        evitando que dos administradores intenten crear o reactivar el mismo régimen al mismo
        milisegundo, garantizando lecturas consistentes.

   B) RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN):
      - A pesar de los bloqueos, existe una ventana infinitesimal donde un `INSERT` concurrente
        podría generar un error nativo `1062 (Duplicate Key)`.
      - Solución: Se implementa un `HANDLER` específico que captura este error, revierte la
        transacción fallida y ejecuta una rutina de búsqueda para devolver el registro que
        "ganó la carrera", simulando un éxito para el usuario final (Transparencia).

   C) AUTOSANACIÓN (SELF-HEALING / SOFT DELETE RECOVERY):
      - Si el sistema detecta que el régimen que se intenta crear YA EXISTE pero fue eliminado
        lógicamente (`Activo = 0`), no lanza error.
      - Acción: Ejecuta una reactivación automática (`UPDATE Activo = 1`) y actualiza los datos
        descriptivos con la nueva información proporcionada.

   RESULTADO (OUTPUT CONTRACT)
   ---------------------------
   Retorna un resultset con:
     - Mensaje: Feedback descriptivo para la UI.
     - Id_Regimen: La llave primaria del recurso (creado o recuperado).
     - Accion: Enumerador de estado ('CREADA', 'REACTIVADA', 'REUSADA').
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarRegimen`$$
CREATE PROCEDURE `SP_RegistrarRegimen`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Todos se asumen como Strings crudos que requieren sanitización.
       ----------------------------------------------------------------- */
    IN _Codigo      VARCHAR(50),   -- OBLIGATORIO: Clave única interna (ej: 'PLA')
    IN _Nombre      VARCHAR(255),  -- OBLIGATORIO: Nombre descriptivo (ej: 'Planta')
    IN _Descripcion VARCHAR(255)   -- OBLIGATORIO: Detalle operativo
)
SP: BEGIN
    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ENTORNO
       ======================================================================================== */
    
    /* Variables de Persistencia (Snapshot del registro en BD) */
    DECLARE v_Id_Regimen INT DEFAULT NULL;
    DECLARE v_Activo     TINYINT(1) DEFAULT NULL;
    
    /* Variables de Validación de Integridad (Para chequeos cruzados) */
    DECLARE v_Nombre_Existente VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo_Existente VARCHAR(50) DEFAULT NULL;
    
    /* Bandera de Control de Flujo (Semáforo para errores SQL) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Objetivo: Capturar colisiones de Unique Key en el INSERT.
       Acción: No abortar. Encender bandera v_Dup = 1 para activar la rutina de recuperación. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos de infraestructura (Disco lleno, Conexión perdida, Syntax Error).
       Acción: Abortar inmediatamente, deshacer cambios (ROLLBACK) y propagar el error (RESIGNAL). */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN (FAIL FAST STRATEGY)
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios al inicio/final. Si la cadena queda vacía, la convertimos a NULL
       para facilitar la validación booleana. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (Business Rule: NO VACÍOS)
       Validamos antes de abrir transacción para ahorrar recursos del servidor. */
    
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El CÓDIGO del Régimen es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El NOMBRE del Régimen es obligatorio.';
    END IF;

    IF _Descripcion IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: La DESCRIPCIÓN del Régimen es obligatoria.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: LÓGICA DE NEGOCIO TRANSACCIONAL
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RESOLUCIÓN DE IDENTIDAD POR CÓDIGO (PRIORIDAD ALTA)
       Verificamos si la clave única (_Codigo) ya está registrada.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Regimen = NULL;

    /* BLOQUEO PESIMISTA: 'FOR UPDATE' asegura que nadie modifique este registro mientras lo leemos */
    SELECT `Id_CatRegimen`, `Nombre`, `Activo` 
    INTO v_Id_Regimen, v_Nombre_Existente, v_Activo
    FROM `Cat_Regimenes_Trabajo`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;

    /* ESCENARIO A: EL CÓDIGO YA EXISTE */
    IF v_Id_Regimen IS NOT NULL THEN
        
        /* Validación de Integridad Cruzada:
           Regla: Si el código existe, el Nombre TAMBIÉN debe coincidir.
           Fallo: Si el código es igual pero el nombre es diferente, es un CONFLICTO DE DATOS. */
        IF v_Nombre_Existente <> _Nombre THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'ERROR DE CONFLICTO: El CÓDIGO ingresado ya existe pero pertenece a un Régimen con diferente NOMBRE. Verifique sus datos.';
        END IF;

        /* Sub-Escenario A.1: Existe pero está INACTIVO (Baja Lógica) -> REACTIVAR */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Regimenes_Trabajo`
            SET `Activo` = 1,
                `Descripcion` = _Descripcion, -- Actualizamos la descripción con el dato fresco
                `updated_at` = NOW()
            WHERE `Id_CatRegimen` = v_Id_Regimen;
            
            COMMIT; 
            SELECT 'Régimen reactivado y actualizado exitosamente.' AS Mensaje, v_Id_Regimen AS Id_Regimen, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        
        /* Sub-Escenario A.2: Existe y está ACTIVO -> IDEMPOTENCIA (Reportar éxito sin cambios) */
        ELSE
            COMMIT; 
            SELECT 'El Régimen ya se encuentra registrado y activo.' AS Mensaje, v_Id_Regimen AS Id_Regimen, 'REUSADA' AS Accion; 
            LEAVE SP;
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: RESOLUCIÓN DE IDENTIDAD POR NOMBRE (PRIORIDAD SECUNDARIA)
       Si llegamos aquí, el CÓDIGO es libre. Ahora verificamos si el NOMBRE ya está en uso.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Regimen = NULL;

    SELECT `Id_CatRegimen`, `Codigo`, `Activo`
    INTO v_Id_Regimen, v_Codigo_Existente, v_Activo
    FROM `Cat_Regimenes_Trabajo`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE;

    /* ESCENARIO B: EL NOMBRE YA EXISTE */
    IF v_Id_Regimen IS NOT NULL THEN
        /* Conflicto de Identidad:
           El nombre existe, pero tiene asociado OTRO código diferente al que intentamos registrar.
           (Nota: Como v_Codigo_Existente podría ser NULL en datos legacy, usamos lógica robusta) */
        
        IF v_Codigo_Existente IS NOT NULL AND v_Codigo_Existente <> _Codigo THEN
             SIGNAL SQLSTATE '45000' 
             SET MESSAGE_TEXT = 'ERROR DE CONFLICTO: El NOMBRE ingresado ya existe pero está asociado a otro CÓDIGO diferente.';
        END IF;
        
        /* Caso Especial: Enriquecimiento de Datos (Data Enrichment)
           El registro existía con Código NULL, y ahora le estamos asignando un Código válido. */
        IF v_Codigo_Existente IS NULL THEN
             UPDATE `Cat_Regimenes_Trabajo` 
             SET `Codigo` = _Codigo, `updated_at` = NOW() 
             WHERE `Id_CatRegimen` = v_Id_Regimen;
        END IF;

        /* Reactivación si estaba inactivo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Regimenes_Trabajo` 
            SET `Activo` = 1, `Descripcion` = _Descripcion, `updated_at` = NOW() 
            WHERE `Id_CatRegimen` = v_Id_Regimen;
            
            COMMIT; 
            SELECT 'Régimen reactivado exitosamente (encontrado por Nombre).' AS Mensaje, v_Id_Regimen AS Id_Regimen, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        END IF;

        COMMIT; 
        SELECT 'El Régimen ya existe (validado por Nombre).' AS Mensaje, v_Id_Regimen AS Id_Regimen, 'REUSADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.3: PERSISTENCIA (INSERCIÓN FÍSICA)
       Si pasamos todas las validaciones y no encontramos coincidencias, es un registro NUEVO.
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0; -- Reiniciamos bandera de error
    
    INSERT INTO `Cat_Regimenes_Trabajo`
    (
        `Codigo`, 
        `Nombre`, 
        `Descripcion`,
        `Activo`,
        `created_at`,
        `updated_at`
    )
    VALUES
    (
        _Codigo, 
        _Nombre, 
        _Descripcion,
        1,      -- Activo por defecto
        NOW(),  -- Fecha Creación
        NOW()   -- Fecha Actualización
    );

    /* Verificación de Éxito: Si v_Dup sigue en 0, el INSERT funcionó */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'Régimen registrado exitosamente.' AS Mensaje, LAST_INSERT_ID() AS Id_Regimen, 'CREADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* ========================================================================================
       BLOQUE 4: RUTINA DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE)
       ========================================================================================
       Si el flujo llega aquí, v_Dup = 1.
       Diagnóstico: Ocurrió una "Race Condition". Otro usuario insertó el registro milisegundos
       antes que nosotros, disparando el Error 1062 (Duplicate Key).
       
       Acción: Recuperar el ID del registro ganador y devolverlo como si fuera nuestro. */
    
    ROLLBACK; -- Limpiamos la transacción fallida
    
    START TRANSACTION; -- Iniciamos nueva lectura limpia
    
    SET v_Id_Regimen = NULL;
    
    /* Intentamos recuperar por CÓDIGO (la restricción más fuerte) */
    SELECT `Id_CatRegimen`, `Activo`, `Nombre`
    INTO v_Id_Regimen, v_Activo, v_Nombre_Existente
    FROM `Cat_Regimenes_Trabajo`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;
    
    IF v_Id_Regimen IS NOT NULL THEN
        /* Validación de Seguridad: Confirmar que no sea un falso positivo */
        IF v_Nombre_Existente <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO DE SISTEMA: Concurrencia detectada con conflicto de datos (Códigos iguales, Nombres distintos).';
        END IF;

        /* Reactivación (si el ganador estaba inactivo) */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Regimenes_Trabajo` 
            SET `Activo` = 1, `Descripcion` = _Descripcion, `updated_at` = NOW() 
            WHERE `Id_CatRegimen` = v_Id_Regimen;
            
            COMMIT; 
            SELECT 'Régimen reactivado (recuperado tras concurrencia).' AS Mensaje, v_Id_Regimen AS Id_Regimen, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        END IF;
        
        /* Éxito por Reuso */
        COMMIT; 
        SELECT 'Régimen ya existía (reusado tras concurrencia).' AS Mensaje, v_Id_Regimen AS Id_Regimen, 'REUSADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* Si falló por 1062 pero no encontramos el registro ni por Código (Caso extremo) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: Fallo de concurrencia no recuperable (Error Fantasma). Contacte a Soporte.';

END$$

DELIMITER ;

/* ============================================================================================
   PROCEDIMIENTO: SP_RegistrarRegion
   ============================================================================================
   1. OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   --------------------------------------
   Gestionar el alta de una nueva "Región Operativa" (ej: Región Marina, Región Sur) en el
   Catálogo Corporativo (`Cat_Regiones_Trabajo`).
   
   Este procedimiento actúa como una **Capa de Lógica de Negocio** (BLL) incrustada en la base de datos.
   Su función no es solo insertar, sino garantizar la unicidad, consistencia y reutilización de datos.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ---------------------------------------------------
   A) INTEGRIDAD DE DATOS (MANDATORY FIELDS):
      - Regla: "Datos completos o nada". Aunque la tabla pueda permitir nulos técnicos, el negocio
        exige que una Región tenga `Código` y `Nombre` para ser operativa.
      - Acción: Se rechazan valores nulos o vacíos antes de iniciar cualquier transacción.

   B) IDENTIDAD UNÍVOCA (DOBLE FACTOR):
      - Unicidad por CÓDIGO: No pueden existir dos regiones con clave 'RM-NE'.
      - Unicidad por NOMBRE: No pueden existir dos regiones llamadas 'REGIÓN MARINA NORESTE'.
      - Resolución: Se verifica primero el Código (Identificador fuerte) y luego el Nombre.

   3. ESTRATEGIA DE PERSISTENCIA Y CONCURRENCIA (ACID)
   ---------------------------------------------------
   A) BLOQUEO PESIMISTA (PESSIMISTIC LOCKING):
      - Se utiliza `SELECT ... FOR UPDATE` durante las verificaciones de existencia.
      - Justificación: Esto "congela" (adquiere un Write Lock) la fila encontrada. Evita que
        otro administrador modifique o reactive esa misma región mientras este proceso decide qué hacer.

   B) RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN):
      - Escenario: Dos usuarios envían la misma Región nueva al mismo tiempo (milisegundos de diferencia).
        Ambos pasan la validación de "No existe". Ambos intentan INSERT. El segundo fallará por `1062`.
      - Solución: Un `HANDLER` captura el error 1062, hace Rollback silencioso y busca el registro
        que acaba de crear el "ganador", devolviéndolo como éxito ("REUSADA").

   C) AUTOSANACIÓN (SELF-HEALING / SOFT DELETE RECOVERY):
      - Si la Región YA EXISTE pero estaba dada de baja (`Activo = 0`), el sistema no duplica ni falla.
      - Acción: "Resucita" el registro (`UPDATE Activo = 1`) y actualiza su descripción.

   RESULTADO (OUTPUT CONTRACT)
   ---------------------------
   Retorna un resultset con:
     - Mensaje: Feedback descriptivo.
     - Id_Region: La llave primaria del recurso.
     - Accion: Enumerador ('CREADA', 'REACTIVADA', 'REUSADA').
   ============================================================================================ */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarRegion`$$
CREATE PROCEDURE `SP_RegistrarRegion`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Recibimos los datos crudos del formulario.
       ----------------------------------------------------------------- */
    IN _Codigo      VARCHAR(50),   -- OBLIGATORIO: Clave corta (ej: 'RM-NE')
    IN _Nombre      VARCHAR(255),  -- OBLIGATORIO: Nombre oficial
    IN _Descripcion VARCHAR(255)   -- OPCIONAL: Notas adicionales
)
SP: BEGIN
    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ENTORNO
       ======================================================================================== */
    
    /* Variables de Persistencia (Snapshot del registro en BD si existe) */
    DECLARE v_Id_Region  INT DEFAULT NULL;
    DECLARE v_Activo     TINYINT(1) DEFAULT NULL;
    
    /* Variables para Validación Cruzada (Cross-Check de identidad) */
    DECLARE v_Nombre_Existente VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo_Existente VARCHAR(50) DEFAULT NULL;
    
    /* Bandera de Control de Flujo (Semáforo para errores de concurrencia) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062 - Duplicate Entry)
       Objetivo: Capturar colisiones de Unique Key en el INSERT final.
       Acción: No abortar. Encender bandera v_Dup = 1 para activar la rutina de recuperación. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos de infraestructura (Disco lleno, Conexión perdida, Syntax Error).
       Acción: Abortar inmediatamente, deshacer cambios (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN (FAIL FAST STRATEGY)
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios al inicio/final. Si la cadena queda vacía, la convertimos a NULL
       para facilitar la validación booleana estricta. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (Business Rule: NO VACÍOS)
       Validamos antes de abrir transacción para ahorrar recursos del servidor. */
    
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El CÓDIGO de la Región es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: El NOMBRE de la Región es obligatorio.';
    END IF;
    
    IF _Descripcion IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN: La DESCRIPCIÓN del Régimen es obligatoria.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: LÓGICA DE NEGOCIO TRANSACCIONAL
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RESOLUCIÓN DE IDENTIDAD POR CÓDIGO (PRIORIDAD ALTA)
       Verificamos si la clave única (_Codigo) ya está registrada.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Region = NULL;

    /* BLOQUEO PESIMISTA: 'FOR UPDATE'
       Asegura que si encontramos una región con este código, nadie más la toque mientras
       verificamos su nombre y estatus. */
    SELECT `Id_CatRegion`, `Nombre`, `Activo` 
    INTO v_Id_Region, v_Nombre_Existente, v_Activo
    FROM `Cat_Regiones_Trabajo`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;

    /* ESCENARIO A: EL CÓDIGO YA EXISTE */
    IF v_Id_Region IS NOT NULL THEN
        
        /* Validación de Integridad Cruzada:
           Regla: Si el código existe, el Nombre TAMBIÉN debe coincidir.
           Fallo: Si el código es 'RM-NE' pero el nombre existente es 'REGION SUR', tenemos
           un conflicto grave de datos. */
        IF v_Nombre_Existente <> _Nombre THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'ERROR DE CONFLICTO: El CÓDIGO ingresado ya existe pero pertenece a una Región con diferente NOMBRE. Verifique sus datos.';
        END IF;

        /* Sub-Escenario A.1: Existe pero está INACTIVO (Baja Lógica) -> REACTIVAR
           Esto es "Autosanación". Recuperamos el registro histórico. */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Regiones_Trabajo`
            SET `Activo` = 1,
				/* CAMBIO AQUÍ: Eliminé COALESCE. Se guarda el dato nuevo obligatoriamente. */
                `Descripcion` = _Descripcion, 
                `updated_at` = NOW()
            WHERE `Id_CatRegion` = v_Id_Region;
            
            COMMIT; 
            SELECT 'Región reactivada y actualizada exitosamente.' AS Mensaje, v_Id_Region AS Id_Region, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        
        /* Sub-Escenario A.2: Existe y está ACTIVO -> IDEMPOTENCIA
           El registro ya está tal como lo queremos. No hacemos nada. */
        ELSE
            COMMIT; 
            SELECT 'La Región ya se encuentra registrada y activa.' AS Mensaje, v_Id_Region AS Id_Region, 'REUSADA' AS Accion; 
            LEAVE SP;
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: RESOLUCIÓN DE IDENTIDAD POR NOMBRE (PRIORIDAD SECUNDARIA)
       Si llegamos aquí, el CÓDIGO es libre. Ahora verificamos si el NOMBRE ya está en uso.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Region = NULL;

    SELECT `Id_CatRegion`, `Codigo`, `Activo`
    INTO v_Id_Region, v_Codigo_Existente, v_Activo
    FROM `Cat_Regiones_Trabajo`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE;

    /* ESCENARIO B: EL NOMBRE YA EXISTE */
    IF v_Id_Region IS NOT NULL THEN
        /* Conflicto de Identidad:
           El nombre existe, pero tiene asociado OTRO código diferente al que intentamos registrar.
           (Nota: Como v_Codigo_Existente podría ser NULL en datos legacy, usamos lógica robusta) */
        
        IF v_Codigo_Existente IS NOT NULL AND v_Codigo_Existente <> _Codigo THEN
             SIGNAL SQLSTATE '45000' 
             SET MESSAGE_TEXT = 'ERROR DE CONFLICTO: El NOMBRE ingresado ya existe pero está asociado a otro CÓDIGO diferente.';
        END IF;
        
        /* Caso Especial: Enriquecimiento de Datos (Data Enrichment)
           El registro existía con Código NULL, y ahora le estamos asignando un Código válido. */
        IF v_Codigo_Existente IS NULL THEN
             UPDATE `Cat_Regiones_Trabajo` 
             SET `Codigo` = _Codigo, `updated_at` = NOW() 
             WHERE `Id_CatRegion` = v_Id_Region;
        END IF;

        /* Reactivación si estaba inactivo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Regiones_Trabajo` 
            SET `Activo` = 1, `updated_at` = NOW() 
            WHERE `Id_CatRegion` = v_Id_Region;
            
            COMMIT; 
            SELECT 'Región reactivada exitosamente (encontrada por Nombre).' AS Mensaje, v_Id_Region AS Id_Region, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        END IF;

        /* Idempotencia: Ya existe y está activo */
        COMMIT; 
        SELECT 'La Región ya existe (validada por Nombre).' AS Mensaje, v_Id_Region AS Id_Region, 'REUSADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.3: PERSISTENCIA (INSERCIÓN FÍSICA)
       Si pasamos todas las validaciones y no encontramos coincidencias, es un registro NUEVO.
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0; -- Reiniciamos bandera de error
    
    INSERT INTO `Cat_Regiones_Trabajo`
    (
        `Codigo`, 
        `Nombre`, 
        `Descripcion`,
        `Activo`,
        `created_at`,
        `updated_at`
    )
    VALUES
    (
        _Codigo, 
        _Nombre, 
        _Descripcion,
        1,      -- Activo por defecto
        NOW(),  -- Fecha Creación
        NOW()   -- Fecha Actualización
    );

    /* Verificación de Éxito: Si v_Dup sigue en 0, el INSERT funcionó y no hubo colisión */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'Región registrada exitosamente.' AS Mensaje, LAST_INSERT_ID() AS Id_Region, 'CREADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* ========================================================================================
       BLOQUE 4: RUTINA DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE)
       ========================================================================================
       Si el flujo llega aquí, v_Dup = 1.
       Diagnóstico: Ocurrió una "Race Condition". Otro usuario insertó el registro milisegundos
       antes que nosotros, disparando el Error 1062 (Duplicate Key).
       
       Acción: Recuperar el ID del registro "ganador" y devolverlo como si fuera nuestro. */
    
    ROLLBACK; -- Limpiamos la transacción fallida (para liberar bloqueos parciales)
    
    START TRANSACTION; -- Iniciamos nueva lectura limpia
    
    SET v_Id_Region = NULL;
    
    /* Intentamos recuperar por CÓDIGO (la restricción más fuerte) */
    SELECT `Id_CatRegion`, `Activo`, `Nombre`
    INTO v_Id_Region, v_Activo, v_Nombre_Existente
    FROM `Cat_Regiones_Trabajo`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;
    
    IF v_Id_Region IS NOT NULL THEN
        /* Validación de Seguridad: Confirmar que no sea un falso positivo */
        IF v_Nombre_Existente <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO DE SISTEMA: Concurrencia detectada con conflicto de datos (Códigos iguales, Nombres distintos).';
        END IF;

        /* Reactivación (si el ganador estaba inactivo) */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Regiones_Trabajo` 
            SET `Activo` = 1, `updated_at` = NOW() 
            WHERE `Id_CatRegion` = v_Id_Region;
            
            COMMIT; 
            SELECT 'Región reactivada (recuperada tras concurrencia).' AS Mensaje, v_Id_Region AS Id_Region, 'REACTIVADA' AS Accion; 
            LEAVE SP;
        END IF;
        
        /* Éxito por Reuso */
        COMMIT; 
        SELECT 'La Región ya existía (reusada tras concurrencia).' AS Mensaje, v_Id_Region AS Id_Region, 'REUSADA' AS Accion; 
        LEAVE SP;
    END IF;

    /* Si falló por 1062 pero no encontramos el registro ni por Código (Caso extremo de corrupción de índices) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA: Fallo de concurrencia no recuperable (Error Fantasma en Regiones). Contacte a Soporte.';

END$$

DELIMITER ;

/* ====================================================================================================
   PROCEDIMIENTO: SP_RegistrarPuesto
   ====================================================================================================
   
   1. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento implementa la lógica de ALTA TRANSACCIONAL para la entidad "Puesto de Trabajo"
   (`Cat_Puestos_Trabajo`). Su propósito es gestionar la creación de nuevos cargos en el catálogo
   corporativo, actuando como la única puerta de entrada para garantizar la calidad de los datos.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ----------------------------------------------------------------------------------------------------
   Para mantener un catálogo limpio y auditable, se aplican las siguientes restricciones de negocio:
   
     A) INTEGRIDAD DE DATOS (DATA COMPLETENESS):
        - El campo `Nombre` es el activo más valioso; no se permiten cadenas vacías o espacios.
        - El campo `Código` se exige como obligatorio en la capa de entrada (API Contract) para
          fomentar el orden, aunque el esquema de base de datos técnicamente permita nulos.

     B) IDENTIDAD UNÍVOCA DE DOBLE FACTOR (DUAL IDENTITY CHECK):
        - Unicidad por CÓDIGO: No pueden existir dos puestos con la clave 'PTO-001'.
        - Unicidad por NOMBRE: No pueden existir dos puestos con la denominación 'MÉDICO GENERAL'.
        - Resolución: El sistema verifica primero el Código (Identificador fuerte) y luego el Nombre
          (Identificador semántico).

   3. ESTRATEGIA DE PERSISTENCIA Y CONCURRENCIA (ACID COMPLIANCE)
   ----------------------------------------------------------------------------------------------------
   Este SP está diseñado para operar en entornos de alta concurrencia, utilizando patrones avanzados:

     A) BLOQUEO PESIMISTA (PESSIMISTIC LOCKING):
        - Utilizamos `SELECT ... FOR UPDATE` durante las verificaciones de existencia.
        - Efecto: Si dos administradores intentan crear el puesto "Supervisor" al mismo tiempo,
          la base de datos serializa las peticiones. El segundo usuario esperará a que el primero
          termine, evitando "Race Conditions" (Condiciones de Carrera).

     B) ENRIQUECIMIENTO DE DATOS (DATA ENRICHMENT):
        - Escenario: Existe el puesto "Secretaria" con Código NULL (dato heredado/legacy).
        - Acción: Si intentamos registrar "Secretaria" con el nuevo código "SEC-01", el sistema
          detecta la coincidencia por nombre y ACTUALIZA el código del registro existente en lugar
          de duplicarlo o rechazarlo.

     C) AUTOSANACIÓN (SELF-HEALING / SOFT DELETE RECOVERY):
        - Si el Puesto ya existe en la base de datos pero estaba dado de baja (`Activo = 0`),
          el sistema no lanza error. En su lugar, lo "resucita" (Reactiva) automáticamente y
          actualiza sus datos descriptivos.

     D) TOLERANCIA A FALLOS DE CONCURRENCIA (RE-RESOLVE PATTERN):
        - A pesar de los bloqueos, existe una ventana infinitesimal donde un INSERT concurrente
          podría generar un error nativo `1062 (Duplicate Key)`.
        - Solución: Implementamos un `HANDLER` que captura este error, revierte la transacción
          fallida y ejecuta una rutina de recuperación para devolver el registro que "ganó la carrera",
          simulando un éxito transparente para el usuario final.

   4. CONTRATO DE SALIDA (OUTPUT CONTRACT)
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset de una sola fila (Single Row) con:
     - Mensaje (VARCHAR): Feedback descriptivo para la UI.
     - Id_Puesto (INT): La llave primaria del recurso (creado o recuperado).
     - Accion (VARCHAR): Enumerador de estado ('CREADA', 'REACTIVADA', 'REUSADA').
   ==================================================================================================== */

DELIMITER $$

DROP PROCEDURE IF EXISTS `SP_RegistrarPuesto`$$

CREATE PROCEDURE `SP_RegistrarPuesto`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUTS)
       Recibimos los datos crudos del formulario. Se asumen cadenas de texto.
       ----------------------------------------------------------------- */
    IN _Codigo      VARCHAR(50),   -- OBLIGATORIO: Clave interna (ej: 'N34-A')
    IN _Nombre      VARCHAR(255),  -- OBLIGATORIO: Denominación del cargo
    IN _Descripcion VARCHAR(255)   -- OPCIONAL: Detalles de funciones
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ENTORNO
       Propósito: Inicializar contenedores para almacenar el estado de los datos y banderas de control.
       ================================================================================================ */
    
    /* Variables de Persistencia (Snapshot): Almacenan la "foto" del registro si ya existe en la BD */
    DECLARE v_Id_Puesto INT DEFAULT NULL;
    DECLARE v_Activo    TINYINT(1) DEFAULT NULL;
    
    /* Variables para Validación Cruzada (Cross-Check): Para detectar conflictos de identidad */
    DECLARE v_Nombre_Existente VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo_Existente VARCHAR(50) DEFAULT NULL;
    
    /* Bandera de Control de Flujo (Semáforo): Indica si ocurrió un error SQL controlado (ej: 1062) */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ================================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Garantizar que el SP nunca termine abruptamente sin limpiar la transacción.
       ================================================================================================ */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error MySQL 1062 - Duplicate Entry)
       Objetivo: Capturar colisiones de Unique Key en el INSERT final (nuestra red de seguridad).
       Estrategia: "Graceful Degradation". En lugar de abortar, encendemos la bandera v_Dup
       para activar la rutina de recuperación (Re-Resolve) más adelante. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos de infraestructura (Disco lleno, Conexión perdida, Error de Sintaxis).
       Estrategia: Abortar inmediatamente, deshacer cambios (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN (FAIL FAST PATTERN)
       Propósito: Rechazar datos inválidos antes de consumir recursos de transacción.
       ================================================================================================ */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios en blanco al inicio/final. Si la cadena queda vacía, la convertimos a NULL
       para facilitar la validación booleana estricta. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (Business Rule: NO VACÍOS)
       Regla de Negocio: Un Puesto sin nombre o código no es auditable ni funcional. */
    
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO del Puesto es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE del Puesto es obligatorio.';
    END IF;
    
    /* Nota: La descripción es opcional, por lo que no validamos su nulidad. */

    /* ================================================================================================
       BLOQUE 3: LÓGICA DE NEGOCIO TRANSACCIONAL (CORE)
       Propósito: Ejecutar la lógica de búsqueda, validación y persistencia de forma atómica.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: RESOLUCIÓN DE IDENTIDAD POR CÓDIGO (PRIORIDAD ALTA)
       
       Objetivo: Verificar si la clave única (_Codigo) ya está registrada en el sistema.
       Mecánica: Usamos `FOR UPDATE` para bloquear la fila encontrada. Esto asegura que nadie modifique
       este registro mientras nosotros decidimos qué hacer con él.
       ------------------------------------------------------------------------------------------------ */
    SET v_Id_Puesto = NULL; -- Reset de seguridad

    SELECT `Id_CatPuesto`, `Nombre`, `Activo` 
    INTO v_Id_Puesto, v_Nombre_Existente, v_Activo
    FROM `Cat_Puestos_Trabajo`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;

    /* ESCENARIO A: EL CÓDIGO YA EXISTE */
    IF v_Id_Puesto IS NOT NULL THEN
        
        /* Validación de Integridad Cruzada:
           Si el código existe, el Nombre TAMBIÉN debe coincidir.
           Si el código es igual pero el nombre es diferente, es un CONFLICTO DE DATOS. */
        IF v_Nombre_Existente <> _Nombre THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya existe pero pertenece a un Puesto con diferente NOMBRE. Verifique sus datos.';
        END IF;

        /* Sub-Escenario A.1: Existe pero está INACTIVO (Baja Lógica) -> REACTIVAR (Autosanación) */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Puestos_Trabajo`
            SET `Activo` = 1,
                `Descripcion` = COALESCE(_Descripcion, `Descripcion`), -- Actualizamos descripción si se proveyó
                `updated_at` = NOW()
            WHERE `Id_CatPuesto` = v_Id_Puesto;
            
            COMMIT; 
            SELECT 'ÉXITO: Puesto reactivado y actualizado correctamente.' AS Mensaje, v_Id_Puesto AS Id_Puesto, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        
        /* Sub-Escenario A.2: Existe y está ACTIVO -> IDEMPOTENCIA (Reportar éxito sin cambios) */
        ELSE
            COMMIT; 
            SELECT 'AVISO: El Puesto ya se encuentra registrado y activo.' AS Mensaje, v_Id_Puesto AS Id_Puesto, 'REUSADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: RESOLUCIÓN DE IDENTIDAD POR NOMBRE (PRIORIDAD SECUNDARIA)
       
       Objetivo: Si llegamos aquí, el CÓDIGO es libre. Ahora verificamos si el NOMBRE ya está en uso.
       Esto previene que se creen duplicados semánticos con códigos diferentes.
       ------------------------------------------------------------------------------------------------ */
    SET v_Id_Puesto = NULL; -- Reset de seguridad

    SELECT `Id_CatPuesto`, `Codigo`, `Activo`
    INTO v_Id_Puesto, v_Codigo_Existente, v_Activo
    FROM `Cat_Puestos_Trabajo`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE;

    /* ESCENARIO B: EL NOMBRE YA EXISTE */
    IF v_Id_Puesto IS NOT NULL THEN
        
        /* Conflicto de Identidad: Nombre existe con otro código distinto.
           Esto se considera un error porque un mismo puesto no debería tener dos claves. */
        IF v_Codigo_Existente IS NOT NULL AND v_Codigo_Existente <> _Codigo THEN
             SIGNAL SQLSTATE '45000' 
             SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya existe pero está asociado a otro CÓDIGO diferente.';
        END IF;
        
        /* Caso Especial: Enriquecimiento de Datos (Data Enrichment)
           El registro existía con Código NULL (dato viejo), y ahora le estamos asignando un Código válido. */
        IF v_Codigo_Existente IS NULL THEN
             UPDATE `Cat_Puestos_Trabajo` 
             SET `Codigo` = _Codigo, `updated_at` = NOW() 
             WHERE `Id_CatPuesto` = v_Id_Puesto;
        END IF;

        /* Reactivación si estaba inactivo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Puestos_Trabajo` 
            SET `Activo` = 1, `updated_at` = NOW() 
            WHERE `Id_CatPuesto` = v_Id_Puesto;
            
            COMMIT; 
            SELECT 'ÉXITO: Puesto reactivado correctamente (encontrado por Nombre).' AS Mensaje, v_Id_Puesto AS Id_Puesto, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;

        /* Idempotencia: Ya existe activo y con datos consistentes */
        COMMIT; 
        SELECT 'AVISO: El Puesto ya existe (validado por Nombre).' AS Mensaje, v_Id_Puesto AS Id_Puesto, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.3: PERSISTENCIA (INSERCIÓN FÍSICA)
       
       Si pasamos todas las validaciones anteriores, significa que no encontramos coincidencias.
       Es un registro totalmente NUEVO y seguro para insertar.
       ------------------------------------------------------------------------------------------------ */
    SET v_Dup = 0; -- Reiniciamos bandera de error
    
    INSERT INTO `Cat_Puestos_Trabajo`
    (
        `Codigo`, 
        `Nombre`, 
        `Descripcion`,
        `Activo`,
        `created_at`,
        `updated_at`
    )
    VALUES
    (
        _Codigo, 
        _Nombre, 
        _Descripcion,
        1,      -- Activo por defecto
        NOW(),  -- Fecha Creación
        NOW()   -- Fecha Actualización
    );

    /* Verificación de Éxito: Si v_Dup sigue en 0, el INSERT funcionó y no hubo colisión */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'ÉXITO: Puesto registrado correctamente.' AS Mensaje, LAST_INSERT_ID() AS Id_Puesto, 'CREADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ================================================================================================
       BLOQUE 4: RUTINA DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN)
       ================================================================================================
       Si el flujo llega aquí, v_Dup = 1.
       Diagnóstico: Ocurrió una "Race Condition". Otro usuario insertó el registro milisegundos
       antes que nosotros, disparando el Error 1062 (Duplicate Key) en el INSERT del Paso 3.3.
       
       Acción: Recuperar el ID del registro "ganador" y devolverlo como si fuera nuestro. */
    
    ROLLBACK; -- Limpiamos la transacción fallida (para liberar bloqueos parciales)
    
    START TRANSACTION; -- Iniciamos nueva transacción limpia
    
    SET v_Id_Puesto = NULL; -- Reset
    
    /* Intentamos recuperar por CÓDIGO (Identificador fuerte) */
    SELECT `Id_CatPuesto`, `Activo`, `Nombre`
    INTO v_Id_Puesto, v_Activo, v_Nombre_Existente
    FROM `Cat_Puestos_Trabajo`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;
    
    IF v_Id_Puesto IS NOT NULL THEN
        /* Validación de Seguridad: Confirmar que no sea un falso positivo */
        IF v_Nombre_Existente <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO DE SISTEMA [500]: Concurrencia detectada con conflicto de datos (Códigos iguales, Nombres distintos).';
        END IF;

        /* Reactivación (si el ganador estaba inactivo) */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Puestos_Trabajo` 
            SET `Activo` = 1, `updated_at` = NOW() 
            WHERE `Id_CatPuesto` = v_Id_Puesto;
            
            COMMIT; 
            SELECT 'ÉXITO: Puesto reactivado (recuperado tras concurrencia).' AS Mensaje, v_Id_Puesto AS Id_Puesto, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
        
        /* Reuso (Ya estaba activo) */
        COMMIT; 
        SELECT 'AVISO: El Puesto ya existía (reusado tras concurrencia).' AS Mensaje, v_Id_Puesto AS Id_Puesto, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* Fallo irrecuperable: Si falló por 1062 pero no encontramos el registro (Corrupción de índices o error fantasma) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [500]: Fallo de concurrencia no recuperable en Puestos.';

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_RegistrarRol
   ====================================================================================================
   
   1. CONTEXTO ARQUITECTÓNICO Y OBJETIVO DE NEGOCIO
   ----------------------------------------------------------------------------------------------------
   Este procedimiento constituye el **Núcleo de la Gestión de Seguridad (RBAC)**. 
   Implementa el patrón de "Alta Transaccional Idempotente" para la entidad `Cat_Roles`.
   Su objetivo es garantizar que la creación de perfiles de acceso sea atómica, consistente y 
   resistente a condiciones de carrera en entornos de alta concurrencia.

   2. REGLAS DE NEGOCIO Y RESTRICCIONES DURAS (HARD CONSTRAINTS)
   ----------------------------------------------------------------------------------------------------
   A) SANITIZACIÓN E INTEGRIDAD DE ENTRADA (INPUT HYGIENE):
      - Principio "Fail Fast": Se rechazan cadenas vacías o nulas antes de iniciar la transacción.
      - Normalización: `TRIM` forzoso para evitar duplicados visuales (" ADMIN" vs "ADMIN").

   B) IDENTIDAD DUAL (DUAL IDENTITY VERIFICATION):
      El sistema impone una restricción de unicidad de dos niveles:
      1. Nivel Técnico (Strong ID): El `Código` (Slug) debe ser único (ej: 'SYS_ADMIN').
      2. Nivel Semántico (Weak ID): El `Nombre` debe ser único (ej: 'Administrador del Sistema').
      
      * Resolución de Conflictos: Se prioriza la existencia del Código. Si el Código es nuevo 
        pero el Nombre ya existe bajo otro Código, se bloquea la operación para evitar ambigüedad.

   3. ESTRATEGIA DE VALIDACIÓN HÍBRIDA (DB vs APP LAYER)
   ----------------------------------------------------------------------------------------------------
   A) FLEXIBILIDAD DEL ESQUEMA (Database Layer):
      - La tabla `Cat_Roles` permite que `Descripcion` sea NULL.
      - Razón: Compatibilidad con procesos ETL o cargas masivas históricas (CSV).

   B) RIGIDEZ DEL PROCEDIMIENTO (Application Layer):
      - Regla: La `Descripcion` es OBLIGATORIA. No se permite crear roles "mudos" desde el sistema.
      - Justificación: Garantizar documentación viva dentro del catálogo de seguridad.

   4. ESTRATEGIA DE PERSISTENCIA Y CONCURRENCIA (ACID PATTERNS)
   ----------------------------------------------------------------------------------------------------
   A) BLOQUEO PESIMISTA (PESSIMISTIC WRITE LOCK):
      - Uso de `SELECT ... FOR UPDATE`.
      - Justificación: Serializa las peticiones concurrentes sobre un mismo recurso potencial. 
        Evita "Lecturas Fantasma" donde dos administradores validan "que no existe" al mismo tiempo.

   B) AUTOSANACIÓN (SELF-HEALING / SOFT DELETE RECOVERY):
      - Si el rol existe pero tiene `Activo = 0` (Borrado Lógico), el sistema NO devuelve error.
      - Acción: Reactiva el registro, actualiza sus metadatos (Descripción) y retorna éxito.

   C) PATRÓN DE RECUPERACIÓN "RE-RESOLVE" (CONCURRENCY TOLERANCE):
      - Maneja la ventana de tiempo infinitesimal entre el SELECT y el INSERT donde puede ocurrir 
        una colisión (Error 1062).
      - Mecánica: Captura el error -> Rollback Silencioso -> Nueva Transacción -> Lectura del Ganador.

   5. CONTRATO DE RESPUESTA (OUTPUT SPECIFICATION)
   ----------------------------------------------------------------------------------------------------
   Devuelve un Resultset de fila única con:
      - [Mensaje]: Feedback descriptivo para UI (Toast Notification).
      - [Id_Rol]: Llave primaria del recurso manipulado.
      - [Accion]: Enumerador de estado ('CREADA', 'REACTIVADA', 'REUSADA').
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarRol`$$

CREATE PROCEDURE `SP_RegistrarRol`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUT LAYER)
       Se asumen tipos de datos crudos (Raw Data) que requieren limpieza.
       ----------------------------------------------------------------- */
    IN _Codigo      VARCHAR(50),   -- OBLIGATORIO: Identificador técnico para Middlewares (ej: 'RH_SUPERVISOR')
    IN _Nombre      VARCHAR(255),  -- OBLIGATORIO: Etiqueta legible para la Interfaz de Usuario.
    IN _Descripcion VARCHAR(255)   -- OBLIGATORIO: Contexto detallado (Regla de Negocio Estricta)
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: INICIALIZACIÓN DE VARIABLES DE ENTORNO
       Propósito: Definir contenedores para el estado de la base de datos y banderas de control.
       ================================================================================================ */
    
    /* Variables de Snapshot: Capturan el estado actual del registro si es encontrado */
    DECLARE v_Id_Rol INT DEFAULT NULL;
    DECLARE v_Activo TINYINT(1) DEFAULT NULL;
    
    /* Variables de Cross-Check: Para validación cruzada de integridad (Código vs Nombre) */
    DECLARE v_Nombre_Existente VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo_Existente VARCHAR(50) DEFAULT NULL;
    
    /* Bandera de Semáforo: Controla el flujo lógico cuando ocurren excepciones SQL controladas */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ================================================================================================
       BLOQUE 1: DEFINICIÓN DE HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Asegurar la atomicidad y la recuperación ante fallos.
       ================================================================================================ */
    
    /* 1.1 HANDLER DE COLISIÓN (Error 1062 - Duplicate Entry)
       Estrategia: "Graceful Degradation". Si el INSERT falla por duplicado, no abortamos el SP.
       Marcamos la bandera v_Dup = 1 para activar la subrutina de recuperación (Re-Resolve). */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER CRÍTICO (SQLEXCEPTION)
       Estrategia: "Abort & Report". Ante fallos de sistema (conexión, disco, sintaxis), 
       revertimos cualquier cambio parcial y propagamos el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST STRATEGY)
       Propósito: Proteger la base de datos de datos basura antes de abrir transacciones costosas.
       ================================================================================================ */
    
    /* 2.1 NORMALIZACIÓN DE CADENAS
       Eliminamos espacios redundantes. NULLIF convierte cadenas vacías '' en NULL reales. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE INTEGRIDAD DE CAMPOS OBLIGATORIOS
       Regla: Un Rol sin Código, Nombre o Descripción es una entidad corrupta para el formulario. */
    
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El campo CÓDIGO es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El campo NOMBRE es obligatorio.';
    END IF;

    /* Aplicación de la Regla de Negocio Híbrida: Aunque la BD acepte NULL, aquí exigimos valor. */
    IF _Descripcion IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: La DESCRIPCIÓN del Rol es obligatoria. Debe detallar el alcance del permiso.';
    END IF;

    /* ================================================================================================
       BLOQUE 3: LÓGICA TRANSACCIONAL PRINCIPAL (CORE BUSINESS LOGIC)
       Propósito: Ejecutar la búsqueda, validación y persistencia de forma atómica.
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.1: VERIFICACIÓN PRIMARIA POR CÓDIGO (STRONG ID CHECK)
       Objetivo: Determinar si el identificador técnico ya existe.
       Estrategia: Bloqueo Pesimista (FOR UPDATE) para serializar el acceso a este registro.
       ------------------------------------------------------------------------------------------------ */
    SET v_Id_Rol = NULL; -- Reset de seguridad

    SELECT `Id_Rol`, `Nombre`, `Activo` 
    INTO v_Id_Rol, v_Nombre_Existente, v_Activo
    FROM `Cat_Roles`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* ESCENARIO A: EL CÓDIGO YA EXISTE EN LA BASE DE DATOS */
    IF v_Id_Rol IS NOT NULL THEN
        
        /* A.1 Validación de Consistencia Semántica
           Regla: Si el código existe, el Nombre asociado debe coincidir con el input.
           Si el código es igual pero el nombre diferente, es un conflicto de integridad. */
        IF v_Nombre_Existente <> _Nombre THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'CONFLICTO DE INTEGRIDAD [409]: El CÓDIGO ya existe pero pertenece a un Rol con distinto NOMBRE.';
        END IF;

        /* A.2 Autosanación (Self-Healing)
           Si el registro existe pero está borrado lógicamente (Activo=0), lo recuperamos. 
           NOTA: Se fuerza la actualización de la Descripción con el nuevo dato obligatorio. */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Roles`
            SET `Activo` = 1,
                `Descripcion` = _Descripcion, -- Actualización mandataria
                `updated_at` = NOW()
            WHERE `Id_Rol` = v_Id_Rol;
            
            COMMIT; 
            SELECT 'ÉXITO: Rol reactivado y actualizado.' AS Mensaje, v_Id_Rol AS Id_Rol, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        
        /* A.3 Idempotencia
           Si ya existe y está activo, no duplicamos ni fallamos. Reportamos éxito silente. */
        ELSE
            COMMIT; 
            SELECT 'AVISO: El Rol ya existe y está activo.' AS Mensaje, v_Id_Rol AS Id_Rol, 'REUSADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.2: VERIFICACIÓN SECUNDARIA POR NOMBRE (WEAK ID CHECK)
       Objetivo: Si el Código es nuevo, asegurarnos que el NOMBRE no esté ocupado por otro código.
       Esto previene duplicados semánticos (ej: dos roles 'Admin' con códigos distintos).
       ------------------------------------------------------------------------------------------------ */
    SET v_Id_Rol = NULL; -- Reset

    SELECT `Id_Rol`, `Codigo`, `Activo`
    INTO v_Id_Rol, v_Codigo_Existente, v_Activo
    FROM `Cat_Roles`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* ESCENARIO B: EL NOMBRE YA EXISTE */
    IF v_Id_Rol IS NOT NULL THEN
        
        /* B.1 Detección de Conflicto Cruzado
           El nombre existe, pero tiene un código diferente al que intentamos registrar. */
        IF v_Codigo_Existente IS NOT NULL AND v_Codigo_Existente <> _Codigo THEN
             SIGNAL SQLSTATE '45000' 
             SET MESSAGE_TEXT = 'CONFLICTO DE INTEGRIDAD [409]: El NOMBRE ya existe asociado a otro CÓDIGO diferente.';
        END IF;
        
        /* B.2 Data Enrichment (Caso Legacy)
           Si el registro existía con Código NULL (datos viejos), le asignamos el nuevo código. */
        IF v_Codigo_Existente IS NULL THEN
             UPDATE `Cat_Roles` SET `Codigo` = _Codigo, `updated_at` = NOW() WHERE `Id_Rol` = v_Id_Rol;
        END IF;

        /* B.3 Autosanación por Nombre
           Si estaba inactivo, lo reactivamos y nos aseguramos de guardar la nueva descripción. */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Roles` 
            SET `Activo` = 1, 
                `Descripcion` = _Descripcion, -- Actualización mandataria
                `updated_at` = NOW() 
            WHERE `Id_Rol` = v_Id_Rol;
            
            COMMIT; 
            SELECT 'ÉXITO: Rol reactivado (encontrado por Nombre).' AS Mensaje, v_Id_Rol AS Id_Rol, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;

        /* B.4 Idempotencia por Nombre */
        COMMIT; 
        SELECT 'AVISO: El Rol ya existe (validado por Nombre).' AS Mensaje, v_Id_Rol AS Id_Rol, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 3.3: PERSISTENCIA (INSERT FÍSICO)
       Si llegamos aquí, no hay colisiones. Procedemos a insertar.
       Aquí existe un riesgo infinitesimal de "Race Condition" si otro usuario inserta en este preciso instante.
       ------------------------------------------------------------------------------------------------ */
    SET v_Dup = 0; -- Reiniciar bandera de error
    
    INSERT INTO `Cat_Roles`
    (
        `Codigo`, 
        `Nombre`, 
        `Descripcion`,
        `Activo`,
        `created_at`,
        `updated_at`
    )
    VALUES
    (
        _Codigo, 
        _Nombre, 
        _Descripcion,
        1,      -- Default: Activo
        NOW(),  -- Timestamp Creación
        NOW()   -- Timestamp Actualización
    );

    /* Verificación de Éxito: Si v_Dup sigue en 0, el INSERT fue limpio. */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'ÉXITO: Rol creado correctamente.' AS Mensaje, LAST_INSERT_ID() AS Id_Rol, 'CREADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ================================================================================================
       BLOQUE 4: SUBRUTINA DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN)
       Propósito: Manejar elegantemente el Error 1062 (Duplicate Key) si ocurre una condición de carrera.
       ================================================================================================ */
    
    /* Si estamos aquí, v_Dup = 1. Significa que "perdimos" la carrera contra otro INSERT concurrente. */
    
    ROLLBACK; -- 1. Revertir la transacción fallida para liberar bloqueos parciales.
    
    START TRANSACTION; -- 2. Iniciar una nueva transacción limpia.
    
    SET v_Id_Rol = NULL;
    
    /* 3. Buscar el registro "ganador" (El que insertó el otro usuario) */
    SELECT `Id_Rol`, `Activo`, `Nombre`
    INTO v_Id_Rol, v_Activo, v_Nombre_Existente
    FROM `Cat_Roles`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;
    
    IF v_Id_Rol IS NOT NULL THEN
        /* Validación de Seguridad Post-Recuperación */
        IF v_Nombre_Existente <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE SISTEMA [500]: Concurrencia detectada con datos inconsistentes.';
        END IF;

        /* Reactivar si el ganador estaba inactivo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Roles` 
            SET `Activo` = 1, 
                `Descripcion` = _Descripcion, -- Actualización mandataria
                `updated_at` = NOW() 
            WHERE `Id_Rol` = v_Id_Rol;
            
            COMMIT; 
            SELECT 'ÉXITO: Rol reactivado (recuperado tras concurrencia).' AS Mensaje, v_Id_Rol AS Id_Rol, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
        
        /* Retornar el ID existente */
        COMMIT; 
        SELECT 'AVISO: El Rol ya existía (reusado tras concurrencia).' AS Mensaje, v_Id_Rol AS Id_Rol, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* Fallo Irrecuperable (Corrupción de índices o error fantasma) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [500]: Fallo de concurrencia no recuperable.';

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_RegistrarUsuarioNuevo
   ====================================================================================================
   TIPO: Transaccional / Self-Service / Onboarding
   
   1. VISIÓN ARQUITECTÓNICA Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento constituye el **Núcleo de Alta de Identidad** del sistema PICADE.
   Su propósito es orquestar el registro inicial de un nuevo colaborador garantizando una política de 
   "CERO TOLERANCIA A DUPLICADOS" y "CONSISTENCIA ATÓMICA".

   A diferencia de un simple INSERT, este componente actúa como un **Firewall Lógico** que impide
   la creación de cuentas basura, usuarios fantasma o registros inconsistentes.

   2. VECTORES DE SEGURIDAD Y REGLAS DE BLINDAJE (SECURITY PATCHES)
   ----------------------------------------------------------------------------------------------------
   A) ANTI-PARADOJA TEMPORAL (LOGICAL CONSISTENCY):
      - Problema: Registros con fechas incoherentes (ej: ingresar a trabajar antes de nacer).
      - Solución: Se validan cronológicamente `Fecha_Nacimiento` vs `Fecha_Ingreso`.
      - Regla Corporativa: Se bloquea el registro de menores de edad (18 años).

   B) ANTI-GEMELOS MALVADOS (IDENTITY SPOOFING PROTECTION):
      - Problema: Un usuario intenta registrarse nuevamente usando una Ficha o Email falsos, 
        pero con sus datos demográficos reales.
      - Solución: Se verifica la **Huella Digital Humana** (Nombre + Apellidos + Fecha Nacimiento).
      - Acción: Si la persona física ya existe en el sistema (bajo cualquier otra ficha), 
        se BLOQUEA la operación y se revela la ficha original.

   C) DIAGNÓSTICO DE ESTADO INTELIGENTE (SMART FEEDBACK):
      - Problema: Un error genérico "Ya existe" confunde al usuario.
      - Solución: El sistema diagnostica el estado del registro encontrado y responde:
          * Si está ACTIVO: Error [409-A] -> Sugiere "Recuperar Contraseña".
          * Si está INACTIVO: Error [409-B] -> Sugiere "Contactar al Administrador" (No reactiva auto).

   D) CONTROL DE CONCURRENCIA ESTRICTA (RACE CONDITION SHIELD):
      - Problema: Dos usuarios envían el formulario al mismo milisegundo.
      - Solución: Se utiliza un `HANDLER` para el error nativo `1062` (Duplicate Key).
      - Resultado: El segundo intento es rechazado y la transacción se revierte (ROLLBACK).

   3. ESTRATEGIA DE AUDITORÍA RECURSIVA (AUTO-PROVENANCE)
   ----------------------------------------------------------------------------------------------------
   - Reto: En un auto-registro, el campo `Created_By` no puede llenarse durante el INSERT porque
     el usuario aún no tiene ID.
   - Solución: Se implementa un patrón de **"Cierre de Círculo"**:
     1. Se insertan los datos con `Created_By = NULL`.
     2. Se recupera el ID generado.
     3. Se ejecuta un UPDATE inmediato para establecer `Created_By = [Nuevo_ID]`.
     Esto garantiza que ningún registro quede huérfano de trazabilidad.

   4. CONTRATO DE SALIDA
   ----------------------------------------------------------------------------------------------------
   Retorna un resultset con:
      - Mensaje: Feedback descriptivo.
      - Id_Usuario: ID generado.
      - Accion: 'CREADA'.
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarUsuarioNuevo`$$

CREATE PROCEDURE `SP_RegistrarUsuarioNuevo`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUT LAYER)
       Datos capturados en el formulario público de registro.
       NOTA: No se pide Foto aquí; eso es parte del perfilamiento posterior.
       ----------------------------------------------------------------- */
    IN _Ficha            VARCHAR(50),    -- Identificador Corporativo (Unique)
    IN _Email            VARCHAR(255),   -- Identificador de Sistema (Unique)
    IN _Contrasena       VARCHAR(255),   -- Hash de Seguridad
    IN _Nombre           VARCHAR(255),   -- Nombre(s) de Pila
    IN _Apellido_Paterno VARCHAR(255),   -- Primer Apellido
    IN _Apellido_Materno VARCHAR(255),   -- Segundo Apellido
    IN _Fecha_Nacimiento DATE,           -- Para validación de Huella Humana
    IN _Fecha_Ingreso    DATE            -- Para cálculo de antigüedad
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: VARIABLES DE ENTORNO Y DIAGNÓSTICO
       Propósito: Contenedores para evaluar el estado de la base de datos antes de escribir.
       ================================================================================================ */
    
    /* Variables para el Diagnóstico de Existencia */
    DECLARE v_Id_Encontrado INT DEFAULT NULL;
    DECLARE v_Estatus_Encontrado TINYINT(1) DEFAULT NULL;
    DECLARE v_Ficha_Original VARCHAR(50) DEFAULT NULL;
    
    /* Variables para la Integridad Referencial y Auditoría */
    DECLARE v_Id_InfoPersonal_Generado INT DEFAULT NULL;
    DECLARE v_Id_Usuario_Generado INT DEFAULT NULL;
    
    /* Variable auxiliar para construcción de mensajes dinámicos */
    DECLARE v_MensajeError VARCHAR(255);

    /* ================================================================================================
       BLOQUE 1: HANDLERS (MECANISMOS DE DEFENSA Y RECUPERACIÓN)
       ================================================================================================ */

    /* 1.1 HANDLER DE CONCURRENCIA (El Escudo Final - Error 1062)
       Objetivo: Proteger la integridad cuando dos peticiones simultáneas superan las validaciones de lectura. */
    DECLARE EXIT HANDLER FOR 1062
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR DE CONCURRENCIA [409]: Otro usuario acaba de registrar estos datos hace un momento. Por favor actualice la página.';
    END;

    /* 1.2 HANDLER DE FALLO TÉCNICO (SQLEXCEPTION)
       Objetivo: Garantizar Atomicidad ante fallos de servidor (crash, red, disco). */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: SANITIZACIÓN DE DATOS (INPUT HYGIENE)
       Propósito: Normalizar la entrada para asegurar consistencia en búsquedas futuras.
       ================================================================================================ */
    SET _Ficha            = TRIM(_Ficha);
    SET _Email            = TRIM(_Email);
    
    /* Estandarización Visual: Nombres en MAYÚSCULAS (Regla de Negocio para Reportes Oficiales) */
    SET _Nombre           = TRIM(UPPER(_Nombre));
    SET _Apellido_Paterno = TRIM(UPPER(_Apellido_Paterno));
    SET _Apellido_Materno = TRIM(UPPER(_Apellido_Materno));

    /* ================================================================================================
       BLOQUE 3: VALIDACIONES PREVIAS (FAIL FAST STRATEGY)
       Propósito: Rechazar datos inválidos o ilógicos antes de consultar la BD.
       ================================================================================================ */
    
    /* 3.1 Integridad de Campos Obligatorios */
    IF _Ficha = '' OR _Email = '' OR _Contrasena = '' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: Ficha, Email y Contraseña son obligatorios.';
    END IF;

    IF _Nombre = '' OR _Apellido_Paterno = '' OR _Apellido_Materno = '' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El nombre completo (con ambos apellidos) es obligatorio.';
    END IF;

    IF _Fecha_Nacimiento IS NULL OR _Fecha_Ingreso IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: Las fechas de Nacimiento e Ingreso son obligatorias.';
    END IF;

    /* 3.2 Lógica de Negocio: Paradoja Temporal */
    IF _Fecha_Ingreso < _Fecha_Nacimiento THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE LÓGICA [400]: La fecha de ingreso no puede ser anterior a la fecha de nacimiento.';
    END IF;

    /* 3.3 Lógica de Negocio: Restricción de Edad (+18) */
    IF TIMESTAMPDIFF(YEAR, _Fecha_Nacimiento, CURDATE()) < 18 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE LÓGICA [400]: El registro está restringido a mayores de 18 años.';
    END IF;

    /* ================================================================================================
       BLOQUE 4: MOTOR DE DIAGNÓSTICO DE EXISTENCIA (THE BRAIN)
       Propósito: Detectar duplicados y proporcionar una respuesta de negocio específica.
       ================================================================================================ */

    /* 4.1 DIAGNÓSTICO DE CREDENCIALES (FICHA) */
    SELECT `Id_Usuario`, `Activo` INTO v_Id_Encontrado, v_Estatus_Encontrado 
    FROM `Usuarios` WHERE `Ficha` = _Ficha LIMIT 1;

    IF v_Id_Encontrado IS NOT NULL THEN
        IF v_Estatus_Encontrado = 1 THEN
            /* Escenario: Usuario activo intenta registrarse de nuevo */
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409-A]: La Ficha ya está registrada y activa. ¿Olvidaste tu contraseña?';
        ELSE
            /* Escenario: Usuario bloqueado intenta registrarse */
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409-B]: La Ficha existe pero el acceso está restringido. Contacte al Administrador.';
        END IF;
    END IF;

    /* 4.2 DIAGNÓSTICO DE CREDENCIALES (EMAIL) */
    SET v_Id_Encontrado = NULL; -- Reset
    SELECT `Id_Usuario`, `Activo` INTO v_Id_Encontrado, v_Estatus_Encontrado 
    FROM `Usuarios` WHERE `Email` = _Email LIMIT 1;

    IF v_Id_Encontrado IS NOT NULL THEN
        IF v_Estatus_Encontrado = 1 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409-A]: El Correo ya está registrado y activo. ¿Olvidaste tu contraseña?';
        ELSE
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409-B]: El Correo existe pero el acceso está restringido. Contacte al Administrador.';
        END IF;
    END IF;

    /* 4.3 DIAGNÓSTICO DE HUELLA HUMANA (ANTI-SPOOFING)
       Objetivo: Detectar si la persona física ya existe, incluso si intenta usar Ficha/Email falsos. */
    SET v_Ficha_Original = NULL;
    
    SELECT U.Ficha, U.Activo
    INTO v_Ficha_Original, v_Estatus_Encontrado
    FROM Info_Personal I
    INNER JOIN Usuarios U ON U.Fk_Id_InfoPersonal = I.Id_InfoPersonal
    WHERE I.Nombre = _Nombre
      AND I.Apellido_Paterno = _Apellido_Paterno
      AND I.Apellido_Materno = _Apellido_Materno
      AND I.Fecha_Nacimiento = _Fecha_Nacimiento
    LIMIT 1;

    /* Si encontramos una coincidencia, revelamos la Ficha Original para detener el duplicado */
    IF v_Ficha_Original IS NOT NULL THEN
        IF v_Estatus_Encontrado = 1 THEN
            SET v_MensajeError = CONCAT('CONFLICTO [409-A]: Ya estás registrado en el sistema bajo la Ficha ', v_Ficha_Original, '. No se permiten duplicados de persona.');
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = v_MensajeError;
        ELSE
            SET v_MensajeError = CONCAT('CONFLICTO [409-B]: Ya existes en el sistema bajo la Ficha ', v_Ficha_Original, ' pero tu cuenta está desactivada. Contacte al Administrador.');
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = v_MensajeError;
        END IF;
    END IF;

    /* ================================================================================================
       BLOQUE 5: TRANSACCIÓN DE PERSISTENCIA (ESCRITURA ATÓMICA)
       Propósito: Guardar los datos de manera indivisible. O se guardan las 2 tablas, o ninguna.
       ================================================================================================ */
    START TRANSACTION;

    /* 5.1 INSERTAR DATOS PERSONALES (Identidad)
       Nota: Solo insertamos demográficos obligatorios. 
       Los campos de auditoría (Created_By) se dejan temporalmente en NULL hasta tener el ID de usuario. */
    INSERT INTO `Info_Personal` (
        `Nombre`, `Apellido_Paterno`, `Apellido_Materno`,
        `Fecha_Nacimiento`, `Fecha_Ingreso`,
        `created_at`
    ) VALUES (
        _Nombre, _Apellido_Paterno, _Apellido_Materno,
        _Fecha_Nacimiento, _Fecha_Ingreso,
        NOW()
    );

    /* Recuperamos el ID generado para vincularlo al usuario */
    SET v_Id_InfoPersonal_Generado = LAST_INSERT_ID();

    /* 5.2 INSERTAR CREDENCIALES DE USUARIO (Acceso)
       Nota: Insertamos con Rol Default (4=Participante).
       La Foto de Perfil tomará su valor DEFAULT NULL definido en el esquema. */
    INSERT INTO `Usuarios` (
        `Ficha`, `Email`, `Contraseña`, 
        `Fk_Id_InfoPersonal`, `Fk_Rol`,
        `created_at`
    ) VALUES (
        _Ficha, _Email, _Contrasena, 
        v_Id_InfoPersonal_Generado, 4,
        NOW()
    );

    /* Recuperamos el ID final del usuario para la auditoría recursiva */
    SET v_Id_Usuario_Generado = LAST_INSERT_ID();

    /* 5.3 AUTO-AUDITORÍA RECURSIVA (CERRANDO EL CÍRCULO)
       Objetivo: Cumplir con la trazabilidad. Como es un auto-registro, el usuario es su propio creador.
       Acción: Actualizamos los campos Created_By con el ID que acabamos de generar. */
    
    UPDATE `Usuarios` 
    SET `Fk_Usuario_Created_By` = v_Id_Usuario_Generado 
    WHERE `Id_Usuario` = v_Id_Usuario_Generado;

    UPDATE `Info_Personal` 
    SET `Fk_Id_Usuario_Created_By` = v_Id_Usuario_Generado 
    WHERE `Id_InfoPersonal` = v_Id_InfoPersonal_Generado;

    /* ================================================================================================
       BLOQUE 6: CONFIRMACIÓN Y RESPUESTA
       ================================================================================================ */
    COMMIT;

    /* Retorno de éxito para redirección en Frontend */
    SELECT 
        'ÉXITO: Usuario registrado correctamente.' AS Mensaje,
        v_Id_Usuario_Generado AS Id_Usuario,
        'CREADA' AS Accion;

END$$

DELIMITER ;

/* ====================================================================================================
   PROCEDIMIENTO: SP_RegistrarUsuarioPorAdmin
   ====================================================================================================
   
   1. PROPÓSITO Y OBJETIVO DE NEGOCIO (THE "WHY")
   ----------------------------------------------------------------------------------------------------
   Este procedimiento orquesta el **Alta Administrativa (Onboarding)** de nuevos colaboradores.
   A diferencia del registro público, este módulo asume que el operador (RH/Admin) posee la verdad 
   absoluta sobre la estructura organizacional, por lo que impone reglas de **Integridad Total**.
   
   Su misión es persistir, en una sola operación atómica, la identidad digital, la identidad humana,
   la ubicación física, la posición jerárquica, la trazabilidad de auditoría y, desde la v1.1,
   los activos multimedia asociados (Fotografía).

   2. VECTORES DE SEGURIDAD MITIGADOS (SECURITY POSTURE)
   ----------------------------------------------------------------------------------------------------
   A) INTEGRIDAD REFERENCIAL OPERATIVA ("ANTI-ZOMBIE RESOURCES"):
      - Riesgo: Asignar un empleado a un Departamento/Puesto que existe en BD pero fue dado de baja.
      - Defensa: Validación en tiempo real del flag `Activo = 1` para cada ID de catálogo foráneo.
   
   B) NO REPUDIO Y AUDITORÍA (NON-REPUDIATION):
      - Riesgo: Creación de usuarios fantasma por administradores malintencionados.
      - Defensa: Inyección obligatoria del `_Id_Admin_Ejecutor` en las columnas de auditoría 
        `Fk_Usuario_Created_By` en todas las tablas afectadas.
   
   C) CONSISTENCIA TEMPORAL (LOGICAL TIME):
      - Riesgo: Fechas incoherentes (ingreso < nacimiento) que rompen reportes de antigüedad.
      - Defensa: Validación aritmética de fechas antes de la escritura.

   D) INTEGRIDAD ATÓMICA (ACID):
      - Riesgo: Fallos parciales (se crea la persona pero no el usuario) dejando datos huérfanos.
      - Defensa: Encapsulamiento en `START TRANSACTION` ... `COMMIT` con `ROLLBACK` automático.

   E) GESTIÓN DE ACTIVOS MULTIMEDIA (NUEVO v1.1):
      - Contexto: El administrador puede cargar la foto oficial al momento del alta.
      - Tratamiento: Se recibe la ruta relativa (String). El almacenamiento físico (Blob/File) 
        es responsabilidad del Backend (Laravel/S3). La BD solo guarda el puntero lógico.

   3. ESPECIFICACIÓN DE ENTRADA/SALIDA (CONTRACT)
   ----------------------------------------------------------------------------------------------------
   - INPUT: 20 Parámetros tipados (Identidad, Foto, Demografía, Ubicación, Auditoría).
   - OUTPUT: Resultset único {Mensaje, Id_Generado, Accion}.
   - ERRORES: Códigos SQLSTATE personalizados [400, 403, 409, 500].
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarUsuarioPorAdmin`$$

CREATE PROCEDURE `SP_RegistrarUsuarioPorAdmin`(
    /* --------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS: AUDITORÍA (META-DATA)
       -------------------------------------------------------------------------------------------- */
    IN _Id_Admin_Ejecutor INT,          -- [OBLIGATORIO] ID del Admin que realiza la operación. 
                                        -- Se usará para llenar `Fk_Usuario_Created_By`.

    /* --------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS: IDENTIDAD Y ACCESO (USER ACCOUNT)
       -------------------------------------------------------------------------------------------- */
    IN _Ficha            VARCHAR(50),   -- [UNIQUE] Clave corporativa.
    IN _Url_Foto         VARCHAR(255),  -- [OPCIONAL] Ruta relativa de la foto de perfil (Update v1.1).
                                        -- Si es NULL, se asume que no se cargó foto inicial.
    /* --------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS: DATOS DEMOGRÁFICOS (HUMAN ENTITY)
       -------------------------------------------------------------------------------------------- */
    IN _Nombre           VARCHAR(255),  -- Nombre(s) de pila.
    IN _Apellido_Paterno VARCHAR(255),  -- Primer apellido.
    IN _Apellido_Materno VARCHAR(255),  -- Segundo apellido.
    IN _Fecha_Nacimiento DATE,          -- Usado para validar mayoría de edad y homonimia.
    IN _Fecha_Ingreso    DATE,          -- Usado para cálculo de antigüedad laboral.

	/* -----------------------------------------------------------------
	   2.5 SEGURIDAD Y ACCESOS Y PRIVILEGIOS (CRÍTICOS DE SISTEMA)
	   ----------------------------------------------------------------- */
    IN _Email            VARCHAR(255),  -- [UNIQUE] Clave de sistema.
    IN _Contrasena       VARCHAR(255),  -- [SEGURIDAD] Debe llegar ya hasheada (Bcrypt/Argon2) desde Backend.
    IN _Id_Rol           INT,           -- [FK] Nivel de privilegios (Admin, Instructor, etc.).

    /* --------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS: PERFIL LABORAL (MATRIZ DE ADSCRIPCIÓN)
       NOTA: En este SP, todos estos campos son OBLIGATORIOS para garantizar reportes completos.
       -------------------------------------------------------------------------------------------- */
    IN _Id_Regimen       INT,           -- [FK] Régimen de contratación (Planta/Transitorio).
    IN _Id_Puesto        INT,           -- [FK] Puesto funcional.
    IN _Id_CentroTrabajo INT,           -- [FK] Ubicación física.
    IN _Id_Departamento  INT,           -- [FK] Unidad departamental.
    IN _Id_Region        INT,           -- [FK] Región geográfica.
    IN _Id_Gerencia      INT,           -- [FK] Línea de mando.
    IN _Nivel            VARCHAR(50),   -- Dato tabular (Nivel salarial/jerárquico).
    IN _Clasificacion    VARCHAR(100)   -- Clasificación contractual.
)
THIS_PROC: BEGIN
    
    /* ============================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ESTADO
       Definición de contenedores en memoria para almacenar resultados intermedios.
       ============================================================================================ */
    
    /* Variables de Diagnóstico de Duplicidad */
    DECLARE v_Id_Encontrado INT DEFAULT NULL;           -- Almacena ID si encontramos colisión de cuenta.
    DECLARE v_Estatus_Encontrado TINYINT(1) DEFAULT NULL; -- Almacena si el duplicado está activo/inactivo.
    DECLARE v_Ficha_Original VARCHAR(50) DEFAULT NULL;  -- Almacena la ficha de una persona física duplicada.
    
    /* Variable de Enlace Relacional */
    DECLARE v_Id_InfoPersonal_Generado INT DEFAULT NULL; -- PK generada en tabla 1, FK para tabla 2.
    
    /* Variable de Validación de Vigencia */
    DECLARE v_Es_Activo TINYINT(1);                     -- Semáforo para validar si un catálogo sigue vivo.
    
    /* Variable de Mensajería */
    DECLARE v_MensajeError VARCHAR(255);                -- Contenedor para construir strings de error dinámicos.

    /* ============================================================================================
       BLOQUE 1: MANEJO DE EXCEPCIONES (DEFENSIVE PROGRAMMING)
       Define el comportamiento del sistema ante fallos previstos e imprevistos.
       ============================================================================================ */

    /* 1.1 HANDLER DE CONCURRENCIA (RACE CONDITION)
       [QUÉ]: Atrapa el error MySQL 1062 (Duplicate Entry for Key).
       [POR QUÉ]: Si dos admins envían la misma ficha al mismo tiempo, el motor de BD bloqueará al segundo.
       [ACCIÓN]: Revertir transacción (ROLLBACK) y notificar al usuario que "perdió la carrera". */
    DECLARE EXIT HANDLER FOR 1062
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'ERROR DE CONCURRENCIA [409]: Los datos acaban de ser registrados por otro administrador hace un instante. Actualice su lista.';
    END;

    /* 1.2 HANDLER DE FALLO CRÍTICO (SYSTEM FAILURE)
       [QUÉ]: Atrapa cualquier otro error SQL (Conexión, Disco, Sintaxis, Foreign Key inexistente).
       [POR QUÉ]: Garantizar la atomicidad. No queremos insertar `Info_Personal` si falla `Usuarios`.
       [ACCIÓN]: ROLLBACK total y propagación del error original (RESIGNAL) para logs del backend. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ============================================================================================
       BLOQUE 2: SANITIZACIÓN DE DATOS (DATA NORMALIZATION)
       Limpieza de inputs antes de cualquier lógica para asegurar consistencia.
       ============================================================================================ */
    
    /* 2.1 TRIMMING: Eliminar espacios basura al inicio/final. */
    SET _Ficha            = TRIM(_Ficha);
    SET _Email            = TRIM(_Email);
    SET _Url_Foto         = NULLIF(TRIM(_Url_Foto), ''); -- Convertir '' a NULL para integridad.
    
    /* 2.2 UPPERCASING: Estandarización visual para reportes oficiales. */
    SET _Nombre           = TRIM(UPPER(_Nombre));
    SET _Apellido_Paterno = TRIM(UPPER(_Apellido_Paterno));
    SET _Apellido_Materno = TRIM(UPPER(_Apellido_Materno));
    SET _Nivel            = TRIM(UPPER(_Nivel));
    SET _Clasificacion    = TRIM(UPPER(_Clasificacion));

    /* ============================================================================================
       BLOQUE 3: VALIDACIONES PREVIAS (FAIL FAST STRATEGY)
       Verificaciones ligeras en memoria. Si fallan, abortamos antes de tocar el disco.
       ============================================================================================ */
    
    /* 3.1 VALIDACIÓN DE AUDITORÍA
       [REGLA]: No existe "Registro Anónimo". Alguien debe hacerse responsable. */
    IF _Id_Admin_Ejecutor IS NULL OR _Id_Admin_Ejecutor <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE AUDITORÍA [403]: No se identificó al usuario administrador (Created_By) para la trazabilidad.';
    END IF;

    /* 3.2 VALIDACIÓN DE INTEGRIDAD DE IDENTIDAD
       [REGLA]: Campos mínimos para definir una entidad digital. */
    IF _Ficha = '' OR _Email = '' OR _Contrasena = '' OR _Nombre = '' OR _Apellido_Paterno = '' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: Los datos de Identidad (Ficha, Email, Nombre, Password) son obligatorios.';
    END IF;

    /* 3.3 VALIDACIÓN DE COMPLETITUD DE PERFIL
       [REGLA]: En Alta Administrativa no se permiten NULLs. El perfil debe ser funcional para reportes inmediatos.
       [LÓGICA]: Verificamos que todos los IDs de catálogo sean mayores a 0 y no NULL. */
    IF (_Id_Regimen <= 0 OR _Id_Regimen IS NULL) OR 
       (_Id_Puesto <= 0 OR _Id_Puesto IS NULL) OR 
       (_Id_CentroTrabajo <= 0 OR _Id_CentroTrabajo IS NULL) OR 
       (_Id_Departamento <= 0 OR _Id_Departamento IS NULL) OR 
       (_Id_Region <= 0 OR _Id_Region IS NULL) OR 
       (_Id_Gerencia <= 0 OR _Id_Gerencia IS NULL) OR
       (_Id_Rol <= 0 OR _Id_Rol IS NULL) THEN
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El Perfil Laboral está incompleto. Todos los campos (Puesto, Área, Ubicación, Rol) son obligatorios para el Alta Administrativa.';
    END IF;

    /* 3.4 VALIDACIÓN LÓGICA DE TIEMPO (ANTI-PARADOJA)
       [REGLA]: Un empleado no puede ser contratado antes de nacer. */
    IF _Fecha_Ingreso < _Fecha_Nacimiento THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE LÓGICA [400]: La fecha de ingreso no puede ser anterior a la fecha de nacimiento.';
    END IF;

    /* ============================================================================================
       BLOQUE 4: VALIDACIÓN DE VIGENCIA DE CATÁLOGOS (ANTI-ZOMBIE RESOURCES CHECK)
       [PROBLEMA]: El Frontend envió el ID 5 ("Ventas"), pero otro Admin lo desactivó hace 1 minuto.
       [SOLUCIÓN]: Consultar en tiempo real si el recurso sigue `Activo = 1`.
       ============================================================================================ */
    
    /* 4.1 Validar Vigencia de PUESTO */
    SET v_Es_Activo = NULL;
    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Puestos_Trabajo` WHERE `Id_CatPuesto` = _Id_Puesto LIMIT 1;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [409]: El Puesto seleccionado no existe o ha sido dado de baja operativa.';
    END IF;

    /* 4.2 Validar Vigencia de CENTRO DE TRABAJO */
    SET v_Es_Activo = NULL;
    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Centros_Trabajo` WHERE `Id_CatCT` = _Id_CentroTrabajo LIMIT 1;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [409]: El Centro de Trabajo seleccionado está inactivo.';
    END IF;

    /* 4.3 Validar Vigencia de DEPARTAMENTO */
    SET v_Es_Activo = NULL;
    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Departamentos` WHERE `Id_CatDep` = _Id_Departamento LIMIT 1;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [409]: El Departamento seleccionado está inactivo.';
    END IF;

    /* 4.4 Validar Vigencia de REGIÓN */
    SET v_Es_Activo = NULL;
    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Regiones_Trabajo` WHERE `Id_CatRegion` = _Id_Region LIMIT 1;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [409]: La Región seleccionada está inactiva.';
    END IF;

    /* 4.5 Validar Vigencia de ROL (SEGURIDAD) */
    SET v_Es_Activo = NULL;
    SELECT `Activo` INTO v_Es_Activo FROM `Cat_Roles` WHERE `Id_Rol` = _Id_Rol LIMIT 1;
    IF v_Es_Activo IS NULL OR v_Es_Activo = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [409]: El Rol de seguridad seleccionado está inactivo o no existe.';
    END IF;

    /* ============================================================================================
       BLOQUE 5: BLINDAJE DE DUPLICADOS (IDENTITY PROTECTION)
       Verificación profunda en BD para evitar colisiones de datos.
       ============================================================================================ */
    
    /* 5.1 VERIFICACIÓN DE CUENTA (FICHA)
       [REGLA]: La Ficha es el identificador único corporativo. No debe repetirse bajo ninguna circunstancia. */
    SELECT `Id_Usuario` INTO v_Id_Encontrado FROM `Usuarios` WHERE `Ficha` = _Ficha LIMIT 1;
    IF v_Id_Encontrado IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409]: La Ficha ingresada YA EXISTE en el sistema.';
    END IF;

    /* 5.2 VERIFICACIÓN DE CUENTA (EMAIL)
       [REGLA]: El correo es el identificador de acceso al sistema (Login). Debe ser único. */
    SET v_Id_Encontrado = NULL;
    SELECT `Id_Usuario` INTO v_Id_Encontrado FROM `Usuarios` WHERE `Email` = _Email LIMIT 1;
    IF v_Id_Encontrado IS NOT NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'CONFLICTO [409]: El Email ingresado YA EXISTE en el sistema.';
    END IF;

    /* 5.3 VERIFICACIÓN DE IDENTIDAD HUMANA (ANTI-GEMELOS)
       [PROBLEMA]: Un Admin intenta registrar a "Juan Pérez (01/01/1990)" con una Ficha NUEVA inventada.
       [DEFENSA]: Buscamos si esa persona física ya existe. Si sí, revelamos su ficha real y bloqueamos. */
    SET v_Ficha_Original = NULL;
    SELECT U.Ficha INTO v_Ficha_Original
    FROM Info_Personal I
    INNER JOIN Usuarios U ON U.Fk_Id_InfoPersonal = I.Id_InfoPersonal
    WHERE I.Nombre = _Nombre 
      AND I.Apellido_Paterno = _Apellido_Paterno 
      AND I.Apellido_Materno = _Apellido_Materno 
      AND I.Fecha_Nacimiento = _Fecha_Nacimiento
    LIMIT 1;

    IF v_Ficha_Original IS NOT NULL THEN
        SET v_MensajeError = CONCAT('CONFLICTO [409]: Esta persona física ya está registrada en el sistema bajo la Ficha: ', v_Ficha_Original, '. No se permiten duplicados de personal.');
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = v_MensajeError;
    END IF;

    /* ============================================================================================
       BLOQUE 6: TRANSACCIÓN DE ESCRITURA ATÓMICA (ACID WRITE)
       Punto de No Retorno: Si llegamos aquí, los datos son puros, válidos y únicos.
       ============================================================================================ */
    START TRANSACTION;

    /* --------------------------------------------------------------------------------------------
       PASO 6.1: PERSISTENCIA DE INFORMACIÓN PERSONAL (ENTIDAD MAESTRA)
       Insertamos los datos demográficos y la matriz de adscripción completa.
       -------------------------------------------------------------------------------------------- */
    INSERT INTO `Info_Personal` (
        `Nombre`, `Apellido_Paterno`, `Apellido_Materno`,
        `Fecha_Nacimiento`, `Fecha_Ingreso`,
        /* Matriz de Adscripción (Validada en Bloque 4) */
        `Fk_Id_CatRegimen`, `Fk_Id_CatPuesto`, 
        `Fk_Id_CatCT`, `Fk_Id_CatDep`, 
        `Fk_Id_CatRegion`, `Fk_Id_CatGeren`, 
        `Nivel`, `Clasificacion`,
        `Activo`,
        /* TRAZABILIDAD: Quién trajo a esta persona a la empresa */
        `Fk_Id_Usuario_Created_By` 
    ) VALUES (
        _Nombre, _Apellido_Paterno, _Apellido_Materno,
        _Fecha_Nacimiento, _Fecha_Ingreso,
        _Id_Regimen, _Id_Puesto, 
        _Id_CentroTrabajo, _Id_Departamento, 
        _Id_Region, _Id_Gerencia, 
        _Nivel, _Clasificacion,
        1, -- Activo por defecto (Alta Administrativa asume operatividad inmediata)
        _Id_Admin_Ejecutor -- Se guarda quién realizó el registro
    );

    /* Recuperamos la Primary Key generada (AUTO_INCREMENT) para vincularla al Usuario */
    SET v_Id_InfoPersonal_Generado = LAST_INSERT_ID();

    /* --------------------------------------------------------------------------------------------
       PASO 6.2: PERSISTENCIA DE CREDENCIALES (ENTIDAD USUARIO)
       Creamos el acceso al sistema vinculado a la persona creada.
       --------------------------------------------------------------------------------------------
       NOTA TÉCNICA: 
       - Aquí se realiza la inserción de la Foto de Perfil (_Url_Foto).
       - Si ocurre una concurrencia (Error 1062) en este punto, el HANDLER del Bloque 1 
         se activará, y se hará ROLLBACK automático de la inserción anterior (6.1). */
    
    INSERT INTO `Usuarios` (
        `Ficha`, `Email`, `Contraseña`, 
        `Fk_Id_InfoPersonal`, `Fk_Rol`,
        `Foto_Perfil_Url`,  /* Columna Nueva v1.1 */
        `Activo`,
        /* TRAZABILIDAD: Quién creó la cuenta de acceso */
        `Fk_Usuario_Created_By`
    ) VALUES (
        _Ficha, _Email, _Contrasena, 
        v_Id_InfoPersonal_Generado, _Id_Rol,
        _Url_Foto,          /* Valor del parámetro opcional v1.1 */
        1, -- Activo por defecto
        _Id_Admin_Ejecutor -- Se guarda quién creó la cuenta
    );

    /* ============================================================================================
       BLOQUE 7: CONFIRMACIÓN Y RESPUESTA (COMMIT & ACKNOWLEDGE)
       Si llegamos aquí, ambas tablas se escribieron correctamente. Hacemos permanentes los cambios.
       ============================================================================================ */
    COMMIT;

    /* Retorno de éxito estructurado para el consumo del API/Frontend */
    SELECT 
        'ÉXITO: Colaborador registrado, perfilado y auditado correctamente.' AS Mensaje,
        LAST_INSERT_ID() AS Id_Usuario, -- Retornamos el ID del nuevo usuario
        'CREADA' AS Accion;

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_RegistrarTipoInstruccion
   ====================================================================================================
   
   1. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   -------------------------------------------------------
   Este procedimiento gestiona el ALTA TRANSACCIONAL de un "Tipo de Instrucción" en el catálogo
   pedagógico (`Cat_Tipos_Instruccion_Cap`).
   
   Su propósito es clasificar la naturaleza de los cursos (ej: Teórico, Práctico, Mixto) para
   fines de logística y certificación. Actúa como la puerta de entrada única para garantizar
   que no existan clasificaciones duplicadas o ambiguas.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ---------------------------------------------------
   A) INTEGRIDAD DE DATOS (DATA HYGIENE):
      - Principio: "Datos limpios desde el origen".
      - Regla: El `Nombre` es el identificador semántico crítico. No se permiten nulos ni cadenas vacías.
      - Acción: Se aplica `TRIM` y validación `NOT NULL` antes de cualquier operación.

   B) IDENTIDAD UNÍVOCA (UNIQUE IDENTITY):
      - Regla: No pueden existir dos tipos con el mismo `Nombre` (ej: dos registros "Teórico").
      - Resolución: Si el nombre ya existe, el sistema evalúa si debe reutilizar el registro activo
        o reactivar uno histórico.

   3. ESTRATEGIA DE PERSISTENCIA Y CONCURRENCIA (ACID)
   ---------------------------------------------------
   A) BLOQUEO PESIMISTA (PESSIMISTIC LOCKING):
      - Se utiliza `SELECT ... FOR UPDATE` al buscar por Nombre.
      - Justificación: Esto "serializa" las peticiones. Si dos coordinadores intentan crear el tipo
        "Híbrido" al mismo tiempo, el segundo esperará a que el primero termine, evitando lecturas
        sucias o inconsistentes.

   B) AUTOSANACIÓN (SELF-HEALING / SOFT DELETE RECOVERY):
      - Escenario: El tipo "Práctico" existía hace años, se dio de baja (`Activo=0`) y ahora se
        quiere volver a usar.
      - Acción: El sistema detecta el registro "muerto", lo reactiva (`Activo=1`), actualiza su
        descripción con la nueva información y lo devuelve como éxito. No se crea un duplicado.

   C) PATRÓN "RE-RESOLVE" (MANEJO DE ERROR 1062):
      - Escenario Crítico: Una "Condición de Carrera" donde dos usuarios hacen INSERT en el mismo
        microsegundo. El motor de BD frenará al segundo con error `1062 (Duplicate Entry)`.
      - Solución: Un `HANDLER` captura el error, hace rollback silencioso y ejecuta una búsqueda
        final para devolver el ID del registro que "ganó", garantizando que el usuario nunca vea
        una pantalla de error técnico.

   4. CONTRATO DE SALIDA (OUTPUT SPECIFICATION)
   --------------------------------------------
   Retorna un Resultset de fila única con:
      - [Mensaje]: Feedback descriptivo (ej: "Tipo registrado exitosamente").
      - [Id_Tipo_Instruccion]: La llave primaria del recurso.
      - [Accion]: Enumerador de estado ('CREADA', 'REACTIVADA', 'REUSADA').
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarTipoInstruccion`$$

CREATE PROCEDURE `SP_RegistrarTipoInstruccion`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos los datos crudos del formulario.
       ----------------------------------------------------------------- */
    IN _Nombre      VARCHAR(255),  -- OBLIGATORIO: Identificador natural (ej: 'Teórico')
    IN _Descripcion VARCHAR(255)   -- OPCIONAL: Detalle técnico (ej: 'Requiere aula')
)
THIS_PROC: BEGIN
    
    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ENTORNO
       Propósito: Inicializar contenedores para el estado de la base de datos.
       ======================================================================================== */
    /* Variables de Persistencia (Snapshot del registro en BD) */
    DECLARE v_Id_Tipo  INT DEFAULT NULL;
    DECLARE v_Activo   TINYINT(1) DEFAULT NULL;
    
    /* Bandera de Control de Flujo (Semáforo para errores SQL) */
    DECLARE v_Dup      TINYINT(1) DEFAULT 0;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Asegurar la estabilidad del sistema ante fallos.
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062)
       Objetivo: Capturar colisiones de Unique Key en el INSERT.
       Acción: No abortar. Encender bandera v_Dup = 1 para activar la rutina de recuperación. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos técnicos (Disco lleno, Conexión).
       Acción: Abortar inmediatamente, deshacer cambios (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN (FAIL FAST STRATEGY)
       Propósito: Limpiar datos y rechazar basura antes de tocar la transacción.
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios al inicio/final. Si la cadena queda vacía, la convertimos a NULL. */
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD
       Regla: Un Tipo de Instrucción sin nombre no tiene valor semántico. */
    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE del Tipo de Instrucción es obligatorio.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: LÓGICA DE NEGOCIO TRANSACCIONAL (CORE)
       Propósito: Ejecutar la búsqueda, validación y persistencia de forma atómica.
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RESOLUCIÓN DE IDENTIDAD POR NOMBRE (BUSQUEDA PRIMARIA)
       
       Objetivo: Verificar si el concepto (_Nombre) ya existe en el catálogo.
       Mecánica: Usamos `FOR UPDATE` para bloquear la fila encontrada.
       Justificación: Esto evita que otro usuario modifique o reactive este mismo registro
       mientras nosotros tomamos la decisión.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Tipo = NULL; -- Reset de seguridad

    SELECT `Id_CatTipoInstCap`, `Activo` 
    INTO v_Id_Tipo, v_Activo
    FROM `Cat_Tipos_Instruccion_Cap`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* ESCENARIO A: EL NOMBRE YA EXISTE */
    IF v_Id_Tipo IS NOT NULL THEN
        
        /* Sub-Escenario A.1: Existe pero está INACTIVO (Baja Lógica) -> REACTIVAR (Autosanación)
           "Resucitamos" el registro y actualizamos su descripción si se proveyó una nueva. */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Tipos_Instruccion_Cap` 
            SET `Activo` = 1, 
                /* Lógica de Fusión: Si el usuario mandó descripción nueva, la usamos. 
                   Si no, mantenemos la histórica. */
                `Descripcion` = COALESCE(_Descripcion, `Descripcion`), 
                `updated_at` = NOW() 
            WHERE `Id_CatTipoInstCap` = v_Id_Tipo;
            
            COMMIT;
            SELECT 'ÉXITO: Tipo de Instrucción reactivado correctamente.' AS Mensaje, 
                   v_Id_Tipo AS Id_Tipo_Instruccion, 
                   'REACTIVADA' AS Accion;
            LEAVE THIS_PROC;
        
        /* Sub-Escenario A.2: Existe y está ACTIVO -> IDEMPOTENCIA
           El registro ya está tal como lo queremos. No hacemos nada y reportamos éxito. */
        ELSE
            COMMIT;
            SELECT 'AVISO: El Tipo de Instrucción ya existe y se encuentra activo.' AS Mensaje, 
                   v_Id_Tipo AS Id_Tipo_Instruccion, 
                   'REUSADA' AS Accion;
            LEAVE THIS_PROC;
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: PERSISTENCIA (INSERCIÓN FÍSICA)
       
       Si llegamos aquí, el registro no existe por Nombre. Es seguro intentar crearlo.
       Aquí existe un riesgo infinitesimal de "Race Condition" si otro usuario inserta 
       exactamente el mismo nombre en este preciso instante (cubierto por Handler 1062).
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0; -- Reiniciamos bandera de error
    
    INSERT INTO `Cat_Tipos_Instruccion_Cap`
    (
        `Nombre`, 
        `Descripcion`,
        `Activo`,
        `created_at`,
        `updated_at`
    )
    VALUES
    (
        _Nombre, 
        _Descripcion,
        1,      -- Default: Activo
        NOW(),  -- Timestamp Creación
        NOW()   -- Timestamp Actualización
    );

    /* Verificación de Éxito: Si v_Dup sigue en 0, el INSERT fue limpio. */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'ÉXITO: Tipo de Instrucción registrado correctamente.' AS Mensaje, 
               LAST_INSERT_ID() AS Id_Tipo_Instruccion, 
               'CREADA' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* ========================================================================================
       BLOQUE 4: RUTINA DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN)
       Propósito: Manejar elegantemente el Error 1062 (Duplicate Key) si ocurre una colisión.
       ======================================================================================== */
    
    /* Si estamos aquí, v_Dup = 1. Significa que "perdimos" la carrera contra otro INSERT. */
    
    ROLLBACK; -- 1. Revertir la transacción fallida para liberar bloqueos parciales.
    
    START TRANSACTION; -- 2. Iniciar una nueva transacción limpia.
    
    SET v_Id_Tipo = NULL;
    
    /* 3. Buscar el registro "ganador" (El que insertó el otro usuario) */
    SELECT `Id_CatTipoInstCap`, `Activo`
    INTO v_Id_Tipo, v_Activo
    FROM `Cat_Tipos_Instruccion_Cap`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE;
    
    IF v_Id_Tipo IS NOT NULL THEN
        /* Reactivar si el ganador estaba inactivo (caso muy raro en carrera, pero posible) */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Tipos_Instruccion_Cap` 
            SET `Activo` = 1, `updated_at` = NOW() 
            WHERE `Id_CatTipoInstCap` = v_Id_Tipo;
            
            COMMIT;
            SELECT 'ÉXITO: Tipo reactivado (recuperado tras concurrencia).' AS Mensaje, 
                   v_Id_Tipo AS Id_Tipo_Instruccion, 
                   'REACTIVADA' AS Accion;
            LEAVE THIS_PROC;
        END IF;
        
        /* Retornar el ID existente (Reuso) */
        COMMIT;
        SELECT 'AVISO: El Tipo ya existía (reusado tras concurrencia).' AS Mensaje, 
               v_Id_Tipo AS Id_Tipo_Instruccion, 
               'REUSADA' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* Fallo Irrecuperable: Si falló por 1062 pero no encontramos el registro 
       (Indica corrupción de índices o error fantasma grave) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [500]: Fallo de concurrencia no recuperable en Tipos de Instrucción.';

END$$

DELIMITER ;


/* ====================================================================================================
	PROCEDIMIENTO SP_RegistrarTemaCapacitacion
   ====================================================================================================

   ----------------------------------------------------------------------------------------------------
   1. CONTEXTO Y PROPÓSITO DEL NEGOCIO (BUSINESS CONTEXT)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento gestiona el ciclo de vida inicial (ALTA) de un "Tema de Capacitación" (Curso).
   Los Temas son el activo central del sistema de capacitación; representan el catálogo de conocimientos
   que la organización puede impartir (ej: "Seguridad Industrial Nivel 1", "Excel Avanzado").
   
   Su función no es simplemente insertar un dato. Actúa como un GUARDIÁN DE INTEGRIDAD que impide:
     a) La creación de cursos "huérfanos" (sin una clasificación pedagógica válida).
     b) La duplicidad de claves o nombres que generarían confusión operativa.
     c) La corrupción de datos por condiciones de carrera en entornos de alta concurrencia.

   ----------------------------------------------------------------------------------------------------
   2. REGLAS DE NEGOCIO ESTRICTAS (HARD CONSTRAINTS)
   ----------------------------------------------------------------------------------------------------
   [RN-01] INTEGRIDAD DE DATOS (MANDATORY FIELDS):
       - CÓDIGO: Es la llave maestra de identificación (ej: 'SEG-001'). NO puede ser Nulo.
       - NOMBRE: Es la identidad humana del curso. NO puede ser Nulo.
       - DURACIÓN: Es vital para el cálculo de horas-hombre. NO puede ser Nulo ni negativo.
       - TIPO DE INSTRUCCIÓN: Es la clasificación pedagógica. NO puede ser Nulo.

   [RN-02] INTEGRIDAD JERÁRQUICA (PARENT LOCKING):
       - Principio: "Un hijo no puede nacer de un padre muerto".
       - Validación: El Tipo de Instrucción (Padre) debe existir Y estar ACTIVO (1).
       - Seguridad: Se bloquea la fila del Padre durante la transacción para evitar que otro
         administrador lo desactive mientras se registra el curso.

   [RN-03] IDENTIDAD UNÍVOCA DE DOBLE FACTOR:
       - El sistema protege la unicidad por dos vías:
         1. Por CÓDIGO: No pueden existir dos cursos con la clave 'EXCEL-01'.
         2. Por NOMBRE: No pueden existir dos cursos llamados 'EXCEL BÁSICO'.
       - Resolución de Conflictos:
         * Si Coinciden Código y Nombre -> ÉXITO (Se reactiva o reutiliza el registro existente).
         * Si Coincide uno pero no el otro -> ERROR (Conflicto de Datos).

   ----------------------------------------------------------------------------------------------------
   3. ARQUITECTURA DE CONCURRENCIA (ACID & RECOVERY)
   ----------------------------------------------------------------------------------------------------
   [ESTRATEGIA]: BLOQUEO PESIMISTA + RECUPERACIÓN OPTIMISTA
   
   1. Bloqueo Pesimista (FOR UPDATE): Se utiliza al validar el Padre y al buscar duplicados.
      Esto serializa las operaciones conflictivas.
   
   2. Patrón "Re-Resolve" (Handler 1062):
      - Problema: Existe una ventana de microsegundos entre la validación (SELECT) y la inserción (INSERT)
        donde otro usuario podría insertar el mismo registro.
      - Solución: Si el motor de BD lanza un error de duplicado (1062), este SP lo captura,
        revierte la transacción fallida, y busca el registro "ganador" para devolverlo como éxito.
      - Beneficio: El usuario final jamás ve un error técnico por concurrencia.

   ----------------------------------------------------------------------------------------------------
   4. CONTRATO DE SALIDA (OUTPUT)
   ----------------------------------------------------------------------------------------------------
   Retorna un Resultset con:
     - Mensaje: Texto descriptivo para la UI.
     - Id_Tema: La llave primaria del recurso gestionado.
     - Accion: 'CREADA' (Nuevo), 'REACTIVADA' (Recuperado), 'REUSADA' (Existente).
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarTemaCapacitacion`$$

CREATE PROCEDURE `SP_RegistrarTemaCapacitacion`(
    /* ------------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos datos crudos. Se asume que requieren sanitización.
       ------------------------------------------------------------------------------------------------ */
    IN _Codigo          VARCHAR(50),   -- [OBLIGATORIO] Clave única interna.
    IN _Nombre          VARCHAR(255),  -- [OBLIGATORIO] Nombre descriptivo único.
    IN _Descripcion     VARCHAR(255),  -- [OPCIONAL] Temario o notas adicionales (Puede ser NULL).
    IN _Duracion_Horas  SMALLINT,      -- [OBLIGATORIO] Carga horaria (Debe ser > 0).
    IN _Id_TipoInst     INT            -- [OBLIGATORIO] FK hacia el catálogo de Tipos.
)
THIS_PROC: BEGIN
    
    /* ================================================================================================
       BLOQUE 0: INICIALIZACIÓN DE VARIABLES DE ENTORNO
       Propósito: Definir los contenedores que mantendrán el estado de la base de datos en memoria.
       ================================================================================================ */
    
    /* Variables de Diagnóstico (Snapshots del registro si ya existe) */
    DECLARE v_Id_Tema      INT DEFAULT NULL;
    DECLARE v_Activo       TINYINT(1) DEFAULT NULL;
    DECLARE v_Nombre_Exist VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo_Exist VARCHAR(50) DEFAULT NULL;
    
    /* Variables de Integridad Jerárquica (Estado del Padre) */
    DECLARE v_Padre_Existe INT DEFAULT NULL;
    DECLARE v_Padre_Activo TINYINT(1) DEFAULT NULL;

    /* Semáforo de Control de Errores (Bandera de Concurrencia) */
    DECLARE v_Dup          TINYINT(1) DEFAULT 0;

    /* ================================================================================================
       BLOQUE 1: DEFINICIÓN DE HANDLERS (SISTEMA DE DEFENSA)
       Propósito: Asegurar que el procedimiento termine de forma controlada ante cualquier eventualidad.
       ================================================================================================ */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062 - Duplicate Entry)
       Objetivo: Capturar colisiones de Unique Key en el INSERT final.
       Acción: No abortar. Encender bandera v_Dup = 1 para activar el protocolo de recuperación. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER DE FALLO CRÍTICO (SQLEXCEPTION)
       Objetivo: Capturar errores de infraestructura (Disco, Red, Sintaxis).
       Acción: Rollback total y propagación del error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ================================================================================================
       BLOQUE 2: SANITIZACIÓN Y NORMALIZACIÓN (DATA HYGIENE)
       Propósito: Limpiar los datos de entrada para evitar registros sucios o espacios invisibles.
       ================================================================================================ */
    
    /* Limpieza de cadenas: TRIM elimina espacios. NULLIF convierte cadenas vacías en NULL reales. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');
    
    /* Sanitización numérica: Convertir NULL o negativos a 0 para validación lógica posterior. */
    SET _Duracion_Horas = IFNULL(_Duracion_Horas, 0);

    /* ================================================================================================
       BLOQUE 3: VALIDACIONES PREVIAS (FAIL FAST STRATEGY)
       Propósito: Rechazar peticiones inválidas antes de consumir recursos de transacción.
       ================================================================================================ */
    
    /* Regla: El Código es la identidad técnica primaria. */
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO del Tema es obligatorio.';
    END IF;

    /* Regla: El Nombre es la identidad semántica. */
    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE del Tema es obligatorio.';
    END IF;

    /* Regla: Un curso sin duración o con duración negativa no es planificable. */
    IF _Duracion_Horas <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: La DURACIÓN debe ser un número mayor a 0.';
    END IF;

    /* Regla: Integridad Referencial Básica. */
    IF _Id_TipoInst IS NULL OR _Id_TipoInst <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: Debe seleccionar un TIPO DE INSTRUCCIÓN válido.';
    END IF;

    /* ================================================================================================
       BLOQUE 4: FASE TRANSACCIONAL (NÚCLEO DEL PROCESO)
       Propósito: Ejecutar la lógica de negocio de manera atómica (Todo o Nada).
       ================================================================================================ */
    START TRANSACTION;

    /* ------------------------------------------------------------------------------------------------
       PASO 4.1: VALIDACIÓN JERÁRQUICA (EL CANDADO DEL PADRE)
       Objetivo: Asegurar que el curso se asigne a una categoría válida y viva.
       Mecánica: `FOR UPDATE` bloquea la fila del Tipo de Instrucción.
       Justificación: Evita condiciones de carrera donde un Admin A desactiva el Tipo, mientras
       el Admin B crea un curso bajo ese Tipo.
       ------------------------------------------------------------------------------------------------ */
    SET v_Padre_Existe = NULL;
    SET v_Padre_Activo = NULL;

    SELECT 1, `Activo` 
    INTO v_Padre_Existe, v_Padre_Activo
    FROM `Cat_Tipos_Instruccion_Cap` 
    WHERE `Id_CatTipoInstCap` = _Id_TipoInst
    LIMIT 1 
    FOR UPDATE; -- <--- BLOQUEO PREVENTIVO AL PADRE

    /* Chequeo de Existencia */
    IF v_Padre_Existe IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE INTEGRIDAD [404]: El Tipo de Instrucción seleccionado no existe en el catálogo.';
    END IF;

    /* Chequeo de Vigencia */
    IF v_Padre_Activo = 0 THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE NEGOCIO [409]: El Tipo de Instrucción seleccionado está INACTIVO. No se pueden registrar nuevos temas bajo una categoría obsoleta.';
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 4.2: RESOLUCIÓN DE IDENTIDAD POR CÓDIGO (REGLA PRIMARIA)
       Objetivo: Verificar si la Clave Única ya existe.
       ------------------------------------------------------------------------------------------------ */
    SET v_Id_Tema = NULL;

    SELECT `Id_Cat_TemasCap`, `Activo`, `Nombre`
    INTO v_Id_Tema, v_Activo, v_Nombre_Exist
    FROM `Cat_Temas_Capacitacion`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE; -- Bloqueo preventivo a la fila si existe

    /* ESCENARIO A: EL CÓDIGO YA EXISTE */
    IF v_Id_Tema IS NOT NULL THEN
        
        /* Validación de Consistencia: Si el código existe, el nombre DEBE ser el mismo. 
           Si el código es igual pero el nombre diferente, es un conflicto de datos. */
        IF v_Nombre_Exist <> _Nombre THEN
            ROLLBACK;
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya existe pero pertenece a un Tema con diferente NOMBRE. Verifique sus datos.';
        END IF;

        /* Sub-Escenario A.1: Autosanación (Reactivar si estaba borrado lógico) */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Temas_Capacitacion`
            SET `Activo` = 1,
                `Descripcion`      = COALESCE(_Descripcion, `Descripcion`), -- Solo actualiza si hay dato nuevo
                `Duracion_Horas`   = _Duracion_Horas,
                `Fk_Id_CatTipoInstCap` = _Id_TipoInst, -- Actualizamos el padre por si cambió la asignación
                `updated_at`       = NOW()
            WHERE `Id_Cat_TemasCap` = v_Id_Tema;

            COMMIT;
            SELECT 'Tema reactivado y actualizado exitosamente.' AS Mensaje, v_Id_Tema AS Id_Tema, 'REACTIVADA' AS Accion;
            LEAVE THIS_PROC;
            
        /* Sub-Escenario A.2: Idempotencia (Ya existe y está activo) */
        ELSE
            COMMIT;
            SELECT 'El Tema ya se encuentra registrado y activo.' AS Mensaje, v_Id_Tema AS Id_Tema, 'REUSADA' AS Accion;
            LEAVE THIS_PROC;
        END IF;
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 4.3: RESOLUCIÓN DE IDENTIDAD POR NOMBRE (REGLA SECUNDARIA)
       Objetivo: Si el código es nuevo, verificamos que el NOMBRE no esté ocupado por otro código.
       ------------------------------------------------------------------------------------------------ */
    SET v_Id_Tema = NULL;
    SET v_Codigo_Exist = NULL;

    SELECT `Id_Cat_TemasCap`, `Activo`, `Codigo`
    INTO v_Id_Tema, v_Activo, v_Codigo_Exist
    FROM `Cat_Temas_Capacitacion`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE; -- Bloqueo preventivo

    /* ESCENARIO B: EL NOMBRE YA EXISTE */
    IF v_Id_Tema IS NOT NULL THEN
        
        /* Validación de Conflicto: El nombre existe, pero tiene un código diferente al ingresado.
           Esto se bloquea para evitar duplicados semánticos. */
        IF v_Codigo_Exist <> _Codigo THEN
             ROLLBACK;
             SIGNAL SQLSTATE '45000' 
             SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya existe pero está asociado a un CÓDIGO diferente.';
        END IF;
        
        /* Nota: Si el código coincidiera, habría caído en el PASO 4.2. 
           Si llegamos aquí y los códigos son distintos, es error definitivo. */
    END IF;

    /* ------------------------------------------------------------------------------------------------
       PASO 4.4: PERSISTENCIA (INSERCIÓN FÍSICA)
       Si llegamos aquí, no hay duplicados ni conflictos. El registro es nuevo y válido.
       ------------------------------------------------------------------------------------------------ */
    SET v_Dup = 0; -- Reiniciar bandera de control

    INSERT INTO `Cat_Temas_Capacitacion` (
        `Codigo`, 
        `Nombre`, 
        `Descripcion`, 
        `Duracion_Horas`, 
        `Fk_Id_CatTipoInstCap`,
        `Activo`,
        `created_at`,
        `updated_at`
    ) VALUES (
        _Codigo, 
        _Nombre, 
        _Descripcion, 
        _Duracion_Horas, 
        _Id_TipoInst,
        1,      -- Activo por defecto
        NOW(),  -- Created
        NOW()   -- Updated
    );

    /* Verificación de Éxito: Si la bandera v_Dup sigue en 0, el INSERT fue limpio. */
    IF v_Dup = 0 THEN
        COMMIT;
        SELECT 'Tema registrado exitosamente.' AS Mensaje, LAST_INSERT_ID() AS Id_Tema, 'CREADA' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* ================================================================================================
       BLOQUE 5: PROTOCOLO DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN)
       Propósito: Manejar el Error 1062 si alguien "ganó la carrera" de inserción milisegundos antes.
       ================================================================================================ */
    
    /* 1. Limpiamos la transacción fallida para liberar bloqueos parciales */
    ROLLBACK; 
    
    /* 2. Iniciamos nueva lectura limpia */
    START TRANSACTION;
    
    SET v_Id_Tema = NULL;

    /* 3. Buscamos al ganador por CÓDIGO (Identificador fuerte) */
    SELECT `Id_Cat_TemasCap`, `Activo`, `Nombre`
    INTO v_Id_Tema, v_Activo, v_Nombre_Exist
    FROM `Cat_Temas_Capacitacion`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;

    IF v_Id_Tema IS NOT NULL THEN
        /* Validación de seguridad: Que no sea un falso positivo con nombre distinto */
        IF v_Nombre_Exist <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [500]: Concurrencia detectada con inconsistencia de datos (Nombres no coinciden).';
        END IF;

        /* Si el ganador estaba inactivo, lo reactivamos nosotros */
        IF v_Activo = 0 THEN
             UPDATE `Cat_Temas_Capacitacion` SET `Activo` = 1, `updated_at` = NOW() WHERE `Id_Cat_TemasCap` = v_Id_Tema;
             COMMIT;
             SELECT 'Tema reactivado (recuperado tras concurrencia).' AS Mensaje, v_Id_Tema AS Id_Tema, 'REACTIVADA' AS Accion;
             LEAVE THIS_PROC;
        END IF;
        
        /* Si ya está activo, lo reusamos */
        COMMIT;
        SELECT 'El Tema ya existía (reusado tras concurrencia).' AS Mensaje, v_Id_Tema AS Id_Tema, 'REUSADA' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* 4. Fallo Irrecuperable (Corrupción de índices o error fantasma) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [500]: Fallo de concurrencia no recuperable al registrar Tema.';

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_RegistrarEstatusCapacitacion
   ====================================================================================================

   ----------------------------------------------------------------------------------------------------
   I. VISIÓN GENERAL Y OBJETIVO ESTRATÉGICO (EXECUTIVE SUMMARY)
   ----------------------------------------------------------------------------------------------------
   [DEFINICIÓN DEL COMPONENTE]:
   Este Stored Procedure actúa como el **Constructor de la Máquina de Estados** del sistema PICADE.
   Su responsabilidad es dar de alta los nodos lógicos que definirán el flujo de trabajo de las capacitaciones
   (ej: 'PROGRAMADO' -> 'EN CURSO' -> 'FINALIZADO').

   [EL PROBLEMA DE NEGOCIO (THE BUSINESS RISK)]:
   La integridad de los reportes operativos depende de que no existan estados duplicados, ambiguos o 
   "fantasmas". 
   - Riesgo 1 (Ambigüedad): Tener dos estados 'CANCELADO' y 'ANULADO' confunde a los usuarios y fragmenta la data.
   - Riesgo 2 (Inconsistencia): Un estado 'FINALIZADO' que no tenga la bandera `Es_Final=1` provocaría que 
     los cursos nunca liberen a sus instructores, bloqueando la programación futura.

   [LA SOLUCIÓN: GESTIÓN DE IDENTIDAD UNÍVOCA]:
   Este SP implementa una estrategia de **"Alta Inteligente con Autosanación"**.
   No solo inserta datos; verifica la existencia previa, resuelve conflictos de identidad y recupera 
   registros históricos ("Muertos") para evitar la proliferación de basura en la base de datos.

   ----------------------------------------------------------------------------------------------------
   II. DICCIONARIO DE REGLAS DE BLINDAJE (SECURITY & INTEGRITY RULES)
   ----------------------------------------------------------------------------------------------------
   
   [RN-01] INTEGRIDAD DE DATOS (MANDATORY FIELDS):
      - Principio: "Datos completos o nada".
      - Regla: El `Código` (ID Técnico) y el `Nombre` (ID Humano) son obligatorios.
      - Justificación: Un estatus sin código no puede ser referenciado por el backend. Un estatus sin nombre 
        es invisible para el usuario.
      - Nota: La `Descripción` es opcional (puede ir vacía).

   [RN-02] IDENTIDAD DE DOBLE FACTOR (DUAL IDENTITY CHECK):
      - Principio: "Unicidad Total".
      - Regla: No pueden existir dos estatus con el mismo CÓDIGO (ej: 'FIN'). Tampoco pueden existir dos 
        estatus con el mismo NOMBRE (ej: 'FINALIZADO').
      - Resolución: Se verifica primero el Código (Identificador fuerte) y luego el Nombre. Si hay conflicto 
        cruzado (mismo nombre, diferente código), se aborta para prevenir ambigüedad.

   [RN-03] AUTOSANACIÓN Y RECUPERACIÓN (SELF-HEALING PATTERN):
      - Principio: "Reciclar antes que crear".
      - Regla: Si el estatus que se intenta crear YA EXISTE pero fue eliminado lógicamente (`Activo=0`), 
        el sistema no lanza error. En su lugar, lo "resucita" (Reactiva), actualiza su configuración 
        (`Es_Final`, `Descripción`) y lo devuelve como éxito.

   [RN-04] TOLERANCIA A CONCURRENCIA (RACE CONDITION SHIELD):
      - Principio: "El usuario nunca ve un error técnico".
      - Escenario: Dos administradores intentan crear el mismo estatus al mismo tiempo.
      - Mecanismo: Se implementa el patrón "Re-Resolve". Si el INSERT falla por duplicado (Error 1062), 
        el SP captura el error, revierte la transacción y busca el registro "ganador" para devolverlo 
        como éxito transparente.

   ----------------------------------------------------------------------------------------------------
   III. ESPECIFICACIÓN TÉCNICA (DATABASE SPECS)
   ----------------------------------------------------------------------------------------------------
   - TIPO: Transacción ACID con Aislamiento Serializable (vía Row-Level Locking).
   - ESTRATEGIA DE BLOQUEO: `SELECT ... FOR UPDATE` (Pessimistic Locking).
     * Congela la fila encontrada o el rango de índice durante la validación.
     * Evita lecturas sucias y condiciones de carrera en la verificación de existencia.
   - IDEMPOTENCIA: Si se solicita crear un estatus que ya existe y es idéntico, el sistema retorna éxito 
     sin consumir ciclos de escritura (I/O Optimization).
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarEstatusCapacitacion`$$

CREATE PROCEDURE `SP_RegistrarEstatusCapacitacion`(
    /* ------------------------------------------------------------------------------------------------
       SECCIÓN DE PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos los datos crudos del formulario. Se asume que requieren sanitización.
       ------------------------------------------------------------------------------------------------ */
    IN _Codigo      VARCHAR(50),   -- [OBLIGATORIO] Clave única interna (ej: 'PROG').
    IN _Nombre      VARCHAR(255),  -- [OBLIGATORIO] Nombre descriptivo único (ej: 'PROGRAMADO').
    IN _Descripcion VARCHAR(255),  -- [OPCIONAL] Contexto detallado de uso.
    IN _Es_Final    TINYINT(1)     -- [CRÍTICO] Bandera de lógica de negocio (0=Vivo/Bloqueante, 1=Muerto/Liberador).
)
THIS_PROC: BEGIN
    
    /* ============================================================================================
       BLOQUE 0: INICIALIZACIÓN DE VARIABLES DE ENTORNO
       Definición de contenedores para almacenar el estado de la base de datos y diagnósticos.
       ============================================================================================ */
    
    /* Variables de Persistencia (Snapshot del registro en BD) */
    DECLARE v_Id_Estatus INT DEFAULT NULL;       -- Almacena el ID si encontramos el registro.
    DECLARE v_Activo     TINYINT(1) DEFAULT NULL; -- Almacena el estado actual (Activo/Inactivo).
    
    /* Variables para Validación Cruzada (Cross-Check de identidad) */
    DECLARE v_Nombre_Existente VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo_Existente VARCHAR(50) DEFAULT NULL;
    
    /* Bandera de Semáforo: Controla el flujo lógico cuando ocurren excepciones SQL controladas */
    DECLARE v_Dup TINYINT(1) DEFAULT 0;

    /* ============================================================================================
       BLOQUE 1: DEFINICIÓN DE HANDLERS (SISTEMA DE DEFENSA)
       Propósito: Asegurar que el procedimiento termine de forma controlada ante cualquier eventualidad.
       ============================================================================================ */
    
    /* 1.1 HANDLER DE COLISIÓN (Error 1062 - Duplicate Entry)
       Objetivo: Capturar colisiones de Unique Key en el INSERT final (nuestra red de seguridad).
       Estrategia: "Graceful Degradation". En lugar de abortar, encendemos la bandera v_Dup
       para activar la rutina de recuperación (Re-Resolve) más adelante. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER CRÍTICO (SQLEXCEPTION)
       Objetivo: Capturar fallos de infraestructura (Disco lleno, Conexión perdida, Error de Sintaxis).
       Estrategia: "Abort & Report". Ante fallos de sistema, revertimos cualquier cambio parcial 
       (ROLLBACK) y propagamos el error original (RESIGNAL) para los logs del backend. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ============================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN (FAIL FAST STRATEGY)
       Propósito: Proteger la base de datos de datos basura antes de abrir transacciones costosas.
       ============================================================================================ */
    
    /* 2.1 NORMALIZACIÓN DE CADENAS
       Eliminamos espacios redundantes (TRIM). NULLIF convierte cadenas vacías '' en NULL reales
       para facilitar la validación booleana estricta. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');
    
    /* Sanitización de Bandera Lógica: Si viene NULL, asumimos FALSE (0 - Bloqueante) por seguridad. */
    SET _Es_Final    = IFNULL(_Es_Final, 0);

    /* 2.2 VALIDACIÓN DE INTEGRIDAD DE CAMPOS OBLIGATORIOS
       Regla: Un Estatus sin Código o Nombre es una entidad corrupta. */
    
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO del estatus es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE del estatus es obligatorio.';
    END IF;

    /* 2.3 VALIDACIÓN DE DOMINIO (Valores permitidos)
       Regla de Negocio: Es_Final es binario. */
    IF _Es_Final NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE LÓGICA [400]: El campo Es_Final solo acepta 0 (Bloqueante) o 1 (Final).';
    END IF;

    /* ============================================================================================
       BLOQUE 3: LÓGICA TRANSACCIONAL PRINCIPAL (CORE BUSINESS LOGIC)
       Propósito: Ejecutar la búsqueda, validación y persistencia de forma atómica.
       ============================================================================================ */
    START TRANSACTION;

    /* --------------------------------------------------------------------------------------------
       PASO 3.1: VERIFICACIÓN PRIMARIA POR CÓDIGO (STRONG ID CHECK)
       Objetivo: Determinar si el identificador técnico ya existe.
       Estrategia: Bloqueo Pesimista (FOR UPDATE) para serializar el acceso a este registro.
       Esto evita que otro admin modifique este registro mientras lo evaluamos.
       -------------------------------------------------------------------------------------------- */
    SET v_Id_Estatus = NULL; -- Reset de seguridad

    SELECT `Id_CatEstCap`, `Nombre`, `Activo` 
    INTO v_Id_Estatus, v_Nombre_Existente, v_Activo
    FROM `Cat_Estatus_Capacitacion`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* ESCENARIO A: EL CÓDIGO YA EXISTE EN LA BASE DE DATOS */
    IF v_Id_Estatus IS NOT NULL THEN
        
        /* A.1 Validación de Consistencia Semántica
           Regla: Si el código existe, el Nombre asociado debe coincidir con el input.
           Fallo: Si el código es igual pero el nombre diferente, es un conflicto de integridad. */
        IF v_Nombre_Existente <> _Nombre THEN
            ROLLBACK; -- Liberamos el bloqueo antes de lanzar error
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya existe pero está asignado a otro nombre.';
        END IF;

        /* A.2 Autosanación (Self-Healing)
           Si el registro existe pero está borrado lógicamente (Activo=0), lo recuperamos.
           NOTA: Se actualizan también la Descripción y la bandera Es_Final con los datos nuevos. */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Estatus_Capacitacion`
            SET `Activo` = 1,
                /* Lógica de actualización: Si el usuario mandó nueva descripción, la usamos. 
                   Si mandó NULL, conservamos la antigua. */
                `Descripcion` = COALESCE(_Descripcion, `Descripcion`),
                `Es_Final` = _Es_Final, -- Actualización crítica de lógica de negocio
                `updated_at` = NOW()
            WHERE `Id_CatEstCap` = v_Id_Estatus;
            
            COMMIT;
            SELECT 'ÉXITO: Estatus recuperado y actualizado correctamente.' AS Mensaje, v_Id_Estatus AS Id_Estatus, 'REACTIVADA' AS Accion;
            LEAVE THIS_PROC;
        
        /* A.3 Idempotencia
           Si ya existe y está activo, no duplicamos ni fallamos. Reportamos éxito silente. */
        ELSE
            COMMIT;
            SELECT 'AVISO: El código del estatus ya existe y está activo.' AS Mensaje, v_Id_Estatus AS Id_Estatus, 'REUSADA' AS Accion;
            LEAVE THIS_PROC;
        END IF;
    END IF;

    /* --------------------------------------------------------------------------------------------
       PASO 3.2: VERIFICACIÓN SECUNDARIA POR NOMBRE (WEAK ID CHECK)
       Objetivo: Si el Código es nuevo, asegurarnos que el NOMBRE no esté ocupado por otro código.
       Esto previene duplicados semánticos (ej: dos estatus 'CANCELADO' con códigos distintos).
       -------------------------------------------------------------------------------------------- */
    SET v_Id_Estatus = NULL; -- Reset

    SELECT `Id_CatEstCap`, `Codigo`, `Activo`
    INTO v_Id_Estatus, v_Codigo_Existente, v_Activo
    FROM `Cat_Estatus_Capacitacion`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* ESCENARIO B: EL NOMBRE YA EXISTE */
    IF v_Id_Estatus IS NOT NULL THEN
        
        /* B.1 Detección de Conflicto Cruzado
           El nombre existe, pero tiene un código diferente al que intentamos registrar. */
        IF v_Codigo_Existente <> _Codigo THEN
             ROLLBACK;
             SIGNAL SQLSTATE '45000' 
             SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ya existe asociado a otro CÓDIGO diferente.';
        END IF;

        /* B.2 Data Enrichment (Caso Legacy)
           Si el registro existía con Código NULL (datos viejos), le asignamos el nuevo código. */
        IF v_Codigo_Existente IS NULL THEN
             UPDATE `Cat_Estatus_Capacitacion` SET `Codigo` = _Codigo, `updated_at` = NOW() WHERE `Id_CatEstCap` = v_Id_Estatus;
        END IF;

        /* B.3 Autosanación por Nombre
           Si estaba inactivo, lo reactivamos y actualizamos su configuración lógica. */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Estatus_Capacitacion` 
            SET `Activo` = 1, 
                `Descripcion` = COALESCE(_Descripcion, `Descripcion`),
                `Es_Final` = _Es_Final,
                `updated_at` = NOW() 
            WHERE `Id_CatEstCap` = v_Id_Estatus;
            
            COMMIT;
            SELECT 'ÉXITO: Estatus reactivado (encontrado por Nombre).' AS Mensaje, v_Id_Estatus AS Id_Estatus, 'REACTIVADA' AS Accion;
            LEAVE THIS_PROC;
        END IF;

        /* B.4 Idempotencia por Nombre */
        COMMIT;
        SELECT 'AVISO: El estatus ya existe y está activo.' AS Mensaje, v_Id_Estatus AS Id_Estatus, 'REUSADA' AS Accion;
        LEAVE THIS_PROC;
    END IF;

    /* --------------------------------------------------------------------------------------------
       PASO 3.3: PERSISTENCIA FÍSICA (INSERT)
       Si llegamos aquí, no hay colisiones conocidas. Procedemos a insertar.
       Aquí existe un riesgo infinitesimal de "Race Condition" si otro usuario inserta en este preciso instante.
       -------------------------------------------------------------------------------------------- */
    SET v_Dup = 0; -- Reiniciar bandera de error
    
    INSERT INTO `Cat_Estatus_Capacitacion`
    (
        `Codigo`, 
        `Nombre`, 
        `Descripcion`, 
        `Es_Final`, 
        `Activo`,
        `created_at`,
        `updated_at`
    )
    VALUES
    (
        _Codigo, 
        _Nombre, 
        _Descripcion, 
        _Es_Final,
        1,      -- Default: Activo
        NOW(),  -- Timestamp Creación
        NOW()   -- Timestamp Actualización
    );

    /* Verificación de Éxito: Si v_Dup sigue en 0, el INSERT fue limpio. */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'ÉXITO: Estatus registrado correctamente.' AS Mensaje, LAST_INSERT_ID() AS Id_Estatus, 'CREADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ============================================================================================
       BLOQUE 4: SUBRUTINA DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN)
       Propósito: Manejar elegantemente el Error 1062 (Duplicate Key) si ocurre una condición de carrera.
       ============================================================================================ */
    
    /* Si estamos aquí, v_Dup = 1. Significa que "perdimos" la carrera contra otro INSERT concurrente. */
    
    ROLLBACK; -- 1. Revertir la transacción fallida para liberar bloqueos parciales.
    
    START TRANSACTION; -- 2. Iniciar una nueva transacción limpia.
    
    SET v_Id_Estatus = NULL;
    
    /* 3. Buscar el registro "ganador" (El que insertó el otro usuario) */
    SELECT `Id_CatEstCap`, `Activo`, `Nombre`
    INTO v_Id_Estatus, v_Activo, v_Nombre_Existente
    FROM `Cat_Estatus_Capacitacion`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;
    
    IF v_Id_Estatus IS NOT NULL THEN
        /* Validación de Seguridad Post-Recuperación */
        IF v_Nombre_Existente <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [500]: Concurrencia detectada con conflicto de datos.';
        END IF;

        /* Reactivar si el ganador estaba inactivo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Estatus_Capacitacion` 
            SET `Activo` = 1, `Es_Final` = _Es_Final, `updated_at` = NOW() 
            WHERE `Id_CatEstCap` = v_Id_Estatus;
            
            COMMIT; 
            SELECT 'ÉXITO: Estatus reactivado (tras concurrencia).' AS Mensaje, v_Id_Estatus AS Id_Estatus, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
        
        /* Retornar el ID existente */
        COMMIT; 
        SELECT 'AVISO: Estatus ya existente (reusado tras concurrencia).' AS Mensaje, v_Id_Estatus AS Id_Estatus, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* Fallo Irrecuperable (Corrupción de índices o error fantasma) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [500]: Fallo de concurrencia no recuperable.';

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_RegistrarModalidadCapacitacion
   ====================================================================================================
   
   1. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento gestiona el ALTA TRANSACCIONAL de una "Modalidad de Capacitación" en el catálogo
   maestro (`Cat_Modalidad_Capacitacion`).
   
   Su propósito es clasificar la logística de impartición de los cursos (ej: Presencial, Virtual, Híbrido,
   Asincrónico). Actúa como la **Puerta de Entrada Única** (Single Gateway) para garantizar que no 
   existan modalidades duplicadas, ambiguas o con datos corruptos que afecten la programación de cursos.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ---------------------------------------------------
   A) INTEGRIDAD DE DATOS (DATA HYGIENE):
      - Principio: "Datos limpios desde el origen".
      - Regla: El `Código` y el `Nombre` son obligatorios. No se permiten cadenas vacías o espacios.
      - Acción: Se aplica `TRIM` y validación `NOT NULL` antes de cualquier operación.

   B) IDENTIDAD UNÍVOCA DE DOBLE FACTOR (DUAL IDENTITY CHECK):
      - Unicidad por CÓDIGO: No pueden existir dos modalidades con la clave 'VIRT'.
      - Unicidad por NOMBRE: No pueden existir dos modalidades llamadas 'VIRTUAL REMOTO'.
      - Resolución: Se verifica primero el Código (Identificador fuerte) y luego el Nombre.

   3. ESTRATEGIA DE PERSISTENCIA Y CONCURRENCIA (ACID & RACE CONDITIONS)
   ----------------------------------------------------------------------------------------------------
   A) BLOQUEO PESIMISTA (PESSIMISTIC LOCKING):
      - Se utiliza `SELECT ... FOR UPDATE` durante las verificaciones de existencia.
      - Justificación: Esto "serializa" las peticiones. Si dos administradores intentan crear la modalidad
        "Híbrido" al mismo tiempo, el segundo esperará a que el primero termine, evitando lecturas sucias.

   B) AUTOSANACIÓN (SELF-HEALING / SOFT DELETE RECOVERY):
      - Escenario: La modalidad "Presencial" existía, se dio de baja (`Activo=0`) y ahora se quiere volver a usar.
      - Acción: El sistema detecta el registro "muerto", lo reactiva (`Activo=1`), actualiza su descripción
        con la nueva información y lo devuelve como éxito. No se crea un duplicado físico.

   C) PATRÓN DE RECUPERACIÓN "RE-RESOLVE" (MANEJO DE ERROR 1062):
      - Escenario Crítico: Una "Condición de Carrera" donde dos usuarios hacen INSERT en el mismo microsegundo.
        El motor de BD frenará al segundo con error `1062 (Duplicate Entry)`.
      - Solución: Un `HANDLER` captura el error, hace rollback silencioso y ejecuta una búsqueda final
        para devolver el ID del registro que "ganó", garantizando una experiencia de usuario transparente.

   4. CONTRATO DE SALIDA (OUTPUT SPECIFICATION)
   --------------------------------------------
   Retorna un Resultset de fila única con:
      - [Mensaje]: Feedback descriptivo (ej: "Modalidad registrada exitosamente").
      - [Id_Modalidad]: La llave primaria del recurso.
      - [Accion]: Enumerador de estado ('CREADA', 'REACTIVADA', 'REUSADA').
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarModalidadCapacitacion`$$

CREATE PROCEDURE `SP_RegistrarModalidadCapacitacion`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos los datos crudos del formulario.
       ----------------------------------------------------------------- */
    IN _Codigo      VARCHAR(50),   -- [OBLIGATORIO] Identificador corto (ej: 'VIRT').
    IN _Nombre      VARCHAR(255),  -- [OBLIGATORIO] Nombre descriptivo (ej: 'VIRTUAL').
    IN _Descripcion VARCHAR(255)   -- [OPCIONAL] Detalles operativos (ej: 'Vía Teams/Zoom').
)
THIS_PROC: BEGIN
    
    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ENTORNO
       Propósito: Inicializar contenedores para el estado de la base de datos.
       ======================================================================================== */
    
    /* Variables de Persistencia (Snapshot): Almacenan la "foto" del registro si ya existe */
    DECLARE v_Id_Modalidad INT DEFAULT NULL;
    DECLARE v_Activo       TINYINT(1) DEFAULT NULL;
    
    /* Variables para Validación Cruzada (Cross-Check): Para detectar conflictos de identidad */
    DECLARE v_Nombre_Existente VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo_Existente VARCHAR(50) DEFAULT NULL;
    
    /* Bandera de Control de Flujo (Semáforo): Indica si ocurrió un error SQL controlado (1062) */
    DECLARE v_Dup          TINYINT(1) DEFAULT 0;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Asegurar la estabilidad del sistema ante fallos previstos e imprevistos.
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062 - Duplicate Entry)
       Objetivo: Capturar colisiones de Unique Key en el INSERT final (la red de seguridad).
       Acción: No abortar. Encender bandera v_Dup = 1 para activar la rutina de recuperación. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos técnicos (Disco lleno, Conexión perdida, Syntax Error).
       Acción: Abortar inmediatamente, deshacer cambios (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST STRATEGY)
       Propósito: Rechazar datos inválidos antes de consumir recursos de transacción.
       ======================================================================================== */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios al inicio/final. Si la cadena queda vacía, la convertimos a NULL
       para facilitar la validación booleana estricta. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (Business Rule: NO VACÍOS)
       Regla: Una Modalidad sin Código o Nombre es una entidad corrupta inutilizable. */
    
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO de la Modalidad es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE de la Modalidad es obligatorio.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: LÓGICA DE NEGOCIO TRANSACCIONAL (CORE)
       Propósito: Ejecutar la búsqueda, validación y persistencia de forma atómica.
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RESOLUCIÓN DE IDENTIDAD POR CÓDIGO (PRIORIDAD ALTA)
       
       Objetivo: Verificar si la clave única (_Codigo) ya está registrada en el sistema.
       Mecánica: Usamos `FOR UPDATE` para bloquear la fila encontrada.
       Justificación: Esto evita que otro usuario modifique o reactive este mismo registro
       mientras nosotros tomamos la decisión.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Modalidad = NULL; -- Reset de seguridad

    SELECT `Id_CatModalCap`, `Nombre`, `Activo` 
    INTO v_Id_Modalidad, v_Nombre_Existente, v_Activo
    FROM `Cat_Modalidad_Capacitacion`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* ESCENARIO A: EL CÓDIGO YA EXISTE */
    IF v_Id_Modalidad IS NOT NULL THEN
        
        /* A.1 Validación de Integridad Cruzada:
           Regla: Si el código existe, el Nombre TAMBIÉN debe coincidir.
           Fallo: Si el código es igual pero el nombre es diferente, es un CONFLICTO DE DATOS. */
        IF v_Nombre_Existente <> _Nombre THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya existe pero pertenece a una Modalidad con diferente NOMBRE. Verifique sus datos.';
        END IF;

        /* A.2 Sub-Escenario: Existe pero está INACTIVO (Baja Lógica) -> REACTIVAR (Autosanación)
           "Resucitamos" el registro y actualizamos su descripción si se proveyó una nueva. */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Modalidad_Capacitacion` 
            SET `Activo` = 1, 
                /* Lógica de Fusión: Si el usuario mandó descripción nueva, la usamos. 
                   Si no, mantenemos la histórica (COALESCE). */
                `Descripcion` = COALESCE(_Descripcion, `Descripcion`), 
                `updated_at` = NOW() 
            WHERE `Id_CatModalCap` = v_Id_Modalidad;
            
            COMMIT; 
            SELECT 'ÉXITO: Modalidad reactivada y actualizada correctamente.' AS Mensaje, v_Id_Modalidad AS Id_Modalidad, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        
        /* A.3 Sub-Escenario: Existe y está ACTIVO -> IDEMPOTENCIA
           El registro ya está tal como lo queremos. No hacemos nada y reportamos éxito. */
        ELSE
            COMMIT; 
            SELECT 'AVISO: La Modalidad ya se encuentra registrada y activa.' AS Mensaje, v_Id_Modalidad AS Id_Modalidad, 'REUSADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: RESOLUCIÓN DE IDENTIDAD POR NOMBRE (PRIORIDAD SECUNDARIA)
       
       Objetivo: Si llegamos aquí, el CÓDIGO es libre. Ahora verificamos si el NOMBRE ya está en uso.
       Esto previene que se creen duplicados semánticos con códigos diferentes (ej: 'VIRTUAL' vs 'VIRTUAL-1').
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Modalidad = NULL; -- Reset de seguridad

    SELECT `Id_CatModalCap`, `Codigo`, `Activo`
    INTO v_Id_Modalidad, v_Codigo_Existente, v_Activo
    FROM `Cat_Modalidad_Capacitacion`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE;

    /* ESCENARIO B: EL NOMBRE YA EXISTE */
    IF v_Id_Modalidad IS NOT NULL THEN
        
        /* B.1 Conflicto de Identidad:
           El nombre existe, pero tiene asociado OTRO código diferente al que intentamos registrar. */
        IF v_Codigo_Existente IS NOT NULL AND v_Codigo_Existente <> _Codigo THEN
             SIGNAL SQLSTATE '45000' 
             SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya existe pero está asociado a otro CÓDIGO diferente.';
        END IF;
        
        /* B.2 Caso Especial: Enriquecimiento de Datos (Data Enrichment)
           El registro existía con Código NULL (dato viejo), y ahora le estamos asignando un Código válido. */
        IF v_Codigo_Existente IS NULL THEN
             UPDATE `Cat_Modalidad_Capacitacion` 
             SET `Codigo` = _Codigo, `updated_at` = NOW() 
             WHERE `Id_CatModalCap` = v_Id_Modalidad;
        END IF;

        /* B.3 Reactivación si estaba inactivo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Modalidad_Capacitacion` 
            SET `Activo` = 1, `Descripcion` = COALESCE(_Descripcion, `Descripcion`), `updated_at` = NOW() 
            WHERE `Id_CatModalCap` = v_Id_Modalidad;
            
            COMMIT; 
            SELECT 'ÉXITO: Modalidad reactivada correctamente (encontrada por Nombre).' AS Mensaje, v_Id_Modalidad AS Id_Modalidad, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;

        /* B.4 Idempotencia: Ya existe y está activo */
        COMMIT; 
        SELECT 'AVISO: La Modalidad ya existe (validada por Nombre).' AS Mensaje, v_Id_Modalidad AS Id_Modalidad, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.3: PERSISTENCIA (INSERCIÓN FÍSICA)
       
       Si pasamos todas las validaciones y no encontramos coincidencias, es un registro NUEVO.
       Aquí existe un riesgo infinitesimal de "Race Condition" si otro usuario inserta 
       exactamente los mismos datos en este preciso instante (cubierto por Handler 1062).
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0; -- Reiniciamos bandera de error
    
    INSERT INTO `Cat_Modalidad_Capacitacion`
    (
        `Codigo`, 
        `Nombre`, 
        `Descripcion`, 
        `Activo`,
        `created_at`,
        `updated_at`
    )
    VALUES
    (
        _Codigo, 
        _Nombre, 
        _Descripcion, 
        1,      -- Activo por defecto (Born Alive)
        NOW(),  -- Timestamp Creación
        NOW()   -- Timestamp Actualización
    );

    /* Verificación de Éxito: Si v_Dup sigue en 0, el INSERT fue limpio. */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'ÉXITO: Modalidad registrada correctamente.' AS Mensaje, LAST_INSERT_ID() AS Id_Modalidad, 'CREADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ========================================================================================
       BLOQUE 4: RUTINA DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN)
       Propósito: Manejar elegantemente el Error 1062 (Duplicate Key) si ocurre una colisión.
       ======================================================================================== */
    
    /* Si estamos aquí, v_Dup = 1. Significa que "perdimos" la carrera contra otro INSERT. */
    
    ROLLBACK; -- 1. Revertir la transacción fallida para liberar bloqueos parciales.
    
    START TRANSACTION; -- 2. Iniciar una nueva transacción limpia.
    
    SET v_Id_Modalidad = NULL;
    
    /* 3. Buscar el registro "ganador" (El que insertó el otro usuario).
       Intentamos recuperar por CÓDIGO (la restricción más fuerte). */
    SELECT `Id_CatModalCap`, `Activo`, `Nombre`
    INTO v_Id_Modalidad, v_Activo, v_Nombre_Existente
    FROM `Cat_Modalidad_Capacitacion`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;
    
    IF v_Id_Modalidad IS NOT NULL THEN
        /* Validación de Seguridad: Confirmar que no sea un falso positivo (nombre distinto) */
        IF v_Nombre_Existente <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO DE SISTEMA [500]: Concurrencia detectada con conflicto de datos (Códigos iguales, Nombres distintos).';
        END IF;

        /* Reactivación (si el ganador estaba inactivo) */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Modalidad_Capacitacion` 
            SET `Activo` = 1, `Descripcion` = COALESCE(_Descripcion, `Descripcion`), `updated_at` = NOW() 
            WHERE `Id_CatModalCap` = v_Id_Modalidad;
            
            COMMIT; 
            SELECT 'ÉXITO: Modalidad reactivada (recuperada tras concurrencia).' AS Mensaje, v_Id_Modalidad AS Id_Modalidad, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
        
        /* Éxito por Reuso (El ganador ya estaba activo) */
        COMMIT; 
        SELECT 'AVISO: La Modalidad ya existía (reusada tras concurrencia).' AS Mensaje, v_Id_Modalidad AS Id_Modalidad, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* Fallo Irrecuperable: Si falló por 1062 pero no encontramos el registro 
       (Indica corrupción de índices o error fantasma grave) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [500]: Fallo de concurrencia no recuperable en Modalidades.';

END$$

DELIMITER ;


/* ====================================================================================================
   PROCEDIMIENTO: SP_RegistrarEstatusParticipante
   ====================================================================================================
   
   1. VISIÓN GENERAL Y OBJETIVO DE NEGOCIO (BUSINESS GOAL)
   ----------------------------------------------------------------------------------------------------
   Este procedimiento gestiona el ALTA TRANSACCIONAL de un "Estatus de Participante" en el catálogo
   maestro (`Cat_Estatus_Participante`).
   
   Su propósito es definir los posibles resultados finales de un asistente en un curso (ej: Aprobado, 
   Reprobado, No Asistió, Cancelado). Actúa como la **Puerta de Entrada Única** (Single Gateway) para 
   garantizar que no existan estados ambiguos que corrompan los reportes de cumplimiento normativo.

   2. REGLAS DE VALIDACIÓN ESTRICTA (HARD CONSTRAINTS)
   ---------------------------------------------------
   A) INTEGRIDAD DE DATOS (DATA HYGIENE):
      - Principio: "Datos limpios desde el origen".
      - Regla: El `Código` y el `Nombre` son obligatorios. No se permiten cadenas vacías o espacios.
      - Acción: Se aplica `TRIM` y validación `NOT NULL` antes de cualquier operación.

   B) IDENTIDAD UNÍVOCA DE DOBLE FACTOR (DUAL IDENTITY CHECK):
      - Unicidad por CÓDIGO: No pueden existir dos estatus con la clave 'APROB'.
      - Unicidad por NOMBRE: No pueden existir dos estatus llamados 'APROBADO'.
      - Resolución: Se verifica primero el Código (Identificador fuerte) y luego el Nombre.

   3. ESTRATEGIA DE PERSISTENCIA Y CONCURRENCIA (ACID & RACE CONDITIONS)
   ----------------------------------------------------------------------------------------------------
   A) BLOQUEO PESIMISTA (PESSIMISTIC LOCKING):
      - Se utiliza `SELECT ... FOR UPDATE` durante las verificaciones de existencia.
      - Justificación: Esto "serializa" las peticiones. Si dos administradores intentan crear el estatus
        "Oyente" al mismo tiempo, el segundo esperará a que el primero termine, evitando lecturas sucias.

   B) AUTOSANACIÓN (SELF-HEALING / SOFT DELETE RECOVERY):
      - Escenario: El estatus "Pendiente" existía, se dio de baja (`Activo=0`) y ahora se quiere volver a usar.
      - Acción: El sistema detecta el registro "muerto", lo reactiva (`Activo=1`), actualiza su descripción
        con la nueva información y lo devuelve como éxito. No se crea un duplicado físico.

   C) PATRÓN DE RECUPERACIÓN "RE-RESOLVE" (MANEJO DE ERROR 1062):
      - Escenario Crítico: Una "Condición de Carrera" donde dos usuarios hacen INSERT en el mismo microsegundo.
        El motor de BD frenará al segundo con error `1062 (Duplicate Entry)`.
      - Solución: Un `HANDLER` captura el error, hace rollback silencioso y ejecuta una búsqueda final
        para devolver el ID del registro que "ganó", garantizando una experiencia de usuario transparente.

   4. CONTRATO DE SALIDA (OUTPUT SPECIFICATION)
   --------------------------------------------
   Retorna un Resultset de fila única con:
      - [Mensaje]: Feedback descriptivo (ej: "Estatus registrado exitosamente").
      - [Id_Estatus_Participante]: La llave primaria del recurso.
      - [Accion]: Enumerador de estado ('CREADA', 'REACTIVADA', 'REUSADA').
   ==================================================================================================== */

DELIMITER $$

-- DROP PROCEDURE IF EXISTS `SP_RegistrarEstatusParticipante`$$

CREATE PROCEDURE `SP_RegistrarEstatusParticipante`(
    /* -----------------------------------------------------------------
       PARÁMETROS DE ENTRADA (INPUT LAYER)
       Recibimos los datos crudos del formulario.
       ----------------------------------------------------------------- */
    IN _Codigo      VARCHAR(50),   -- [OBLIGATORIO] Identificador corto (ej: 'APROB').
    IN _Nombre      VARCHAR(255),  -- [OBLIGATORIO] Nombre descriptivo (ej: 'APROBADO').
    IN _Descripcion VARCHAR(255)   -- [OPCIONAL] Detalles operativos (ej: 'Calif >= 8.0').
)
THIS_PROC: BEGIN
    
    /* ========================================================================================
       BLOQUE 0: DECLARACIÓN DE VARIABLES DE ENTORNO
       Propósito: Inicializar contenedores para el estado de la base de datos.
       ======================================================================================== */
    
    /* Variables de Persistencia (Snapshot): Almacenan la "foto" del registro si ya existe */
    DECLARE v_Id_Estatus INT DEFAULT NULL;
    DECLARE v_Activo       TINYINT(1) DEFAULT NULL;
    
    /* Variables para Validación Cruzada (Cross-Check): Para detectar conflictos de identidad */
    DECLARE v_Nombre_Existente VARCHAR(255) DEFAULT NULL;
    DECLARE v_Codigo_Existente VARCHAR(50) DEFAULT NULL;
    
    /* Bandera de Control de Flujo (Semáforo): Indica si ocurrió un error SQL controlado (1062) */
    DECLARE v_Dup          TINYINT(1) DEFAULT 0;

    /* ========================================================================================
       BLOQUE 1: HANDLERS (MANEJO ROBUSTO DE EXCEPCIONES)
       Propósito: Asegurar la estabilidad del sistema ante fallos previstos e imprevistos.
       ======================================================================================== */
    
    /* 1.1 HANDLER DE DUPLICIDAD (Error 1062 - Duplicate Entry)
       Objetivo: Capturar colisiones de Unique Key en el INSERT final (la red de seguridad).
       Acción: No abortar. Encender bandera v_Dup = 1 para activar la rutina de recuperación. */
    DECLARE CONTINUE HANDLER FOR 1062 SET v_Dup = 1;

    /* 1.2 HANDLER GENÉRICO (SQLEXCEPTION)
       Objetivo: Capturar fallos técnicos (Disco lleno, Conexión perdida, Syntax Error).
       Acción: Abortar inmediatamente, deshacer cambios (ROLLBACK) y propagar el error. */
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN 
        ROLLBACK; 
        RESIGNAL; 
    END;

    /* ========================================================================================
       BLOQUE 2: SANITIZACIÓN Y VALIDACIÓN PREVIA (FAIL FAST STRATEGY)
       Propósito: Rechazar datos inválidos antes de consumir recursos de transacción.
       ======================================================================================= */
    
    /* 2.1 LIMPIEZA DE DATOS (TRIM & NULLIF)
       Eliminamos espacios al inicio/final. Si la cadena queda vacía, la convertimos a NULL
       para facilitar la validación booleana estricta. */
    SET _Codigo      = NULLIF(TRIM(_Codigo), '');
    SET _Nombre      = NULLIF(TRIM(_Nombre), '');
    SET _Descripcion = NULLIF(TRIM(_Descripcion), '');

    /* 2.2 VALIDACIÓN DE OBLIGATORIEDAD (Business Rule: NO VACÍOS)
       Regla: Un Estatus sin Código o Nombre es una entidad corrupta inutilizable. */
    
    IF _Codigo IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El CÓDIGO del Estatus es obligatorio.';
    END IF;

    IF _Nombre IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR DE VALIDACIÓN [400]: El NOMBRE del Estatus es obligatorio.';
    END IF;

    /* ========================================================================================
       BLOQUE 3: LÓGICA DE NEGOCIO TRANSACCIONAL (CORE)
       Propósito: Ejecutar la búsqueda, validación y persistencia de forma atómica.
       ======================================================================================== */
    START TRANSACTION;

    /* ----------------------------------------------------------------------------------------
       PASO 3.1: RESOLUCIÓN DE IDENTIDAD POR CÓDIGO (PRIORIDAD ALTA)
       
       Objetivo: Verificar si la clave única (_Codigo) ya está registrada en el sistema.
       Mecánica: Usamos `FOR UPDATE` para bloquear la fila encontrada.
       Justificación: Esto evita que otro usuario modifique o reactive este mismo registro
       mientras nosotros tomamos la decisión.
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Estatus = NULL; -- Reset de seguridad

    SELECT `Id_CatEstPart`, `Nombre`, `Activo` 
    INTO v_Id_Estatus, v_Nombre_Existente, v_Activo
    FROM `Cat_Estatus_Participante`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE; -- <--- BLOQUEO DE ESCRITURA AQUÍ

    /* ESCENARIO A: EL CÓDIGO YA EXISTE */
    IF v_Id_Estatus IS NOT NULL THEN
        
        /* A.1 Validación de Integridad Cruzada:
           Regla: Si el código existe, el Nombre TAMBIÉN debe coincidir.
           Fallo: Si el código es igual pero el nombre es diferente, es un CONFLICTO DE DATOS. */
        IF v_Nombre_Existente <> _Nombre THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El CÓDIGO ingresado ya existe pero pertenece a un Estatus con diferente NOMBRE. Verifique sus datos.';
        END IF;

        /* A.2 Sub-Escenario: Existe pero está INACTIVO (Baja Lógica) -> REACTIVAR (Autosanación)
           "Resucitamos" el registro y actualizamos su descripción si se proveyó una nueva. */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Estatus_Participante` 
            SET `Activo` = 1, 
                /* Lógica de Fusión: Si el usuario mandó descripción nueva, la usamos. 
                   Si no, mantenemos la histórica (COALESCE). */
                `Descripcion` = COALESCE(_Descripcion, `Descripcion`), 
                `updated_at` = NOW() 
            WHERE `Id_CatEstPart` = v_Id_Estatus;
            
            COMMIT; 
            SELECT 'ÉXITO: Estatus reactivado y actualizado correctamente.' AS Mensaje, v_Id_Estatus AS Id_Estatus_Participante, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        
        /* A.3 Sub-Escenario: Existe y está ACTIVO -> IDEMPOTENCIA
           El registro ya está tal como lo queremos. No hacemos nada y reportamos éxito. */
        ELSE
            COMMIT; 
            SELECT 'AVISO: El Estatus ya se encuentra registrado y activo.' AS Mensaje, v_Id_Estatus AS Id_Estatus_Participante, 'REUSADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.2: RESOLUCIÓN DE IDENTIDAD POR NOMBRE (PRIORIDAD SECUNDARIA)
       
       Objetivo: Si llegamos aquí, el CÓDIGO es libre. Ahora verificamos si el NOMBRE ya está en uso.
       Esto previene que se creen duplicados semánticos con códigos diferentes (ej: 'APROBADO' vs 'APROBADO-1').
       ---------------------------------------------------------------------------------------- */
    SET v_Id_Estatus = NULL; -- Reset de seguridad

    SELECT `Id_CatEstPart`, `Codigo`, `Activo`
    INTO v_Id_Estatus, v_Codigo_Existente, v_Activo
    FROM `Cat_Estatus_Participante`
    WHERE `Nombre` = _Nombre
    LIMIT 1
    FOR UPDATE;

    /* ESCENARIO B: EL NOMBRE YA EXISTE */
    IF v_Id_Estatus IS NOT NULL THEN
        
        /* B.1 Conflicto de Identidad:
           El nombre existe, pero tiene asociado OTRO código diferente al que intentamos registrar. */
        IF v_Codigo_Existente IS NOT NULL AND v_Codigo_Existente <> _Codigo THEN
             SIGNAL SQLSTATE '45000' 
             SET MESSAGE_TEXT = 'CONFLICTO DE DATOS [409]: El NOMBRE ingresado ya existe pero está asociado a otro CÓDIGO diferente.';
        END IF;
        
        /* B.2 Caso Especial: Enriquecimiento de Datos (Data Enrichment)
           El registro existía con Código NULL (dato viejo), y ahora le estamos asignando un Código válido. */
        IF v_Codigo_Existente IS NULL THEN
             UPDATE `Cat_Estatus_Participante` 
             SET `Codigo` = _Codigo, `updated_at` = NOW() 
             WHERE `Id_CatEstPart` = v_Id_Estatus;
        END IF;

        /* B.3 Reactivación si estaba inactivo */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Estatus_Participante` 
            SET `Activo` = 1, `Descripcion` = COALESCE(_Descripcion, `Descripcion`), `updated_at` = NOW() 
            WHERE `Id_CatEstPart` = v_Id_Estatus;
            
            COMMIT; 
            SELECT 'ÉXITO: Estatus reactivado correctamente (encontrado por Nombre).' AS Mensaje, v_Id_Estatus AS Id_Estatus_Participante, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;

        /* B.4 Idempotencia: Ya existe y está activo */
        COMMIT; 
        SELECT 'AVISO: El Estatus ya existe (validado por Nombre).' AS Mensaje, v_Id_Estatus AS Id_Estatus_Participante, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ----------------------------------------------------------------------------------------
       PASO 3.3: PERSISTENCIA (INSERCIÓN FÍSICA)
       
       Si pasamos todas las validaciones y no encontramos coincidencias, es un registro NUEVO.
       Aquí existe un riesgo infinitesimal de "Race Condition" si otro usuario inserta 
       exactamente los mismos datos en este preciso instante (cubierto por Handler 1062).
       ---------------------------------------------------------------------------------------- */
    SET v_Dup = 0; -- Reiniciamos bandera de error
    
    INSERT INTO `Cat_Estatus_Participante`
    (
        `Codigo`, 
        `Nombre`, 
        `Descripcion`, 
        `Activo`,
        `created_at`,
        `updated_at`
    )
    VALUES
    (
        _Codigo, 
        _Nombre, 
        _Descripcion, 
        1,      -- Activo por defecto (Born Alive)
        NOW(),  -- Timestamp Creación
        NOW()   -- Timestamp Actualización
    );

    /* Verificación de Éxito: Si v_Dup sigue en 0, el INSERT fue limpio. */
    IF v_Dup = 0 THEN
        COMMIT; 
        SELECT 'ÉXITO: Estatus registrado correctamente.' AS Mensaje, LAST_INSERT_ID() AS Id_Estatus_Participante, 'CREADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* ========================================================================================
       BLOQUE 4: RUTINA DE RECUPERACIÓN DE CONCURRENCIA (RE-RESOLVE PATTERN)
       Propósito: Manejar elegantemente el Error 1062 (Duplicate Key) si ocurre una colisión.
       ======================================================================================== */
    
    /* Si estamos aquí, v_Dup = 1. Significa que "perdimos" la carrera contra otro INSERT. */
    
    ROLLBACK; -- 1. Revertir la transacción fallida para liberar bloqueos parciales.
    
    START TRANSACTION; -- 2. Iniciar una nueva transacción limpia.
    
    SET v_Id_Estatus = NULL;
    
    /* 3. Buscar el registro "ganador" (El que insertó el otro usuario).
       Intentamos recuperar por CÓDIGO (la restricción más fuerte). */
    SELECT `Id_CatEstPart`, `Activo`, `Nombre`
    INTO v_Id_Estatus, v_Activo, v_Nombre_Existente
    FROM `Cat_Estatus_Participante`
    WHERE `Codigo` = _Codigo
    LIMIT 1
    FOR UPDATE;
    
    IF v_Id_Estatus IS NOT NULL THEN
        /* Validación de Seguridad: Confirmar que no sea un falso positivo (nombre distinto) */
        IF v_Nombre_Existente <> _Nombre THEN
             SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO DE SISTEMA [500]: Concurrencia detectada con conflicto de datos (Códigos iguales, Nombres distintos).';
        END IF;

        /* Reactivación (si el ganador estaba inactivo) */
        IF v_Activo = 0 THEN
            UPDATE `Cat_Estatus_Participante` 
            SET `Activo` = 1, `Descripcion` = COALESCE(_Descripcion, `Descripcion`), `updated_at` = NOW() 
            WHERE `Id_CatEstPart` = v_Id_Estatus;
            
            COMMIT; 
            SELECT 'ÉXITO: Estatus reactivado (recuperado tras concurrencia).' AS Mensaje, v_Id_Estatus AS Id_Estatus_Participante, 'REACTIVADA' AS Accion; 
            LEAVE THIS_PROC;
        END IF;
        
        /* Éxito por Reuso (El ganador ya estaba activo) */
        COMMIT; 
        SELECT 'AVISO: El Estatus ya existía (reusado tras concurrencia).' AS Mensaje, v_Id_Estatus AS Id_Estatus_Participante, 'REUSADA' AS Accion; 
        LEAVE THIS_PROC;
    END IF;

    /* Fallo Irrecuperable: Si falló por 1062 pero no encontramos el registro 
       (Indica corrupción de índices o error fantasma grave) */
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR CRÍTICO [500]: Fallo de concurrencia no recuperable en Estatus de Participante.';

END$$

DELIMITER ;